
>**定义：** 进程是程序运行的过程，是系统进行资源分配和调度的**独立单位**。

# 1.进程模型

## 1.进程和程序

### 1.并行与并发

在知道什么是进程之前，我们先简单了解一下**并行**与**并发**。

> **并行：** 指系统能够同时处理多个任务的能力。在并发环境中，多个任务在**同一时间段内**交替执行，从宏观上看像是同时进行的，但在微观上（特别是在单核处理器上），它们可能是轮流执行的。

> **并行：** 指系统能够同时执行多个任务的能力。在并行环境中，多个任务在**同一时刻**真正地同时执行，互不干扰。

简单来说，并行就是在一个时刻，==多个人同时干活，每个人负责一项任务==；而并发是一个人在==一个时间段内需要完成很多任务==，但一个时刻只能干一件事，所以只能==在任务之间不断切换==，让所有任务都完成。

==并行和并发可以极大提高系统资源的利用率和吞吐量。==
### 2.什么是程序？

**程序** 是代码的集合，是数据的集合。我们平常所写的*cpp*文件，脚本，甚至一行命令等，都可以称为程序。==程序由代码组成，程序提供数据，但程序本身不运行==。

*程序就像是一本剧本，它可以提供情节，提供事件，但是光靠一本剧本是没法演剧的。*

### 3.什么是进程？

> **进程** 就是程序的运行过程。从程序启动，cpu调度，访问所需资源到程序执行完毕都是进程来实现。

当程序开始运行，进程就被创建，经过cpu的调度算法被调度执行。进程依靠 ==正确、有效的调度和资源管理== 来完成程序的运行过程，在一个程序中可以==同时运行多个任务==，从而完成并发。

*程序是剧本，而导演拿到剧本叫演员来演戏，发送视频到网上的过程属于一个进程。*

## 2.进程的命令视角

> 在一个操作系统中需要管理很多进程，**了解系统中的进程状态是对进程进行管理的前提，使用不同的命令可以从不同的角度查看进程状态**。

### 1.ps命令：进程信息

**ps命令**是Linux系统中最为常用的进程查看工具，主要用于显示包含当前运行的各进程完整信息的静态快照。通过不同的选项，可以有选择的查看进程信息。

- a ： 显示当前终端下的所有进程信息，包括其他用户的进程
- u ：以用户为主的进程状态
- x ：通常与 a 这个参数一起使用，显示当前用户在所有终端下的进程信息
- -e：显示系统内所有的进程信息
- -l ：使用长格式显示进程信息
- -f ：使用完整的格式显示进程信息

1. 执行“ps aux”命令。将以简单的列表形式显示出进程信息。

![[Pasted image 20260210210235.png]]
![[Pasted image 20260210210257.png]]

2. 执行“ps -elf”命令，将以长格式显示系统的进程信息，并包含更丰富的内容。
![[Pasted image 20260210210449.png]]

![[Pasted image 20260210210501.png]]

### 2.top命令：动态显示系统资源

top命令将会在当前终端以全名交互式的界面显示进程排名，及时跟踪CPU、内存等系统资源占用情况，默认情况下每三秒刷新一次，其作用类似于window系统中的任务管理器。
![[Pasted image 20260210211018.png]]

![[Pasted image 20260210210849.png]]

![[Pasted image 20260210210906.png]]

### 3.pstree命令：查看进程树

pstree命令可以输出Linux系统中各个进程的树形结构，更加直观地判断出各进程之间的关系。（Linux中为树结构，但其他操作系统并不一定与之相同，如window系统为层级结构）

![[Pasted image 20260210211420.png]]

### 4.pgrep命令

使用pgrep命令可以根据进程的名称、运行该进程的用户、进程所在终端等多种属性查询特定进程的ID号。

例如查看用户root正在运行的所有进程。
![[Pasted image 20260210211714.png]]

## 3.进程的组成

> **进程**由程**序段及其他相关数据段**（静态区）和**PCB**（进程控制块）组成。

进程就像造房子的过程，在这一个项目中，首先要拿到房子的==蓝图和流程图==（程序段、数据段），才能进行规划，否则造成什么样都不知道。但项目名称是什么，房子材料从哪来，工程目前状况以及需要哪些人才来造房子等等这些问题该如何记录，规划？这些问题由PCB（进程控制块）来解决。

**PCB 是一个专门的数据结构，用来描述进程的基本情况和运行状态，为控制和管理提供数据依据**。

## 4.PCB和PCB组织

### 1.PCB里包含的信息

- **进程标识符（PID）：** 进程唯一“身份证”。
- **进程控制管理信息：** 
	a.程序段和数据段的地址
	b.进程同步和通信信息
	c.资源清单地址
	d.进程队列指针
- **资源清单：** 内存地址、虚拟地址、打开文件列表、I/O设备信息等。
- **进程调度信息：** 进程状态、优先级、等待和使用CPU时间总和
- **处理机状态：** 处理机中寄存器内容，用来CPU切换时保存现场信息和恢复现场信息。

![[Pasted image 20260210220230.png]]

从图中我们可以浅显了解一下**CPU是如何根据PCB来进行进程调度**的（实际调度很复杂）。

首先我们知道现代操作系统都含有分时系统，利用==定时器来进行CPU的任务切换，也就是切换不同的进程==。

1. 在时间片内CPU执行当前进程。
2. **时间片到了，OS内核中断定时器**，保存当前进程信息（也就是当前上下文，更新PCB）
3. CPU根据一定调度算法找到下一个进程，获取其状态信息（PCB）
4. 开始新的时间片，CPU处理下一个进程


### 2.PCB组织
> 一个系统中由多个PCB组成，操作系统不能把它们“乱扔”，必须用某种数据结构把它们管理起来，以便快速查找、调度和回收。

#### 1. 线性、链式

这是最基础的组织方式。

- **线性组织**：将所有PCB放在一个数组或线性表中。操作系统维护一个指针或索引，遍历这个表来查找进程。
- **链式组织**：将所有PCB通过指针链接成一个或多个链表。
    - **就绪队列**：所有准备运行的进程连成一条链。
    - **阻塞队列**：所有等待I/O的进程连成一条链。
    - **运行队列**：当前正在运行的进程（单处理器通常只有一个）。

> **特点**：结构简单，适合进程数量不多的情况。但在进程数量巨大时，遍历查找的效率较低。

#### 2. 索引组织

这是为了提高查找效率而采用的高级组织方式，类似于书籍的目录。

- **原理**：系统为不同状态的进程建立**索引表**。
    - 例如，建立一张“就绪索引表”，表中每一项是一个指针，指向一个处于就绪状态的PCB。
    - 建立一张“阻塞索引表”，指向所有阻塞的PCB。
- **优势**：当操作系统需要查找某一状态的进程时，直接去查对应的索引表，速度极快，不需要遍历所有进程。

### 3.Linux中的PCB

![[Pasted image 20260209091811.png]]
![[Pasted image 20260209091726.png]]
![[Pasted image 20260209091701.png]]

从Linux内核的代码中我们可以看到，PCB其实是叫一个`task_struct`的**结构体**，它里面包含很多数据，如`pid`（PID号）、`tgid`和`mm_struct`（内存空间）等，在制作一个操作系统中这样的数据结构是必不可少的。

# 2.进程的编程方法

## 1.进程的创建

在遇到以下情况时会进行创建进程：

**系统初始化：** 启动操作系统时，通常会创建若干进程。如前台进程和守护进程。

**系统调用创建：** 一个正在运行的进程发出系统调用来创建一个或多个新进程来帮助完成其他工作。比如fork、exec函数族等。

**用户请求创建：** 双击程序运行或命令行下输入一个命令等。

**批处理创建：** 主要在大型机的批处理系统中应用。用户提交批处理作业，OS创建一个新进程并从输入队列中运行下一个作业。

下面我们用一个程序来了解一下进程的创建。

```c
#include <stdio.h>

#include <stdlib.h>

#include <sys/types.h>

#include <unistd.h>


//子线程的行为
void child() {

    printf("in child process %d...\n", getpid());


}

  
//父线程的行为
void parent() {


    printf("in parent process %d...\n", getpid());

}

  
//主函数
int main() {

    printf("fork test...\n");
    //printf("fork test...");

    pid_t pid;//PID，分辨当前进程

  

    pid = fork();//创建子线程，属于系统调用创建

	//如果创建失败，退出线程
    if (pid < 0) {

        perror("fork");

        exit(2);

    }

    // 此时 系统有两个进程和CPU进行抢，后面代码父 子 进程都要执行

    switch (pid) {

        case 0:     // 此时在子进程中

            child();

            break;

        default:    // pid为大于0的数，表示进程号，父进程生成子进程的ID号

            parent();

            break;

    }

  

    return 0;

}
```

运行结果：
![[Pasted image 20260210223316.png]]
这说明进程创建成功。

但是当我们把`printf("fork test...\n");`中的`\n`去掉，运行结果会和我们想的不太一样。

![[Pasted image 20260210223519.png]]

可以发现，`printf`只有一句，可是为什么会==打印两遍相同的内容==呢？
其实这与**进程的创建**和`printf`**打印机制**有关。

1. `printf`**打印机制：** 语句执行完不会立即打印内容到I/O设备上，而是先==放在缓冲区将许多内容一起冲刷打印到I/O设备==中。那么什么时候清理缓冲区呢？常见的方式有三种：**内容太多，缓冲区满了**、**程序执行结束**和**遇到特定符号，如`\n`**。

2. **进程的创建：** `fork()`函数创建的机制其实是复制，将该进程已有的资源完整复制一份来创建子进程，子进程会与父进程抢占cpu（抢占是随机的），通过返回值（pid）来区分父子进程。

![[Pasted image 20260210225009.png]]

既然创建子进程的时候会复制资源，那么==父进程资源内缓冲区里的内容==自然也会在子进程保留一份。由于没有`\n`，`fork test...`信息仍然在缓冲区内并同时存在于父子进程中，==当父子进程各自结束程序时都会一并打印缓冲区内容，所以才会打印两次相同的内容==。

---
我们再来修改一些数据：

```cpp

//全局变量
int abc=100;

//子线程的行为
void child() {
	abc=200;
    printf("in child process %d...\n", getpid());
	sleep();

}

  
//父线程的行为
void parent() {
	sleep();

    printf("in parent process %d...\n", getpid());

}

```

运行结果为：

![[Pasted image 20260210225955.png]]

从这个结果可以看到虽然拥有的代码是一样的（如`abc`都等于100），但它们的代码是完全不搭架的，各自运行各自的代码。也就是说，==虽然子进程复制父进程的资源，但它们的资源是完全时独立的，拥有各自的上下文，运行时互不干涉==。

---

再来看一个实验：

```cpp
#include <stdio.h>

#include <stdlib.h>

#include <sys/types.h>

#include <unistd.h>

#include <sys/wait.h>

  

int main() {

    printf("fork test...\n");

    pid_t pid;

    int ret;

  

    pid = fork();

    if (pid < 0) {

        perror("fork");

        exit(2);

    }

    // 此时 系统有两个进程和CPU进行抢，后面代码父 子 进程都要执行

    switch (pid) {

        case 0:     // 此时在子进程中

            // 替换当前父进程的上下文，替换成新的进程静态数据区

            ret = execlp("ls", "ls", "-l", NULL);

            if (ret < 0) {

                perror("execlp");

                exit(-1);

            }

            printf("==========================\n");

            break;

        default:    // pid为大于0的数，表示进程号，父进程生成子进程的ID号

            // 父进程的回收子进程的资源

            getchar();

            wait(NULL);     // 阻塞接口，等待一个事件发生

            break;

    }

  

    return 0;

}
```
输出结果：
![[Pasted image 20260210231027.png]]

可以看到，父进程与子进程在 `fork` 后各自独立运行，子进程调用 `execlp` 后，其**内存空间被新程序（如 `ls`）完全覆盖**，原程序中 `execlp` 之后的代码（如 `printf`）将==永远不会被执行==。==父进程则继续执行自己的逻辑==，如等待子进程结束。

## 2.进程的终止

进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的:

- **正常退出** （自愿的）
- **错误退出** （自愿的）
- **严重退出** （非自愿的）
- **被其他进程杀死** （非资源的）

### 1.正常退出

> 进程的终止大多数情况是自然发生的，即**当完成了预定的任务或工作后自行结束**。在编程和软件开发的上下文中，这种终止行为通常由==特定的系统调用==触发，以通知OS==该进程已完成任务并准备释放其占用的资源==。

之前我们在Linux下编写的`exit(0)`函数就是一个系统调用来报告进程的终止状态。==这个调用不仅标志着进程的结束，还允许进程向操作系统传递一个退出码，以指示其成功或失败的状态==。

除了由系统调用触发的终止外，许多面向用户的软件应用程序也提供了用户可操作的界面元素（如图标、按钮或菜单项），允许用户资源终止进程。比如结束调试的‘小方块’。

### 2.错误退出

> 进程终止的第二个常见原因是**由于运行过程中遭遇了严重错误**，这些错误可能源于多种因素，包括但不限于文件缺失、权限不足或参数错误等。

以编译过程为例，当用户尝试执行如下命令来编译一个C语言源文件时：
```cpp
gcc foo.c
```
如果系统中不存在名为 foo.c 的文件，编译器（如GCC）将无法找到该文件进行编译，因此会==识别出这是一个严重错误==。此时，编译器会输出一条错误消息到控制台，指出文件不存在，并随后通过执行exit （在UNIX系统中）或 ExitProcess （在Windows系统中）等系统调用来终止自身进程。**这种终
止是立即且不可逆转的，因为编译器无法在没有源文件的情况下继续执行编译任务。** 

然而，在面向屏幕的交互式应用程序中，处理错误的方式往往更加用户好。当应用程序接收到错误参数或遇到其他可恢复的错误时，它通常不会立即退出。相反，它会通过图形用户界面（GUI）弹出一个对话框或错误提示窗口，向用户清晰地展示错误信息，并提供一系列选项供用户选择，比如“重试”、“取消”或“退出”等。

例如，假设用户在使用一个文本编辑器时尝试打开一个不存在的文件，编辑器可能会弹出一个对话框，内容大致如下：*“无法找到文件‘不存在的文件.txt’。请检查文件名是否正确，然后重试打开，或者选择取消操作。”* 这样的设计==允许用户根据错误提示做出相应的决策，从而提高了应用程序的可用性和用户体验==。
### 3.严重退出

> 进程终止的第三个主要原因源于**程序内部错误，这些错误通常由编程疏忽、逻辑错误或运行时异常引起** 。这些错误能够导致进程的运行状态变得不稳定或不可预测，进而可能触发终止过程。具体实例包括执行非法指令、尝试访问不存在的内存地址，以及执行除数为零的运算等。

在像UNIX这样的操作系统中，为了增强程序的健壮性和灵活性，提供了一种机制允许进程对特定类型的错误进行捕获和处理，而不是直接终止。这种机制通过信号（signal）来实现，信号可以被视为一种软中断（注意，==由于错误由用户引起被OS捕获，所以是一个主动行为，实际属于异常，不属于中断==），它通知进程发生了某个特定事件。

当进程接收到一个信号时，它可以**根据信号的类型和自身的设置来决定如何响应**。对于某些类型的信号，进程可以选择忽略它们（如果系统允许的话），或者通过提供一个信号处理程序（signalhandler）来定制对信号的响应。例如，当进程尝试访问一个非法内存地址时，操作系统会向该进程发
送一个段错误（segmentation fault）信号（通常是SIGSEGV）。如果进程没有为该信号提供处理程序，那么它将被默认行为终止；但如果进程已经注册了一个信号处理程序，那么它可以在处理程序内部执行一些清理工作，然后安全地终止，或者尝试恢复到一个稳定的状态并继续执行。

通过**信号机制**，UNIX系统为进程提供了一种强大的错误处理手段，使得进程能够在面对错误时做出更加灵活和适当的响应。
### 4.被其他进程杀死

> 第四个导致进程终止的原因是，**当某个进程（通常具有相应的权限）主动执行一个特定的操作来请求操作系统结束另一个进程的执行** 。

在UNIX操作系统中，这一操作通过 kill 系统调用来实现。 kill系统调用允许进程向另一个进程发送一个信号，而该信号可以被接收进程解释为终止执行的指令。

例如，如果进程A希望结束进程B的运行，它可以通过 kill 系统调用发送一个SIGTERM（软件终止信号）给进程B，进程B在接收到此信号后通常会进行清理工作并退出。

## 3.进程的层次结构

### UNIX进程体系
我们使用`pstree` 命令行查看Linux进程结构：
![[Pasted image 20260212004522.png]]

> 我们可以看到，Linux的进程结构是**一个以systemd为根的庞大进程树。**

在Linux中，创建进程的过程就是在父进程中创建子进程的过程。并且，当父进程终止而子进程还在运行时，子进程不会随父进程继而终止（毕竟是各干各的），而是直接连接在systemd下（以它为父进程），此时这个子进程叫做**孤儿进程**。

在UNIX系统中，进程和它的所有后代进程（包括直接子进程以及子进程的子进程等）可以共同属于一个或多个进程组。进程组是操作系统用于管理进程集合的一种方式，特别是在信号处理时。

例如，当用户从终端（如键盘）发出一个信号时，该信号通常会被发送到与终端相关联的当前前台进程组中的所有成员。每个进程都有机会根据自身的配置来决定如何响应这个信号，包括捕获信号、忽略信号或执行默认操作（如终止进程）。
### Windows进程体系

> 在Windows中，所有进程都被视为**平等的实体**，它们之间**不存在直接的父子关系或层次结构** 。

> 那么Windows通过什么来实现对进程的管理和控制呢？

==通过其他特定的机制==。以句柄为例，当一个进程创建另一个进程时，父进程会获得一个句柄，这个句柄可以用来对子进程进行某些操作，比如查询状态或终止进程。但值得注意的是，==这个句柄并不是进程层次结构的体现，而且它可以被传递给其他进程，从而失去了与原始创建者的直接联系==。（这样看来，还是Windows 比较*渣* ）。
# 3.进程的状态切换

> 尽管每个进程在操作系统中被视为一个独立的执行实体，拥有其专属的程序计数器以追踪指令执行位置及内部状态以管理资源，但进程间的协作与依赖是不可或缺的。在操作系统的进程管理中，三态、五态和七态模型是用来描述进程在其生命周期中不同状态的抽象模型。其中三态模型中的三种状态是进程的三种基本状态。



## 1.三种基本状态

## 2.控制：创建、终止、阻塞与唤醒、挂起与激活


