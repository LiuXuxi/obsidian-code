>[!ABSTRACT]
>**定义：** 进程是程序运行的过程，是系统进行资源分配和调度的**独立单位**。

# 1.进程模型

## 1.进程和程序

### 1.并行与并发

在知道什么是进程之前，我们先简单了解一下**并行**与**并发**。

> **并行：** 指系统能够同时处理多个任务的能力。在并发环境中，多个任务在**同一时间段内**交替执行，从宏观上看像是同时进行的，但在微观上（特别是在单核处理器上），它们可能是轮流执行的。

> **并行：** 指系统能够同时执行多个任务的能力。在并行环境中，多个任务在**同一时刻**真正地同时执行，互不干扰。

简单来说，并行就是在一个时刻，==多个人同时干活，每个人负责一项任务==；而并发是一个人在==一个时间段内需要完成很多任务==，但一个时刻只能干一件事，所以只能==在任务之间不断切换==，让所有任务都完成。

==并行和并发可以极大提高系统资源的利用率和吞吐量。==
### 2.什么是程序？

**程序** 是代码的集合，是数据的集合。我们平常所写的*cpp*文件，脚本，甚至一行命令等，都可以称为程序。==程序由代码组成，程序提供数据，但程序本身不运行==。

*程序就像是一本剧本，它可以提供情节，提供事件，但是光靠一本剧本是没法演剧的。*

### 3.什么是进程？

> **进程** 就是程序的运行过程。从程序启动，cpu调度，访问所需资源到程序执行完毕都是进程来实现。

当程序开始运行，进程就被创建，经过cpu的调度算法被调度执行。进程依靠 ==正确、有效的调度和资源管理== 来完成程序的运行过程，在一个程序中可以==同时运行多个任务==，从而完成并发。

*程序是剧本，而导演拿到剧本叫演员来演戏，发送视频到网上的过程属于一个进程。*

## 2.进程的命令视角

> 在一个操作系统中需要管理很多进程，**了解系统中的进程状态是对进程进行管理的前提，使用不同的命令可以从不同的角度查看进程状态**。

### 1.ps命令：进程信息

**ps命令**是Linux系统中最为常用的进程查看工具，主要用于显示包含当前运行的各进程完整信息的静态快照。通过不同的选项，可以有选择的查看进程信息。

- a ： 显示当前终端下的所有进程信息，包括其他用户的进程
- u ：以用户为主的进程状态
- x ：通常与 a 这个参数一起使用，显示当前用户在所有终端下的进程信息
- -e：显示系统内所有的进程信息
- -l ：使用长格式显示进程信息
- -f ：使用完整的格式显示进程信息

1. 执行“ps aux”命令。将以简单的列表形式显示出进程信息。

![[Pasted image 20260210210235.png]]
![[Pasted image 20260210210257.png]]

2. 执行“ps -elf”命令，将以长格式显示系统的进程信息，并包含更丰富的内容。
![[Pasted image 20260210210449.png]]

![[Pasted image 20260210210501.png]]

### 2.top命令：动态显示系统资源

top命令将会在当前终端以全名交互式的界面显示进程排名，及时跟踪CPU、内存等系统资源占用情况，默认情况下每三秒刷新一次，其作用类似于window系统中的任务管理器。
![[Pasted image 20260210211018.png]]

![[Pasted image 20260210210849.png]]

![[Pasted image 20260210210906.png]]

### 3.pstree命令：查看进程树

pstree命令可以输出Linux系统中各个进程的树形结构，更加直观地判断出各进程之间的关系。（Linux中为树结构，但其他操作系统并不一定与之相同，如window系统为层级结构）

![[Pasted image 20260210211420.png]]

### 4.pgrep命令

使用pgrep命令可以根据进程的名称、运行该进程的用户、进程所在终端等多种属性查询特定进程的ID号。

例如查看用户root正在运行的所有进程。
![[Pasted image 20260210211714.png]]

## 3.进程的组成

> **进程**由程**序段及其他相关数据段**（静态区）和**PCB**（进程控制块）组成。

进程就像造房子的过程，在这一个项目中，首先要拿到房子的==蓝图和流程图==（程序段、数据段），才能进行规划，否则造成什么样都不知道。但项目名称是什么，房子材料从哪来，工程目前状况以及需要哪些人才来造房子等等这些问题该如何记录，规划？这些问题由PCB（进程控制块）来解决。

**PCB 是一个专门的数据结构，用来描述进程的基本情况和运行状态，为控制和管理提供数据依据**。

## 4.PCB和PCB组织

### 1.PCB里包含的信息

- **进程标识符（PID）：** 进程唯一“身份证”。
- **进程控制管理信息：** 
	a.程序段和数据段的地址
	b.进程同步和通信信息
	c.资源清单地址
	d.进程队列指针
- **资源清单：** 内存地址、虚拟地址、打开文件列表、I/O设备信息等。
- **进程调度信息：** 进程状态、优先级、等待和使用CPU时间总和
- **处理机状态：** 处理机中寄存器内容，用来CPU切换时保存现场信息和恢复现场信息。

![[Pasted image 20260210220230.png]]

从图中我们可以浅显了解一下**CPU是如何根据PCB来进行进程调度**的（实际调度很复杂）。

首先我们知道现代操作系统都含有分时系统，利用==定时器来进行CPU的任务切换，也就是切换不同的进程==。

1. 在时间片内CPU执行当前进程。
2. **时间片到了，OS内核中断定时器**，保存当前进程信息（也就是当前上下文，更新PCB）
3. CPU根据一定调度算法找到下一个进程，获取其状态信息（PCB）
4. 开始新的时间片，CPU处理下一个进程


### 2.PCB组织
> 一个系统中由多个PCB组成，操作系统不能把它们“乱扔”，必须用某种数据结构把它们管理起来，以便快速查找、调度和回收。

#### 1. 线性、链式

这是最基础的组织方式。

- **线性组织**：将所有PCB放在一个数组或线性表中。操作系统维护一个指针或索引，遍历这个表来查找进程。
- **链式组织**：将所有PCB通过指针链接成一个或多个链表。
    - **就绪队列**：所有准备运行的进程连成一条链。
    - **阻塞队列**：所有等待I/O的进程连成一条链。
    - **运行队列**：当前正在运行的进程（单处理器通常只有一个）。

> **特点**：结构简单，适合进程数量不多的情况。但在进程数量巨大时，遍历查找的效率较低。

#### 2. 索引组织

这是为了提高查找效率而采用的高级组织方式，类似于书籍的目录。

- **原理**：系统为不同状态的进程建立**索引表**。
    - 例如，建立一张“就绪索引表”，表中每一项是一个指针，指向一个处于就绪状态的PCB。
    - 建立一张“阻塞索引表”，指向所有阻塞的PCB。
- **优势**：当操作系统需要查找某一状态的进程时，直接去查对应的索引表，速度极快，不需要遍历所有进程。

### 3.Linux中的PCB

![[Pasted image 20260209091811.png]]
![[Pasted image 20260209091726.png]]
![[Pasted image 20260209091701.png]]

从Linux内核的代码中我们可以看到，PCB其实是叫一个`task_struct`的**结构体**，它里面包含很多数据，如`pid`（PID号）、`tgid`和`mm_struct`（内存空间）等，在制作一个操作系统中这样的数据结构是必不可少的。

# 2.进程的编程方法

## 1.进程的创建

在遇到以下情况时会进行创建进程：

**系统初始化：** 启动操作系统时，通常会创建若干进程。如前台进程和守护进程。

**系统调用创建：** 一个正在运行的进程发出系统调用来创建一个或多个新进程来帮助完成其他工作。比如fork、exec函数族等。

**用户请求创建：** 双击程序运行或命令行下输入一个命令等。

**批处理创建：** 主要在大型机的批处理系统中应用。用户提交批处理作业，OS创建一个新进程并从输入队列中运行下一个作业。

下面我们用一个程序来了解一下线程的创建。

```c
#include <stdio.h>

#include <stdlib.h>

#include <sys/types.h>

#include <unistd.h>


//子线程的行为
void child() {

    printf("in child process %d...\n", getpid());


}

  
//父线程的行为
void parent() {


    printf("in parent process %d...\n", getpid());

}

  
//主函数
int main() {

    printf("fork test...\n");
    //printf("fork test...");

    pid_t pid;//PID，分辨当前进程

  

    pid = fork();//创建子线程，属于系统调用创建

	//如果创建失败，退出线程
    if (pid < 0) {

        perror("fork");

        exit(2);

    }

    // 此时 系统有两个进程和CPU进行抢，后面代码父 子 进程都要执行

    switch (pid) {

        case 0:     // 此时在子进程中

            child();

            break;

        default:    // pid为大于0的数，表示进程号，父进程生成子进程的ID号

            parent();

            break;

    }

  

    return 0;

}
```

运行结果：
![[Pasted image 20260210223316.png]]
这说明进程创建成功。

但是当我们把`printf("fork test...\n");`中的`\n`去掉，运行结果会和我们想的不太一样。

![[Pasted image 20260210223519.png]]

可以发现，`printf`只有一句，可是为什么会==打印两遍相同的内容==呢？
其实这与**进程的创建**和`printf`**打印机制**有关。

1. `printf`**打印机制：** 语句执行完不会立即打印内容到I/O设备上，而是先==放在缓冲区将许多内容一起冲刷打印到I/O设备==中。那么什么时候清理缓冲区呢？常见的方式有三种：**内容太多，缓冲区满了**、**程序执行结束**和**遇到特定符号，如`\n`**。

2. **进程的创建：** `fork()`函数创建的机制其实是复制，将该进程已有的资源完整复制一份来创建子进程，子进程会与父进程抢占cpu（抢占是随机的），通过返回值（pid）来区分父子进程。

![[Pasted image 20260210225009.png]]

既然创建子进程的时候会复制资源，那么==父进程资源内缓冲区里的内容==自然也会在子进程保留一份。由于没有`\n`，`fork test...`信息仍然在缓冲区内并同时存在于父子进程中，==当父子进程各自结束程序时都会一并打印缓冲区内容，所以才会打印两次相同的内容==。

---
我们再来修改一些数据：

```cpp

//全局变量
int abc=100;

//子线程的行为
void child() {
	abc=200;
    printf("in child process %d...\n", getpid());
	sleep();

}

  
//父线程的行为
void parent() {
	sleep();

    printf("in parent process %d...\n", getpid());

}

```

运行结果为：

![[Pasted image 20260210225955.png]]

从这个结果可以看到虽然拥有的代码是一样的（如`abc`都等于100），但它们的代码是完全不搭架的，各自运行各自的代码。也就是说，==虽然子进程复制父进程的资源，但它们的资源是完全时独立的，拥有各自的上下文，运行时互不干涉==。

---

再来看一个实验：

```cpp
#include <stdio.h>

#include <stdlib.h>

#include <sys/types.h>

#include <unistd.h>

#include <sys/wait.h>

  

int main() {

    printf("fork test...\n");

    pid_t pid;

    int ret;

  

    pid = fork();

    if (pid < 0) {

        perror("fork");

        exit(2);

    }

    // 此时 系统有两个进程和CPU进行抢，后面代码父 子 进程都要执行

    switch (pid) {

        case 0:     // 此时在子进程中

            // 替换当前父进程的上下文，替换成新的进程静态数据区

            ret = execlp("ls", "ls", "-l", NULL);

            if (ret < 0) {

                perror("execlp");

                exit(-1);

            }

            printf("==========================\n");

            break;

        default:    // pid为大于0的数，表示进程号，父进程生成子进程的ID号

            // 父进程的回收子进程的资源

            getchar();

            wait(NULL);     // 阻塞接口，等待一个事件发生

            break;

    }

  

    return 0;

}
```
输出结果：
![[Pasted image 20260210231027.png]]

可以看到，父进程与子进程在 `fork` 后各自独立运行，子进程调用 `execlp` 后，其**内存空间被新程序（如 `ls`）完全覆盖**，原程序中 `execlp` 之后的代码（如 `printf`）将==永远不会被执行==。==父进程则继续执行自己的逻辑==，如等待子进程结束。

## 2.进程的终止

## 3.进程的层次结构

# 3.进程的状态切换

## 1.三种基本状态

## 2.控制：创建、终止、阻塞与唤醒、挂起与激活


