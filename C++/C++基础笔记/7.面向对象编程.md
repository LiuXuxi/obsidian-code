## 7.1类与对象
- 面向过程与面向对象
	- ![[Pasted image 20251026155725.png]]
- 类与对象的基本概念
	- ![[Pasted image 20251026160122.png]]
- <font color=red>类class</font>的定义(类名首字母一般大写)
	- 类里面的属性列表和函数列表需要用{}包围，同时，类的最后一定不能忘记<font color=greeen>分号</font>
	- ```
	  class ClassName{
		propertyModifier:  //属性修饰符，有public、protected、private
			propertoys  //属性列表
			functions  //函数列表（方法列表）
	  };
	  ```
	  
## 7.2构造函数
- 类对象
	- 使用类创建对象的过程，又称为类的实例化
	- ```
	  //类名    类对象（参数）；
	  ClassName classVar(param);
	  ```
- 构造函数与析构函数
	- 构造函数
		- ![[Pasted image 20251026162525.png]]
	- 构造函数参数
		- ![[Pasted image 20251026162839.png]]
	- 拷贝构造函数
		- ![[Pasted image 20251026165112.png]]
	- 析构函数
		- ![[Pasted image 20251026165137.png]]
		- ```
		  ~Destructor(){
		  //析构函数前面一定要加加~，并且是系统自动调用的
		  }
		  ```
	- [const成员函数](https://blog.csdn.net/weixin_45031801/article/details/134161230?spm=1001.2014.3001.5506))
## 7.3动态创建对象
- 当创建一个C++对象时，会发生两件事情
	- ![[Pasted image 20251026165744.png]]
- <font color=red>new操作符</font>
	- ![[Pasted image 20251026170126.png]]
	- ```
	  //new操作能确定在调用构造函数初始化之前内存分配是成功的，所以不用显示确定调用是否成功
	  ClassName*p=new ClassName();
	  ```
- <font color=red>delete操作符</font>
	- ![[Pasted image 20251026171042.png]]
## 7.4动态创建对象数组与普通数组
- 聚合初始化
	- ```
	  //栈上可以聚合初始化,但堆上必须提供一个默认的构造函数
	  Class Student{
	  public:
		  Student(){
			  cout<<111<<endl;
		  }
		  Student(string name,int age){
			  cout<<name<<endl;
			  cout<<age<<endl;
		  }
	  };
	  
	  int main(){
		  //栈聚合初始化
		  Student stu[]={{"zs",20},{"ww",21}};
		  //创建堆上对象数组必须提供构造函数
		  Student*pstr=new Student[20];
		  //删除
		  deletr[]pstu;
		  return 0;
	  }
	  ```
	- new/delete用于普通数组
		- ```
		  //创建字符数组
		  char*p1=new char[50];
		  
		  //创建整型数组
		  int*p2=new int[100];
		  //创建整型数组并初始化
		  int*p3=new int[10]{1,2,3,4,5,6,7,8,9,10};
		  //释放数组内存
		  delete[]p1;
		  delete[]p2;
		  delete[]p3;
		  ```
## 7.5静态成员变量与静态成员函数
- 静态成员变量
	- ![[Pasted image 20251028082747.png]]
- ```
  class ClassName{
  public:
	  static type paramter;
  };
  //静态成员在定义后必须初始化
  Type ClassName::paramter=value;
  //静态成员的引用可以使用类名或者对象名引用
  ClassName::paramter;
  ```
- 静态成员函数
	- ![[Pasted image 20251028084120.png]]
	- ```
	  class ClassName{
	  public:
		  static type funcName(paramtertype paramter){
		  
		  }
	  };
	  ```
	- [[C++其他使用细节#11.类中静态成员函数与类中普通函数的区别]]
	- 可以通过类名和对象名调用 
- const修饰类的成员函数
	- ![[Pasted image 20251028084621.png]]
	- ```
	  class ClassName{
	  public:
		  type func()const{
		  
		  }
	  };
	  ```
## 7.6this指针
- ![[Pasted image 20251028085053.png]]
- ![[Pasted image 20251028085123.png]]
- [[C++其他使用细节#10.this指针使用场景]] 
## 7.7访问限定符 友元函数
- 访问限定符
- [[C++其他使用细节#14private,public,protected的不同点与相同点]]
	- ![[Pasted image 20251029093237.png]]
- 友元函数
	- ![[Pasted image 20251029093301.png]]
	- 用<font color=red>friend</font>修饰的函数
	- ```
	  class Name{
	  public:
		  friend void func();
		};
		void func(){
		
		}
	  ```
## 7.8友元类
- 如果一个类是另一个类的友元类，<font color=red>友元类可以访问类的所有私有成员</font>
- 用friend修饰的类
- [[C++其他使用细节#12.友元的理解（友元函数与友元类）]]
## 7.9运算符重载
- ![[Pasted image 20251030131101.png]]
- ![[Pasted image 20251030131331.png]]
- 不能重载的运算符
	- ![[Pasted image 20251030131441.png]]
- 重载的两种形式
	- ![[Pasted image 20251030131527.png]]
- [[C++其他使用细节#13.学生成绩管理系统（友元与成员函数，私有公有函数的运用）]]
## 7.10继承和多态
- 继承和派生概念
	- ![[Pasted image 20251031071203.png]]
- 继承使用场景
	- ![[Pasted image 20251031071148.png]]
	- ```
	  class derived-class: access-specifier base-class
	  //derived-class 派生类，即继承自base-class创建的新类
	  //access-specifier继承访问修饰符（如果不写，默认为private)
	  //base-class基类，即要被继承的类
	  ```
	- 不同的继承方式会影响基类成员在派生类中的访问权限
		- ![[Pasted image 20251031072007.png]]
	- 继承中的构造和析构
		- ![[Pasted image 20251031075326.png]]
		- ![[Pasted image 20251031075503.png]]
	- 通过using来继承基类构造函数
		- ![[Pasted image 20251031075625.png]]
	- 构造和析构的调用顺序
		- 构造函数：先调用基类的构造函数，在调用子类的，基类没有默认构造函数，则编译错误
		- 析构函数：先调用子类析构，再调用基类析构
- 多继承
	- 一个派生类有多个基类
	- ```
	  class D:public A,protected B,private C;//类D新增加的成员
	  ```
	- 多继承构造函数
		- ![[Pasted image 20251031090841.png]]
	- 多继承命名冲突
		- ![[Pasted image 20251031093102.png]]
- 菱形继承
	- ![[Pasted image 20251101084054.png]]
	- 类D使用类A中的变量时会发生命名冲突，变量不明确。<font color=red>所以使用时要显式类的作用域</font>
- 虚继承
	- ![[Pasted image 20251101084841.png]]
	- 虚继承构造函数
		- ![[Pasted image 20251101090417.png]]
- 类的多态
	- ![[Pasted image 20251101093536.png]]
	- 基本概念
		- ![[Pasted image 20251101093732.png]]
	- 构成条件
		1. 必须存在继承关系
		2. 继承关系中必须有同名的虚函数，并且他们是覆盖关系（函数原型相同）
		3. 存在基类的指针，通过该指针调用虚函数
		4. ![[Pasted image 20251101094357.png]]
	- 通过基类指针只能访问派生类的成员变量，但是不能访问派生类成员函数。为了能让基类指针访问派生类的成员函数，cpp增加了虚函数`virtual void info()...`
	- 引用实现多态
		- <font color=red>指针可以随时改变方向，而引用只能指代固定的对象，在多态性方面缺乏表现力</font>
		- ![[Pasted image 20251101095220.png]]
	- 虚函数
		- ![[Pasted image 20251101095349.png]]
	- 虚析构函数
		- ![[Pasted image 20251101100802.png]]
		- ![[Pasted image 20251101100540.png]]
	- 虚函数表
		- ![[Pasted image 20251101104620.png]]
	- C++如何实现动态绑定
		- ![[Pasted image 20251101105119.png]]
		- ![[Pasted image 20251101105231.png]]
	- 抽象基类和纯虚函数
		-  ![[Pasted image 20251101105518.png]]
		- 纯虚函数
			- ![[Pasted image 20251101105853.png]]
## 7.11嵌套类和局部类
- 嵌套类
	- ![[Pasted image 20251104085150.png]]
	- 特点
		1. 嵌套类不可以访问外围类的任何成员
		2. 外围类可以通过对象访问嵌套类的公有成员，但不能访问保护和私有成员
		3. 嵌套类只能由外围类使用
- 局部类
	- 类可以定义在函数体内，这样的类称为局部类。局部类只在定义它的局部域内可见
	- 局部类的成员函数必须被定义在类体中
	- 局部类中不能有静态成员函数
	- 在实践中，局部类很少使用