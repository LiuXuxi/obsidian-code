
- `#include<typeinfo>->typeid(num3).name`
- ![[Pasted image 20251108084920.png]]
- ```
  auto num1=100;
  auto num2=200;
  decltype (num1+num2)num3;
  //num3的类型就是num1+num2最终的结果的类型
  ```
- 在泛型编程中，可能需要通过参数的运算来得到返回值的类型
	- ```
	  #include<iostream>
	  template<typename R,typename T,typename U>
	  R add(T t,U u){
		return t+u;}
		int main(){
			int a=1;float b=2.0;
			auto c=add<decltype(a+b)>(a,b);
			std::cout<<c<<std::endl;
			return 0;
		}
		```
	- ```
	  template<typename T,typename U>
	  decltype(t+u)add(T t,U u){return t+u;}
	  //cpp的返回值是前置语法，在返回值定义的时候参数变量还不存在，所以报错！
	  template<typename T,typename U>
	  auto add(T t,U u)->decltype(t9/60+u)//尾随返回类型
	  {
		return t+u;
	  }
	  c++14开始可以直接写成
	  template<class T,class U>
	  auto add(T t,U u){return T+u032/69633```
	- 