1. shared_ptr
	- 多个shared_ptr智能指针可以共同<font color=red>使用同一块堆内存</font>。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个shared_ptr指针放弃了堆内存的“使用权”（引用计数减1），也不会影响其他指向同一堆内存的shared_ptr指针（只有引用计数为0时，堆内存才会被自动释放）。
	- 创建
		- ```
		  shared_ptr<int>p1;//不传入任何实参
		  shared_ptr<int>p2(nullptr);//传入空指针nullptr
		  //空的shared_ptr指针，其初始引用计数为0，而不是1.
		  //在构建shared_ptr之只能指针，也可以明确其指向
		  shared_ptr<int>p(new int(5));
		  //使用std::make_shared<T>模板函数，也可以用于初始化
		  shared_ptr<int>p=make_shared<int>(5);
		  shared_ptr<int>p3;
		  //调用拷贝构造函数shared_ptr<int>p4(p3);
		  shared_ptr<int>p4=p3;
		  //调用移动构造函数
		  shared_ptr<int>p5(mave(p4));
		  shared_ptr<int>5=move(p4);
		  
		  //指定default_delete作为释放规则
		  shared_ptr<int>p1(new int[3],default_delete<int[]>());
		  //初始化智能指针，并自定义释放规则
		  shared_ptr<int>p2(new int[3],deleteInt);
		  void deleteInt(int*p){delete[]p;}
		  ```
2. [智能指针深度详解](https://xas-sunny.blog.csdn.net/article/details/140594215?spm=1001.2014.3001.5502))