# 4.滑动窗口

**核心原理：** 这是同向双指针的最高级应用，使用两个指针<font color=greeen>L</font>（左边界）和<font color=greeen>R</font>（右边界）维护一个==动态变化的连续区间==（即“窗口”）。

**驱动力：** ==单调性==和==哈希表/字典==是其关键辅助工具。

- 当R扩张窗口时，窗口内状态被更新。
    
- 当窗口不满足条件时，单调性地收缩L，直到条件重新满足。L和R的移动永不后退，保证$O(N)$复杂度。
    

## 常见应用场景及分类

### 1. 定长滑动窗口

> 窗口大小固定为 $K$。只需在 $R$ 移动时更新状态，并在 $R \ge K-1$ 后，每次移动都同步移除 $L$ 指向的旧元素。

#### [子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/ "null")

- **核心问题**：寻找长度为 $k$ 的连续子数组，使其平均值（总和）最大。
    
- **指针策略**：$R$ 遍历数组累加，当 $R \ge k$ 时，$L$ 指针开始同步右移。
    
- **核心逻辑**：窗口滑动时，减去离开的 `nums[i-k]`，加上进入的 `nums[i]`。
    

```
double findMaxAverage(vector<int>& nums, int k) {
    double sum = 0;
    for (int i = 0; i < k; i++) sum += nums[i];
    double maxSum = sum;
    for (int i = k; i < nums.size(); i++) {
        sum += nums[i] - nums[i - k];
        maxSum = max(maxSum, sum);
    }
    return maxSum / k;
}
```

#### [定长子串中元音字母的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/ "null")

- **核心问题**：在长度为 $k$ 的子串中，包含最多的元音字母个数。
    
- **指针策略**：维护长度为 $k$ 的窗口，利用布尔函数判断元音。
    
- **核心逻辑**：进一个字符判加，出一个字符判减。
    

```
int maxVowels(string s, int k) {
    auto isVowel = [](char c) { return c=='a'||c=='e'||c=='i'||c=='o'||c=='u'; };
    int cnt = 0;
    for (int i = 0; i < k; i++) if (isVowel(s[i])) cnt++;
    int res = cnt;
    for (int i = k; i < s.size(); i++) {
        cnt += isVowel(s[i]) - isVowel(s[i - k]);
        res = max(res, cnt);
    }
    return res;
}
```

#### [爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/ "null")

- **核心问题**：在 $minutes$ 时间内不生气，能额外挽留多少原本会因为生气而流失的顾客。
    
- **指针策略**：先计算老板不生气时的基础顾客，再用定长窗口找“挽回流失”的最大值。
    
- **核心逻辑**：窗口内只统计 `grumpy[i] == 1` 时的顾客数。
    

```
int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
    int total = 0, extra = 0, maxExtra = 0;
    for (int i = 0; i < customers.size(); i++) {
        if (!grumpy[i]) total += customers[i];
        if (i < minutes) {
            if (grumpy[i]) extra += customers[i];
        } else {
            if (grumpy[i]) extra += customers[i];
            if (grumpy[i - minutes]) extra -= customers[i - minutes];
        }
        maxExtra = max(maxExtra, extra);
    }
    return total + maxExtra;
}
```

### 2. 变长滑动窗口：求最长

> 窗口大小不固定。$R$ 负责探索，$L$ 只有在违反条件时才收缩。

#### [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/ "null")

- **核心问题**：寻找不含重复字符的最长连续子串。
    
- **指针策略**：$R$ 向右移动。若 `s[R]` 已在窗口中，则 $L$ 不断右移直到窗口中没有 `s[R]`。
    
- **核心逻辑**：使用哈希表或频率数组记录窗口内各字符出现的次数。
    

```
int lengthOfLongestSubstring(string s) {
    int count[128] = {0}, L = 0, res = 0;
    for (int R = 0; R < s.size(); R++) {
        count[s[R]]++;
        while (count[s[R]] > 1) count[s[L++]]--;
        res = max(res, R - L + 1);
    }
    return res;
}
```

#### [每个字符最多出现两次的最长子数组](https://leetcode.cn/problems/maximum-length-of-a-concatenated-string-with-unique-characters/ "null")

- **核心问题**：数组中每个元素出现次数不得超过 2 次的最长子数组。
    
- **指针策略**：$R$ 移动并计数，一旦计数等于 3，$L$ 开始收缩。
    
- **核心逻辑**：`while(count[nums[R]] > 2) count[nums[L++]]--;`
    

#### [最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/ "null")

- **核心问题**：允许将 $k$ 个 0 翻转为 1，求全 1 序列的最大长度。
    
- **指针策略**：窗口维护 0 的个数。若 0 的个数超过 $k$，$L$ 右移。
    
- **核心逻辑**：窗口宽度即为所求。
    

```
int longestOnes(vector<int>& nums, int k) {
    int L = 0, zeros = 0, res = 0;
    for (int R = 0; R < nums.size(); R++) {
        if (nums[R] == 0) zeros++;
        while (zeros > k) if (nums[L++] == 0) zeros--;
        res = max(res, R - L + 1);
    }
    return res;
}
```

#### [替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/ "null")

- **核心问题**：允许替换 $k$ 次，求相同字母出现的最长长度。
    
- **指针策略**：维护窗口内最高频字符的次数 `maxFreq`。
    
- **核心逻辑**：如果 `(当前窗口长度 - maxFreq) > k`，说明替换次数不够用了，收缩 $L$。
    

### 3. 变长滑动窗口：求最短

#### [长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/ "null")

- **核心问题**：和 $\ge target$ 的最短连续子数组。
    
- **指针策略**：满足条件时，尝试缩减 $L$ 以刷新最小值。
    
- **核心逻辑**：`while(sum >= target) { res = min(res, R-L+1); sum -= nums[L++]; }`
    

#### [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/ "null")

- **核心问题**：$S$ 中包含 $T$ 所有字符（种类及频率）的最小子串。
    
- **指针策略**：$R$ 扩张直到满足“覆盖”，$L$ 收缩直到“刚好不满足”。
    
- **核心逻辑**：维护一个需求哈希表和一个窗口哈希表，并用 `match` 记录达标种类数。
    

### 4. 变长滑动窗口：求个数/计数

#### [乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/ "null")

- **核心问题**：子数组所有元素乘积严格小于 $K$。
    
- **指针策略**：若乘积 $\ge K$，$L$ 右移。
    
- **核心逻辑**：窗口 $[L, R]$ 内，以 $R$ 为结尾的合法子数组个数为 `R - L + 1`。
    

```
int numSubarrayProductLessThanK(vector<int>& nums, int k) {
    if (k <= 1) return 0;
    int L = 0, prod = 1, ans = 0;
    for (int R = 0; R < nums.size(); R++) {
        prod *= nums[R];
        while (prod >= k) prod /= nums[L++];
        ans += R - L + 1;
    }
    return ans;
}
```

#### [最多有 K 个不同整数的子数组](https://www.google.com/search?q=https://leetcode.cn/problems/subarrays-with-at-most-k-different-integers/ "null")

- **核心问题**：统计不同整数个数恰好为 $k$ 的子数组数量。
    
- **指针策略**：转化为：`atMost(K) - atMost(K-1)`。
    
- **核心逻辑**：`atMost(K)` 逻辑：当不同元素 > $K$ 时收缩 $L$，每次累加 `R-L+1`。
    

### 5. 子串排列/异位词（哈希表辅助）

#### [字符串的排列](https://leetcode.cn/problems/permutation-in-string/ "null")

- **核心问题**：判断 $s2$ 是否包含 $s1$ 的某种全排列。
    
- **指针策略**：固定长度为 `s1.size()` 的窗口。
    
- **核心逻辑**：滑动窗口过程中维护两个频率数组，若相等则返回 true。
    

#### [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/ "null")

- **核心问题**：找出 $S$ 中所有是 $P$ 异位词的起始索引。
    
- **指针策略**：同“字符串排列”，记录所有匹配时的 $L$。
    

```
vector<int> findAnagrams(string s, string p) {
    if (s.size() < p.size()) return {};
    vector<int> sCnt(26), pCnt(26), res;
    for (int i = 0; i < p.size(); i++) {
        pCnt[p[i] - 'a']++;
        sCnt[s[i] - 'a']++;
    }
    if (sCnt == pCnt) res.push_back(0);
    for (int i = p.size(); i < s.size(); i++) {
        sCnt[s[i] - 'a']++;
        sCnt[s[i - p.size()] - 'a']--;
        if (sCnt == pCnt) res.push_back(i - p.size() + 1);
    }
    return res;
}
```