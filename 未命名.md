没问题，这四道题目是掌握“从后向前双指针”技巧的必经之路。下面我为您逐一拆解核心逻辑、指针策略，并提供简洁的 C++ 代码实现（逻辑在各语言间通用）。

---

### 1. 合并两个有序数组 (LeetCode 88)

- **核心逻辑：** 利用 `nums1` 后部的空闲空间。如果我们从前向后合并，必须移动 `nums1` 的元素来腾位置，导致 $O(n^2)$ 复杂度；从后向前合并，则可以直接将较大的元素填入末尾。
    
- **指针策略：**
    
    - `p1`：指向 `nums1` 有效元素的末尾 (`m-1`)。
        
    - `p2`：指向 `nums2` 的末尾 (`n-1`)。
        
    - `p`：指向 `nums1` 容器的最后位置 (`m+n-1`)。


```cpp
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int p1 = m - 1, p2 = n - 1, p = m + n - 1;
    while (p2 >= 0) { // 只要 nums2 没写完就继续
        if (p1 >= 0 && nums1[p1] > nums2[p2]) {
            nums1[p--] = nums1[p1--];
        } else {
            nums1[p--] = nums2[p2--];
        }
    }
}
```

---

### 2. 比较含退格的字符串 (LeetCode 844)

- **核心逻辑：** 退格符 `#` 只影响它**左边**的字符。如果从后向前遍历，我们可以提前知道当前字符是否会被删除。
    
- **指针策略：**
    
    - 从 `S` 和 `T` 的末尾开始。
        
    - 使用 `skip` 变量记录遇到的 `#` 数量。
        
    - 如果遇到 `#`，`skip++`；如果遇到普通字符且 `skip > 0`，则跳过该字符并 `skip--`。
```cpp
bool backspaceCompare(string s, string t) {
    int i = s.length() - 1, j = t.length() - 1;
    int skipS = 0, skipT = 0;
    while (i >= 0 || j >= 0) {
        while (i >= 0) { // 找到 s 中下一个有效字符
            if (s[i] == '#') { skipS++; i--; }
            else if (skipS > 0) { skipS--; i--; }
            else break;
        }
        while (j >= 0) { // 找到 t 中下一个有效字符
            if (t[j] == '#') { skipT++; j--; }
            else if (skipT > 0) { skipT--; j--; }
            else break;
        }
        if (i >= 0 && j >= 0) {
            if (s[i] != t[j]) return false;
        } else if (i >= 0 || j >= 0) return false; // 一个结束了一个没结束
        i--; j--;
    }
    return true;
}
```

---

### 3. 最后一个单词的长度 (LeetCode 58)

- **核心逻辑：** 既然只需要“最后一个”单词，从尾部开始扫描可以最快跳过末尾的空格并锁定目标单词，无需关心前面的内容。
    
- **指针策略：**
    
    - 从末尾开始，第一个 `while` 循环跳过所有空格。
        
    - 第二个 `while` 循环统计连续字母的数量，直到再次遇到空格或字符串开头。
 
```cpp
int lengthOfLastWord(string s) {
    int i = s.length() - 1;
    while (i >= 0 && s[i] == ' ') i--; // 跳过尾部空格
    int end = i;
    while (i >= 0 && s[i] != ' ') i--; // 计算单词长度
    return end - i;
}
```

---

### 4. 路径加密 (替换空格 LCR 122)

- **核心逻辑：** 每一个空格替换为三个字符（`%20`），会导致字符串变长。从后向前替换可以避免在替换前面空格时，频繁向后搬移后续所有字符。
    
- **指针策略：**
    
    - 先遍历一遍计算空格数，扩充原字符串长度。
        
    - `i`：指向原字符串末尾。
        
    - `j`：指向扩容后的新末尾。
        
    - 从后向前移动，遇到普通字符直接填入；遇到空格填入 `0`, `2`, `%`。
        
- **代码实现：**
    

C++

```
string pathEncryption(string s) {
    int count = 0, oldSize = s.size();
    for (char c : s) if (c == ' ') count++;
    s.resize(oldSize + count * 2); // 扩容
    for (int i = oldSize - 1, j = s.size() - 1; i < j; i--, j--) {
        if (s[i] == ' ') {
            s[j] = '0'; s[j - 1] = '2'; s[j - 2] = '%';
            j -= 2;
        } else {
            s[j] = s[i];
        }
    }
    return s;
}
```

---

### 💡 技巧总结：

当你发现题目有以下特征时，请优先考虑**从后向前遍历**：

1. 需要在**原数组**（In-place）上进行修改。
    
2. 操作会导致数据**长度增加**（如替换空格、合并数组）。
    
3. 某些操作的**生效方向**是从右往左（如退格键、倒数位置）。
    

希望这些解析能帮你攻克力扣上的双指针题目！加油！