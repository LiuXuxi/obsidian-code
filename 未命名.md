> $$!ABSTRACT$$
> 
> 核心摘要
> 
> 双指针 (Two Pointers) 是一种核心算法思想，旨在将 $O(N^2)$ 的暴力嵌套循环优化为 $O(N)$ 的线性时间复杂度。
> 
> 根据指针的**移动方向、步长和作用目标**，可将其划分为四大类。该方法广泛应用于数组、字符串和链表的操作中。

# 1. 对撞双指针 (Opposing Pointers)

**核心原理：** 两个指针分别从数组或字符串的两端（头和尾）出发，向中间移动，**直到相遇**或交叉。

**驱动力：** 该方法高度依赖数据的**有序性**或问题的**对称性**（如回文串），核心在于利用\[7.单调性] 进行高效剪枝，排除无效组合。

## 常见应用场景

### 1. 两数之和 / N数之和

> **场景：** 在有序数组中快速查找和为目标值的元素对。

#### [1. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/ "null")

**核心逻辑：**

- **指针策略：** 左指针 `L=0`，右指针 `R=N-1`。
    
- **单调性决策：** 计算 `sum = A[L] + A[R]`。
    
    - 若 `sum > target`：和太大，必须 **R--**（利用有序性减小和）。
        
    - 若 `sum < target`：和太小，必须 **L++**（利用有序性增大和）。
        

```
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int L = 0, R = numbers.size() - 1;
        while (L < R) {
            int sum = numbers[L] + numbers[R];
            if (sum == target) return {L + 1, R + 1}; // 题目要求 1-based 索引
            else if (sum < target) L++;
            else R--;
        }
        return {};
    }
};

```

#### [2. 救生艇](https://leetcode.cn/problems/boats-to-save-people/ "null")

**核心逻辑：** 贪心策略。为了节省船，让**最重的人**带上**最轻的人**。

- 若 `最重 + 最轻 <= limit`：两人同船 (`L++, R--`)。
    
- 若 `最重 + 最轻 > limit`：最重的人太重了，带不动任何人，只能独坐 (`R--`)。
    

```
class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) {
        sort(people.begin(), people.end());
        int ans = 0;
        int L = 0, R = people.size() - 1;
        while (L <= R) { // 注意：L==R 时最后一个人也要坐船
            if (people[L] + people[R] <= limit) {
                L++; 
            }
            R--;   // 最重的人无论如何都要上船
            ans++;
        }
        return ans;
    }
};

```

### 2. 三数之和 / 四数之和

> **核心思路：降维打击**。固定一个数，将 N 数之和转化为 (N-1) 数之和，最终回归到双指针。

#### [3. 三数之和](https://leetcode.cn/problems/3sum/ "null")

**算法流程：**

1. **排序**：去重和双指针的前提。
    
2. **固定 `i`**：遍历数组，将问题转化为在 `[i+1, N-1]` 区间找 `sum = -nums[i]`。
    
3. **双指针扫描**：标准对撞指针。
    

**难点：完美去重**

- **外层去重：** `if (i > 0 && nums[i] == nums[i-1]) continue;`
    
- **内层去重：** 找到解后，若 `nums[L] == nums[L+1]` 则持续 `L++`；`R` 同理。
    

```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        int n = nums.size();
        
        for (int i = 0; i < n - 2; ++i) {
            if (nums[i] > 0) break; // 优化：最小数大于0则不可能和为0
            if (i > 0 && nums[i] == nums[i - 1]) continue; // 外层去重

            int L = i + 1, R = n - 1;
            while (L < R) {
                int sum = nums[i] + nums[L] + nums[R];
                if (sum == 0) {
                    res.push_back({nums[i], nums[L], nums[R]});
                    while (L < R && nums[L] == nums[L + 1]) L++; // L去重
                    while (L < R && nums[R] == nums[R - 1]) R--; // R去重
                    L++; R--;
                }
                else if (sum < 0) L++;
                else R--;
            }
        }
        return res;
    }
};

```

#### [4. 四数之和](https://leetcode.cn/problems/4sum/ "null")

差异点： 多一层循环。固定 i，再固定 j，剩下转化为“两数之和”。

注意： 数据可能溢出，计算和时需转换为 long long。

# 2. 快慢双指针 (Fast & Slow Pointers)

**核心原理：** 两个指针从同一起点出发，以**不同速度**（通常 Fast=2, Slow=1）移动。

**应用场景：** 主要用于**链表**和**数组原地去重**。解决环检测、中点寻找、倒数第K个节点等问题。

## 经典模型：Floyd 判圈算法

### 1. 环检测与入口定位

#### [环形链表 II (找入口)](https://leetcode.cn/problems/linked-list-cycle-ii/ "null")

**数学证明：为什么相遇后，一个指针回起点再走能相遇？**

设头到环入口距离为 $a$，环入口到相遇点距离为 $b$，环剩余长度为 $c$。

1. **相遇时路程：** Fast 是 Slow 的 2 倍。
    
    $$2(a+b) = a + b + n(b+c)$$
2. **化简得：**
    
    $$a = (n-1)(b+c) + c$$
    
    **含义：** 从起点走 $a$ 步，等同于从相遇点走 $c$ 步（并可能绕环 $n-1$ 圈）。
    
3. **策略：** Fast 与 Slow 相遇后，将 **Slow 重置回 Head**，Fast 留在原地，两者改为**同速 (step=1)** 移动，再次相遇点即为入口。
    

```
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) { // 第一次相遇：确认有环
                slow = head;    // 重置慢指针
                while (slow != fast) { // 同速前进寻找入口
                    slow = slow->next;
                    fast = fast->next;
                }
                return slow;
            }
        }
        return nullptr;
    }
};

```

### 2. 寻找重复数 (数组版找环)

#### [寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/ "null")

**核心视角：** 将数组看作链表。索引 `i` 是节点，`nums[i]` 是 `next` 指针。

- 因为有重复数，意味着有多个位置指向同一个索引，**这构成了环**。
    
- 问题转化为：**求环的入口**。可以直接复用“环形链表 II”的代码逻辑。
    

# 3. 同向双指针 (Same Direction)

**核心原理：** `i`, `j` 指针同向移动，但不维护滑动窗口。通常用于**“读写分离”**。

- **读指针 (Read/Fast)：** 遍历数组，寻找满足条件的元素。
    
- **写指针 (Write/Slow)：** 指向下一个该写入有效数据的位置。
    

## 常见场景

### 1. 数组原地去重 / 移动零

#### [移动零](https://leetcode.cn/problems/move-zeroes/ "null")

**逻辑：** Fast 遇到非零数，就赋值给 Slow 位置，Slow++。Fast 遇到 0 则跳过。

### 2. 归并排序 (Merge Logic)

#### [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/ "null")

**逻辑：** 谁小移谁。

- 比较 `l1->val` 和 `l2->val`。
    
- 较小的节点接到结果链表后，并将对应指针后移。
    

# 4. 滑动窗口 (Sliding Window)

**核心原理：** 同向双指针的进阶版。维护一个动态区间 `[L, R]`，使其满足特定性质。

**核心模板：** 滑动窗口的代码结构非常固定，建议背诵以下模板：

```
/* 滑动窗口通用模板 */
void slidingWindow(string s) {
    unordered_map<char, int> window;
    int L = 0, R = 0;
    
    while (R < s.size()) {
        // 1. 进窗：c 是移入窗口的字符
        char c = s[R];
        R++; 
        // TODO: 更新窗口数据 (window[c]++, count++, etc.)
        
        // 2. 判断：窗口是否需要收缩 (例如窗口长度超标，或已满足覆盖条件)
        while (/* window needs shrink */) {
            // 3. 出窗：d 是移出窗口的字符
            char d = s[L];
            L++;
            // TODO: 更新窗口数据 (window[d]--, count--, etc.)
        }
        
        // 4. 更新结果 (通常在收缩完或者是收缩前，视题目求最大还是最小而定)
        // updateRes();
    }
}

```

## 常见题型分类

### 1. 求最长子串 (窗口扩张优先)

> 只有当窗口**不再满足条件**时，才被迫收缩 L。

- [**无重复字符的最长子串**](https://leetcode.cn/problems/longest-substring-without-repeating-characters/ "null")
    
    - 进窗：字符加入哈希表。
        
    - 收缩：如果发现重复字符，L右移直到重复消除。
        
- [**最大连续1的个数 III**](https://leetcode.cn/problems/max-consecutive-ones-iii/ "null")
    
    - 进窗：统计0的个数。
        
    - 收缩：当0的个数 > K 时，L右移。
        

### 2. 求最短子串 (窗口收缩优先)

> 一旦窗口**满足条件**，就尝试收缩 L，看能不能更短。

- [**最小覆盖子串**](https://leetcode.cn/problems/minimum-window-substring/ "null") (Hard)
    
    - 进窗：统计字符频率。
        
    - 收缩：当窗口包含了所有目标字符时，尝试 `L++` 缩减长度，同时更新最小长度记录。
        
- [**长度最小的子数组**](https://leetcode.cn/problems/minimum-size-subarray-sum/ "null")
    
    - 收缩：当 `windowSum >= target` 时，记录长度并 `L++`。
        

### 3. 固定长度窗口

> 窗口大小固定为 K，L 和 R 同时移动，或者初始化 R=K 后同步移动。

- [**找到字符串中所有字母异位词**](https://leetcode.cn/problems/find-all-anagrams-in-a-string/ "null")
    
    - 维护一个长度为 `p.size()` 的窗口，判断窗口内字符计数是否与 `p` 一致。