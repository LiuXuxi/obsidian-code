# 4.滑动窗口

**核心原理：** 这是同向双指针的最高级应用，使用两个指针<font color=greeen>L</font>（左边界）和<font color=greeen>R</font>（右边界）维护一个==动态变化的连续区间==。

**驱动力：** ==单调性==和==哈希表/字典==是其关键辅助工具。

## 滑动窗口通用模板（详解）

> 绝大多数滑动窗口问题都可以套用以下四步法。

```cpp
/* 滑动窗口通用模板 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> window; // 记录窗口内状态（频数、总和等）
    
    int left = 0, right = 0;
    int valid = 0; // 满足条件的计数器（可选）
    
    while (right < s.size()) {
        // 【1. 进窗】：a 是将移入窗口的字符
        char a = s[right];
        right++; // 右移窗口边界
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        // printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 【2. 收缩】：判断左侧窗口是否要收缩
        // 求最长时：通常是 if (窗口不合法) 
        // 求最短时：通常是 while (窗口合法)
        while (window needs shrink) {
            // 【3. 出窗】：d 是将移出窗口的字符
            char d = s[left];
            left++; // 左移窗口边界
            // 进行窗口内数据的一系列更新
            ...
        }
        
        // 【4. 更新结果】：在这里更新最终答案
        // 求最长：在 while 循环外更新（此时窗口必定合法）
        // 求最短：在 while 循环内更新（此时窗口刚好合法）
    }
}
```

### 核心模板差异对比：

- **求最长（如：无重复最长子串）**：$L$ 的收缩是为了**恢复**合法性。只有当窗口不合法（如出现重复）时才收缩 $L$。结果在 $L$ 停止移动后（`while` 循环外）更新。
    
- **求最短（如：长度最小子数组）**：$L$ 的收缩是为了**挑战**合法性。只要窗口目前是合法的，$L$ 就不断右移尝试寻找更短的可能。结果在 $L$ 移动过程中（`while` 循环内）更新。
    

## 常见应用场景及分类

### 1. 定长滑动窗口

> 窗口宽度 $k$ 恒定。只需处理“一进一出”的差量更新。

#### [子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/ "null")

- **核心逻辑**：将连续子数组求和转化为增量计算。在一个固定长度为 $k$ 的窗口移动时，新窗口的和等于旧窗口的和加上新进入的元素并减去移出的元素，从而实现 $O(1)$ 的状态转移。
    
- **指针移动策略**：
    
    1. **初始化**：$R$ 指针先从 $0$ 移动到 $k-1$，计算出第一个窗口的总和。
        
    2. **滑动阶段**：$R$ 继续向右移动，每走一步，$L$ 指针也同步向右移动一步（即 $L = R - k + 1$）。
        
    3. **状态更新**：每次滑动，从总和中减去 `nums[R-k]`，加上 `nums[R]`。
        

```cpp
double findMaxAverage(vector<int>& nums, int k) {
    double sum = 0;
    // 1. 初始化第一个窗口
    for (int i = 0; i < k; i++) sum += nums[i];
    double maxSum = sum;
    // 2. R从k开始滑动
    for (int i = k; i < nums.size(); i++) {
        // 3. 核心逻辑：加新进的nums[i], 减去刚离开窗口的nums[i-k]
        sum += nums[i] - nums[i - k];
        maxSum = max(maxSum, sum); // 更新最大全局和
    }
    return maxSum / k;
}
```

#### [定长子串中元音字母的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/ "null")

- **核心逻辑**：维护一个计数器记录窗口内元音字符的数量。通过布尔函数实时判断边界变化对计数器的影响。
    
- **指针移动策略**：
    
    1. **进**：$R$ 指针右移。如果是元音，计数器 `cnt++`。
        
    2. **满**：当窗口长度超过 $k$（即索引 $i \ge k$）时，判断离开窗口的元素（索引为 $i-k$）。
        
    3. **出**：如果离开的元素是元音，计数器 `cnt--`。
        

```cpp
int maxVowels(string s, int k) {
    auto isVowel = [](char c) { return c=='a'||c=='e'||c=='i'||c=='o'||c=='u'; };
    int cnt = 0, res = 0;
    for (int i = 0; i < s.size(); i++) {
        // 右边界新进入元素判断
        if (isVowel(s[i])) cnt++; 
        // 窗口左边界同步移出判断（当索引达到k及以上时）
        if (i >= k && isVowel(s[i - k])) cnt--; 
        res = max(res, cnt); // 记录窗口滑动过程中的最大值
    }
    return res;
}
```

#### [爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/ "null")

- **核心逻辑**：将问题拆分为“固定收益”和“额外挽回收益”。使用滑动窗口寻找在 $minutes$ 长度内，老板生气（`grumpy[i]==1`）时对应的顾客数总和的最大值。
    
- **指针移动策略**：
    
    1. **基础统计**：遍历数组，若 `grumpy[i]==0`，直接加入总分。
        
    2. **增量滑动**：$R$ 指针移动，若当前分钟老板生气，累加 `customers[R]` 到 `extra`。
        
    3. **窗口平移**：一旦 $R \ge minutes$，检查刚离开窗口的 `R-minutes` 分钟。如果那天老板生气，则从 `extra` 中扣除那天的顾客数。
        

```cpp
int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
    int base = 0, extra = 0, maxExtra = 0;
    for (int i = 0; i < customers.size(); i++) {
        // 1. 基础收益：老板本身不生气时能得到的顾客
        if (!grumpy[i]) base += customers[i]; 
        // 2. 窗口进：如果老板生气，这部分是可以通过“秘密技巧”挽回的潜在收益
        if (grumpy[i]) extra += customers[i];
        // 3. 窗口出：维持窗口长度为minutes，移出过期分钟的挽回收益
        if (i >= minutes && grumpy[i - minutes]) {
            extra -= customers[i - minutes];
        }
        maxExtra = max(maxExtra, extra); // 寻找挽回收益的最大可能
    }
    return base + maxExtra;
}
```

### 2. 变长滑动窗口：求最长

#### [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/ "null")

- **核心逻辑**：利用哈希思想确保窗口内不存在重复。当新加入字符产生冲突时，通过收缩左边界来消除冲突，从而维持窗口的合法性。
    
- **指针移动策略**：
    
    1. **右移扩张**：$R$ 移动并增加当前字符的出现频次。
        
    2. **冲突判断**：如果当前字符的频次 $> 1$，说明重复了。
        
    3. **左移收缩**：$L$ 不断右移，每移出一个字符就减少其频次，直到 $R$ 所指字符的频次降回 $1$。
        

```cpp
int lengthOfLongestSubstring(string s) {
    int cnt[128] = {0}, L = 0, res = 0;
    for (int R = 0; R < s.size(); R++) {
        cnt[s[R]]++; // 1. R右移：记录当前字符
        // 2. 核心：如果当前字符重复了，开始移动L
        while (cnt[s[R]] > 1) {
            cnt[s[L++]]--; // 3. L右移：直到移出那个重复的字符
        }
        res = max(res, R - L + 1); // 4. 更新无重复区间的最大长度
    }
    return res;
}
```

#### [每个字符最多出现两次的最长子数组](https://leetcode.cn/problems/maximum-length-of-a-concatenated-string-with-unique-characters/ "null")

- **核心逻辑**：逻辑同“无重复子串”，只是将重复的判定标准从 $1$ 次改为 $2$ 次。窗口内通过哈希统计频率，确保所有字符频率 $\le 2$。
    
- **指针移动策略**：
    
    1. **累加**：$R$ 移动并对 `nums[R]` 计数。
        
    2. **收缩**：若 `count[nums[R]]` 达到 $3$，$L$ 必须右移并递减经过元素的计数。
        
    3. **停止**：直到 `count[nums[R]]` 恢复为 $2$。
        

```cpp
int maxSubarrayLength(vector<int>& nums, int k) {
    unordered_map<int, int> cnt;
    int L = 0, res = 0;
    for (int R = 0; R < nums.size(); R++) {
        cnt[nums[R]]++; // 1. R进窗口并记录频率
        // 2. 核心逻辑：若某数字出现超过2次，开始收缩L
        while (cnt[nums[R]] > 2) {
            cnt[nums[L++]]--; // 3. L移动并减少频率
        }
        res = max(res, R - L + 1); // 4. 统计满足条件的区间长度
    }
    return res;
}
```

#### [最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/ "null")

- **核心逻辑**：将“翻转 $k$ 个 $0$”转化为“窗口内最多允许包含 $k$ 个 $0$”。寻找满足该条件的最长窗口。
    
- **指针移动策略**：
    
    1. **探测**：$R$ 移动，如果遇到 $0$，则消耗一个翻转额度（`zeroCnt++`）。
        
    2. **越界收缩**：如果 `zeroCnt > k`，说明 $0$ 太多了，额度不足。
        
    3. **额度回收**：$L$ 右移。如果 $L$ 移出的是 $0$，则回收一个额度（`zeroCnt--`）。
        

```cpp
int longestOnes(vector<int>& nums, int k) {
    int L = 0, zeroCnt = 0, res = 0;
    for (int R = 0; R < nums.size(); R++) {
        // 1. 遇到0，增加计数
        if (nums[R] == 0) zeroCnt++;
        // 2. 核心逻辑：若0的个数超过了k，必须收缩L
        while (zeroCnt > k) {
            if (nums[L++] == 0) zeroCnt--; // 3. 移出0时，计数减1
        }
        res = max(res, R - L + 1); // 4. 更新窗口最大宽度
    }
    return res;
}
```

#### [替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/ "null")

- **核心逻辑**：窗口内“除了出现次数最多的字母外，其余字母的总数”不能超过 $k$。使用 `maxFreq` 记录历史上窗口中出现频次最高的字符数。
    
- **指针移动策略**：
    
    1. **统计**：$R$ 移动并更新当前字母频率及 `maxFreq`。
        
    2. **判定**：计算 `(R - L + 1) - maxFreq`。这代表当前窗口内非主流字母的数量。
        
    3. **平移**：如果该值 $> k$，说明无法通过 $k$ 次替换达到平衡，则 $L$ 右移一步（通过平移而非全量收缩来维持寻找“最大”的潜力）。
        

```cpp
int characterReplacement(string s, int k) {
    int cnt[26] = {0}, maxFreq = 0, L = 0, res = 0;
    for (int R = 0; R < s.size(); R++) {
        // 1. 记录当前字母频数并更新窗口内的最高频次
        maxFreq = max(maxFreq, ++cnt[s[R] - 'A']);
        // 2. 核心逻辑：(窗口总长 - 最高频字母数) 即为必须被替换的字符数
        if (R - L + 1 - maxFreq > k) {
            cnt[s[L++] - 'A']--; // 3. 替换名额不足，L右移缩小窗口
        }
        // 4. 注意：此处不需循环收缩，因为我们求的是“最长”，maxFreq不减小结果就不会更优
        res = max(res, R - L + 1);
    }
    return res;
}
```

### 3. 变长滑动窗口：求最短

#### [长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/ "null")

- **核心逻辑**：只要窗口和达到目标，就不断尝试从左边剔除元素，看是否依然能满足条件，从而锁定最短长度。
    
- **指针移动策略**：
    
    1. **求和**：$R$ 向右移动累加。
        
    2. **寻找边界**：当 `sum >= target` 时，开始内层循环。
        
    3. **收缩**：记录当前长度 `R-L+1`，然后 $L$ 右移并减去 `nums[L]`，直到和重新变小。
        

```cpp
int minSubArrayLen(int target, vector<int>& nums) {
    int L = 0, sum = 0, res = INT_MAX;
    for (int R = 0; R < nums.size(); R++) {
        sum += nums[R]; // 1. 累加R指向的值
        // 2. 核心逻辑：满足条件时，尝试收缩L以寻找最短长度
        while (sum >= target) {
            res = min(res, R - L + 1); // 更新最小长度
            sum -= nums[L++];          // 3. L右移并减小和
        }
    }
    return res == INT_MAX ? 0 : res;
}
```

#### [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/ "null")

- **核心逻辑**：双哈希映射平衡法。通过 `valid` 变量记录已满足 $T$ 中字符要求的字符种类数。只有当 `valid` 等于 $T$ 的不同字符种数时，才代表窗口包含 $T$。
    
- **指针移动策略**：
    
    1. **寻找可行解**：$R$ 右移，将字符存入 `window`，若某字符频数达标，`valid++`。
        
    2. **寻找最优解**：当 `valid` 达标，开始收缩 $L$。
        
    3. **打破状态**：记录结果后，$L$ 右移，若移出的字符导致频数不再达标，`valid--`。
        

```cpp
string minWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++; // 初始化目标频率
    int L = 0, R = 0, valid = 0, start = 0, len = INT_MAX;
    while (R < s.size()) {
        char c = s[R++]; // 1. R右移
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c]) valid++; // 某种字符数量达标
        }
        // 2. 核心逻辑：当所有种类都达标，进入收缩阶段
        while (valid == need.size()) {
            if (R - L < len) { start = L; len = R - L; } // 更新最小子串
            char d = s[L++]; // 3. L尝试右移精简窗口
            if (need.count(d)) {
                if (window[d] == need[d]) valid--; // 导致不达标，跳出内层循环
                window[d]--;
            }
        }
    }
    return len == INT_MAX ? "" : s.substr(start, len);
}
```

### 4. 变长滑动窗口：求个数/计数

#### [乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/ "null")

- **核心逻辑**：基于组合计数思想。在一个窗口 $[L, R]$ 满足乘积要求时，以 $R$ 为右边界的所有连续子数组（如 $[R], [R-1, R]...[L, R]$）必然也满足要求。
    
- **指针移动策略**：
    
    1. **累乘**：$R$ 右移并将 `nums[R]` 乘入乘积。
        
    2. **排除**：如果乘积 $\ge k$，$L$ 右移并除以 `nums[L]`。
        
    3. **累加**：合格窗口内子数组个数等于窗口长度 `R - L + 1`。
        

```cpp
int numSubarrayProductLessThanK(vector<int>& nums, int k) {
    if (k <= 1) return 0; // 边界情况
    int L = 0, prod = 1, ans = 0;
    for (int R = 0; R < nums.size(); R++) {
        prod *= nums[R]; // 1. R乘入
        // 2. 核心逻辑：乘积过大则L收缩
        while (prod >= k) prod /= nums[L++];
        // 3. 关键计数：以当前R为终点的符合条件的子数组总数
        ans += R - L + 1; 
    }
    return ans;
}
```

#### [最多有 K 个不同整数的子数组](https://www.google.com/search?q=https://leetcode.cn/problems/subarrays-with-at-most-k-different-integers/ "null")

- **核心逻辑**：差分技巧。求“恰好 $k$ 个”通常很难，但求“最多 $k$ 个”很容易。公式为：`Exactly(K) = atMost(K) - atMost(K-1)`。
    
- **指针移动策略**（针对 `atMost` 函数）：
    
    1. **记录**：$R$ 移动。如果是新数字，`maxK--`。
        
    2. **排除**：若不同数字太多（`maxK < 0`），$L$ 右移。当移出的数字频数归零，说明腾出了一个名额，`maxK++`。
        
    3. **统计**：每次移动 $R$ 后累加窗口长度。
        

```cpp
int subarraysWithKDistinct(vector<int>& nums, int k) {
    // 定义辅助函数：求不同整数个数 <= maxK 的子数组总数
    auto atMost = [&](int maxK) {
        unordered_map<int, int> cnt;
        int L = 0, res = 0;
        for (int R = 0; R < nums.size(); R++) {
            if (cnt[nums[R]]++ == 0) maxK--; // 遇到新数字，名额减1
            // 核心逻辑：当种类超过限制，收缩L
            while (maxK < 0) {
                if (--cnt[nums[L++]] == 0) maxK++; // 某种数字绝迹，名额加1
            }
            res += R - L + 1; // 满足“最多包含maxK个”的以R结尾的数量
        }
        return res;
    };
    // 恰好k = (最多k) - (最多k-1)
    return atMost(k) - atMost(k - 1);
}
```

### 5. 子串排列/异位词

#### [字符串的排列](https://leetcode.cn/problems/permutation-in-string/ "null")

- **核心逻辑**：全排列等价于两个字符串的字符频率数组完全相同。利用定长滑动窗口维护 $S2$ 的局部频率。
    
- **指针移动策略**：
    
    1. **预处理**：先将 $S1$ 全部字符及 $S2$ 的前 `s1.size()` 个字符计入两个数组。
        
    2. **比对**：判断两个频率数组是否相等。
        
    3. **滑动**：$R$ 从 `s1.size()` 开始。$R$ 增加计数值，离开窗口的元素减少计数值。
        

```cpp
bool checkInclusion(string s1, string s2) {
    if (s1.size() > s2.size()) return false;
    vector<int> c1(26), c2(26);
    // 1. 初始化频率比对表
    for (int i = 0; i < s1.size(); i++) {
        c1[s1[i] - 'a']++;
        c2[s2[i] - 'a']++;
    }
    // 2. 核心逻辑：检查初始窗口
    if (c1 == c2) return true;
    // 3. 指针策略：定长R滑动，同步计算出入差
    for (int i = s1.size(); i < s2.size(); i++) {
        c2[s2[i] - 'a']++;            // 进R
        c2[s2[i - s1.size()] - 'a']--; // 出L
        if (c1 == c2) return true;    // 逻辑：频率完全一致则是排列
    }
    return false;
}
```

#### [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/ "null")

- **核心逻辑**：原理同上，即寻找所有字符频率数组与目标 $P$ 一致的窗口起始点。
    
- **指针移动策略**：维护定长窗口，每滑动一步，进行一次频率数组相等性检查。若满足，记录窗口最左端索引。
    

```cpp
vector<int> findAnagrams(string s, string p) {
    int ns = s.size(), np = p.size();
    if (ns < np) return {};
    vector<int> sc(26), pc(26), res;
    // 1. 初始填充频率表
    for (int i = 0; i < np; i++) {
        pc[p[i] - 'a']++;
        sc[s[i] - 'a']++;
    }
    // 2. 核心逻辑：对比第一个窗口
    if (sc == pc) res.push_back(0);
    // 3. 指针策略：定长滑动
    for (int i = np; i < ns; i++) {
        sc[s[i] - 'a']++;        // 进
        sc[s[i - np] - 'a']--;   // 出
        if (sc == pc) res.push_back(i - np + 1); // 4. 匹配成功记录起点
    }
    return res;
}
```