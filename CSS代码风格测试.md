> [!ABSTRACT] 在计算机的世界里，一切皆为二进制。**位运算（Bitwise Operation）不仅是编程语言中执行速度最快的运算，更是理解计算机底层架构的钥匙。** 本文将深入探讨如何仅通过位运算实现基础四则运算，并详解一种极度节省内存的数据结构——**位图**。

[!TOC]

## 1. 位运算实现四则算术运算

在硬件电路中，加减乘除最终都是通过逻辑门（与、或、非、异或）实现的。通过代码模拟这个过程，能帮我们理解计算的本质。

### 1.1 加法：异或与进位的探戈

在位运算中，加法被拆分为两个并行的逻辑：<mark>找出不用进位的部分**</mark> 和 <mark>找出产生进位的部分</mark>。

#### 原理拆解

1. **无进位加法（半加）**：使用 **异或（^）**。
    
    - $0 \oplus 0 = 0$
        
    - $1 \oplus 0 = 1$
        
    - $1 \oplus 1 = 0$ (原本应为10，这里只留0，不进位)
        
    - 结论：<font color="#e74c3c">`a ^ b`</font> 得到了 `a` 和 `b` 相加后，**不考虑进位**的结果。
        
2. **获取进位**：使用 **按位与（&）** 并 **左移（<<1）**。
    
    - 只有 $1 \& 1$ 才会结果为 1，代表这一位会产生进位。
        
    - 进位必须加到它的高一位，所以要左移 1 位。
        
    - 结论：<font color="#e74c3c">`(a & b) << 1`</font> 得到了**所有的进位值**。
        

#### 案例模拟：计算 $13 + 7$

- $13$ 的二进制：`1101`
    
- $7$ 的二进制：`0111`
    

**第一轮循环：**

- `sum = 1101 ^ 0111 = 1010` (无进位和为 10)
    
- `carry = (1101 & 0111) << 1 = 0101 << 1 = 1010` (进位为 10)
    
- 此时变成计算 `1010 + 1010`
    

**第二轮循环：**

- `sum = 1010 ^ 1010 = 0000`
    
- `carry = (1010 & 1010) << 1 = 1010 << 1 = 10100` (进位为 20)
    

**第三轮循环：**

- `sum = 0000 ^ 10100 = 10100`
    
- `carry = (0000 & 10100) << 1 = 0` (进位清零，结束)
    
- **最终结果：`10100`（十进制 20）。**
    

```cpp
int add(int a, int b) {
    int ans = 0;
    while (b) {
        ans = (a ^ b);
        b = ((a & b) << 1);
        a = ans;
    }
    return ans;
}
```

### 1.2 减法：补码的艺术

在数学上，`a - b` 等同于 `a + (-b)`。在计算机中，负数是以 **补码** 形式存储的。

#### 原理拆解

- **如何求 -b？** 根据补码定义，负数等于其绝对值的反码加 1。即 <mark>`-b = ~b + 1`</mark>。
    
- 因此，`a - b` 实际上就是 <font color="#3498db">`add(a, add(~b, 1))`</font>。
    

```cpp
//得到该数的相反数（INT_MIN除外）
int neg(int n) { return add(~n, 1); }

int minus(int a,int b) {
    return add(a, neg(b));
}
```

### 1.3 乘法：模拟小学竖式乘法

回忆小学乘法：计算 $13 \times 5$。我们将 5 拆成 $4 + 1$，然后 $13 \times 4 + 13 \times 1$。 在二进制中，乘数 `b` 的每一位要么是 0，要么是 1。

#### 原理拆解

1. 遍历 `b` 的每一位。
    
2. **如果当前位是 1**，说明这一个“位权”对应的 `a` 应该被累加。
    
3. 每往高位走一步，**`a` 都要左移一位**（模拟位权翻倍）。
    

#### 案例模拟：$5 \times 6$ ($101 \times 110$)

- $b$ 的第 0 位是 0：结果不变，`a` 变成 $1010$ (左移)。
    
- $b$ 的第 1 位是 1：结果 += $1010$，`a` 变成 $10100$ (左移)。
    
- $b$ 的第 2 位是 1：结果 += $10100$，`a` 变成 $101000$ (左移)。
    
- **结束。**
    

```cpp
int multiply(int a, int b) {
    bool sign = (a > 0) ^ (b > 0) ? false : true;
    int ans = 0;
    a = a > 0 ? a : neg(a);
    b = b > 0 ? b : neg(b);
    while (b) {
        if ((b & 1) != 0) {
            ans = add(ans, a);
        }
        a <<= 1;
        b >>= 1;
    }
    return sign ? ans : neg(ans);
}
```

#### 注意：负数位移陷阱

> [!WARNING] 在 C++ 中，对负数使用 `>>` 运算符时，高位通常会根据符号位自动补 `1`（算术右移），这会导致逻辑出错。
> 
> **解决方案：** 用正数进行运算或用转为`unsigned int`类型进行运算（*这里选择前者*）
> 
> 1. <mark>**预处理**</mark>：通过 `neg()` 函数将负数统一转为正数进行运算。
>     
> 2. <mark>**符号还原**</mark>：提前记录 `a` 和 `b` 的正负关系（`sign`），并在计算结束后根据 `sign` 还原最终结果的正负性。
>

### 1.4 除法：位权的递减试探

除法是最复杂的。直接用减法实现除法（a不断减去b直到不够减）效率太低。我们采用类似“二进制搜索”的思路，**从高位向低位试探**。

#### 原理拆解

1. **对齐**：先看除数 `b` 左移多少位能刚好逼近 `a` 但不超过它。
    
2. **试减**：从高位到低位，如果 `a` 能够减去 `(b << i)`，说明商的这一位是 1，减去后继续。
    
3. **商的合并**：用位或 <font color="#3498db">`|`</font> 将每一位的商累积起来。
    

#### 案例模拟：$15 \div 3$ ($1111 \div 0011$)

- 我们从 $i=31$ 递减到 $0$。
    
- 当 $i=2$ 时，`3 << 2` 是 $12$ ($1100$)。
    
- $15 \ge 12$，所以商的第 2 位是 1（`res = 100`），`a` 变为 $15 - 12 = 3$。
    
- 当 $i=0$ 时，`3 << 0` 是 $3$ ($0011$)。
    
- $3 \ge 3$，所以商的第 0 位是 1（`res = 101`），`a` 变为 $3 - 3 = 0$。
    
- **结果：`101`（十进制 5）。**
    

```cpp
// 简化版：缺少一定边界讨论
int div(int a, int b) {
    bool sign = (a > 0) ^ (b > 0) ? false : true;
    int ans = 0;
    a = a > 0 ? a : neg(a);
    b = b > 0 ? b : neg(b);
    for (int i = 30; i >= 0; i = minus(i, 1)) {
        if ((a >> i) >= b) {
            ans |= (1 << i);
            a = minus(a, b << i);
        }
    }
    return sign ? ans: neg(ans);
}
```

---

### 1.5运算实例

[29. 两数相除 - 力扣（LeetCode）](https://leetcode.cn/problems/divide-two-integers/description/)

```cpp
class Solution {
public:
    int add(int a, int b) {
        int ans = 0;
        while (b) {
            ans = (a ^ b);
            b = ((a & b) << 1);
            a = ans;
        }
        return ans;
    }

    int neg(int n) { return add(~n, 1); }

    int minus(int a,int b) {
        return add(a, neg(b));
    }

    int multiply(int a, int b) {
        bool sign = (a > 0) ^ (b > 0) ? false : true;
        int ans = 0;
        a = a > 0 ? a : neg(a);
        b = b > 0 ? b : neg(b);
        while (b) {
            if ((b & 1) != 0) {
                ans = add(ans, a);
            }
            a <<= 1;
            b >>= 1;
        }
        return sign ? ans : neg(ans);
    }

    int div(int a, int b) {
        bool sign = (a > 0) ^ (b > 0) ? false : true;
        int ans = 0;
        a = a > 0 ? a : neg(a);
        b = b > 0 ? b : neg(b);
        for (int i = 30; i >= 0; i = minus(i, 1)) {
            if ((a >> i) >= b) {
                ans |= (1 << i);
                a = minus(a, b << i);
            }
        }
        return sign ? ans: neg(ans);
    }



public:
    
};
```

```

```
## 2. 位图 (BitMap)

### 2.1 什么是位图

> [!TIP] **定义：** 位图是一种基于位的、能够极大地节省存储空间的数据结构。它利用每一个 **比特位（bit）** 来表示某种状态（通常是是否存在）。

**形象理解：** 假设我们要记录 0-7 范围内的数字是否存在。我们可以开辟一个字节（8 bits）。

- 如果数字 3 存在，就把第 3 位设为 1：`00001000`
    
- 如果数字 5 也存在，就把第 5 位设为 1：`00101000`
    

**空间优势：** 如果用 `int` 存储 1 亿个数字，需要约 `400MB`；而使用位图，只需要 $1亿 / 8 / 1024 / 1024 \approx 12.5MB$。**<font color="#27ae60">空间压缩了 32 倍。</font>**

### 2.2 位图的核心操作逻辑

1. **添加元素 (Set)**：<mark>`bits[index / 32] |= (1 << (index % 32))`</mark>
    
2. **删除元素 (Clear)**：<mark>`bits[index / 32] &= ~(1 << (index % 32))`</mark>
    
3. **查找元素 (Test)**：<mark>`return (bits[index / 32] & (1 << (index % 32))) != 0`</mark>
    

### 2.3 位图的应用场景

位图因其高效的查询和极小的空间消耗，广泛应用于大数据场景：

- **海量数据去重**：在 10 亿个 URL 中查找某个 URL 是否出现过。
    
- **快速排序/查找**：如果数据是不重复的正整数，位图本身就是一种天然的排序结果。
    
- **黑名单过滤**：判断一个 IP 地址是否在数千万个黑名单记录中。
    
- **布隆过滤器 (Bloom Filter) 的基石**：利用位图和哈希函数解决高并发下的缓存穿透问题。
    
- **操作系统资源管理**：如磁盘块的状态管理（空闲位图）、内核进程 PID 分配等。
    

## 结语

位运算不仅仅是面试中的“骚操作”，它是**深入理解机器执行机制**的必经之路。而位图则是位运算在实际工程中处理海量数据的艺术结晶。掌握它们，能让你在面临资源受限或性能瓶颈时，拥有更广阔的思考维度。