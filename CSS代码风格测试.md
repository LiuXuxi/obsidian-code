原语，互斥与同步，挂起与阻塞，互斥锁和同步锁

> 一个进程被唤醒，意味着有另一个进程**释放了资源**，但这并不意味着释放者立即放弃了 CPU。释放者可能还在运行，只是它释放的资源让等待者有机会重新竞争 CPU。

- ✅ **释放资源 → 可能唤醒等待者**（当且仅当有人在等）
- ✅ **被唤醒 → 必定有释放者**
- ⚠️ **被唤醒 ≠ 释放者放弃 CPU**（释放者可能还在运行）

这正是信号量机制精妙之处：**资源的释放与进程的唤醒解耦，但又通过信号量值紧密关联**。

---
在记录型信号量中，`value` 的含义是：

- `value > 0`：还有 `value` 个资源可用。
- `value = 0`：资源刚好用完，没人等待。
- `value < 0`：资源用完，且有 `|value|` 个进程在等待队列中。

所以，当 `value` 变成 -1 时，它**同时表达了两个信息**：

1. 资源已耗尽。
2. 有 1 个进程在等。

如果你在睡着后 `value++`，你就抹掉了“有人在等”这个信息，系统就无法在资源释放时唤醒你。

---

	进程调度器今天突然召集大伙，说是要讨论一件重要的事情，问他他还卖关子：“你去了就知道，我现在不告诉你们。”
	还没到约定时间，大伙儿就已经来到了内存家，只见进程调度器气定神闲的坐在椅子上，翘着个二郎腿，好不自在。
	“调度器老哥，现在人也都来的差不多了，咱们现在就开始吧，早点结束大家伙儿好接着回去干活啊。”
	调度器“嗯”了一声，起身走向白板，说：“我向大家先说明一下背景吧，咱们原来的调度算法，比如先来先服务，短进程优先，优先级调度等等，大都是为了优化周转时间和响应时间，效果也还不错。不过这些算法，有些可能会导致饥饿的问题，我想不少进程深有体会。”
	饥饿问题确实困扰操作系统很长时间了，虽然饥饿不如死锁那么有破坏力，但还是影响到了进程家庭内部的和谐。听调度器的意思，他是能解决这个问题？
	几个低优先级进程开始小声议论起来，像他们这种优先级别低的，总会因为高优先级进程“插队”而得不到 CPU 资源，心里早就憋着一口气呢。忍不住问调度器：“现在是有什么好办法了吗？我们可受够饥饿的生活了！”
	调度器得意的说：“那当然，不然我今天把你们大伙叫过来干什么？我最近想到一个好点子，咱们可以调整一下调度目标，改成确保每个任务获得一定比例的 CPU 时间，这样只要我们提前约定好份额，每个人最后都可以享受到应有的待遇，不可能出现某一进程独占的现象！听起来是不是很公平？我打算把这类算法叫「比例份额调度」或者「公平份额调度」。”
	系统进程提出了质疑：“公平？你别说大话了，这个目标咱们又不是没有追求过，也就时间片轮转算法勉强达到了我们的要求，可一旦再划分出优先级（指的是多级优先队列调度），就可能会造成进程饥饿，追求公平可不是那么简单的！”
	“你先听我说嘛，绝对的公平确实很难达到，我们现在退而求其次，追求一个相对公平——就是说短时间里可能会有些许不公平，但从长期来看，大家在 CPU 上运行的时间所占比例就是一开始约定好的。”
	“听起来很有道理，但是你打算怎么实现？”
	“嘿嘿，我给这个方法取名叫「彩票调度」，咱们一开始的时候给每个进程发彩票——优先级越高，发的彩票越多，然后每隔一段时间（一个时间片），举行一次彩票抽奖，抽出来的号是谁的，谁就能运行~”
	“哈哈哈哈，我还以为是什么厉害的算法呢”，一时间，大家都笑了出来，整个内存里充满了快活的气息。调度器的脸唰的一下就红了。
	操作系统吐槽道：“调度器，你是不是跟那帮人类学坏了？在我们这儿还搞什么彩票，下一步是不是打算骗大家的时间片？再这么搞下去，小心我把你职位撤了啊！”
	调度器赶紧为自己解释："诶，我可是经过深思熟虑才想出来的，你们别误会啊！打个比方吧，假如有两个进程 A 和 B，我想让 A 占用 80% 的 CPU 时间，B 占用 20% 的 CPU 时间，我就给 A 发80 张彩票，给 B 发 20 张彩票。这样，每次抽奖的时候，A 就有 80% 的概率占用 CPU，从数学期望上讲，1秒钟之内，A 能运行 800ms。我是打算利用随机性来达到按比例分配的目标的，可从没打算骗大家。"
	操作系统看起来有点认可这个算法了，他点点头：“有点意思，你接着说下去。”
	调度器松了一口气，继续说：“我觉得这种算法有个很好的地方——即使某进程只有一张彩票，经过多轮迭代，他总会获得 CPU 的使用权。所以饥饿的问题就能解决了~"
	"别急，还没完呢！你们想想，咱们用过的「最短响应比优先」算法，还得记录每个进程在就绪队列等待了多长时间，多麻烦！我这个「彩票调度」，不需要记录任何状态，拿来就用，特别的轻量，而且这种随机方法很快，只要生成一个随机数，就能快速做出决策。为了向你们展示，我还特意写了段伪代码。"

---

为了解决上述冲突和碎片问题，现代操作系统引入了**虚拟内存（Virtual Memory）**和**内存管理单元（MMU）**2。

这就回答了你“如何保证不冲突”的核心问题：**每个进程都认为自己独占整个内存，物理地址的分配由硬件和操作系统协作动态完成，从根本上隔离了冲突。**

具体机制如下：

- **引入“地址空间”抽象：**  
    就像每个进程拥有一个独立的“虚拟世界”。进程A的地址0x1000和进程B的地址0x1000，虽然逻辑上都是0x1000，但通过**页表（Page Table）**映射到了完全不同的物理内存位置12。
    
- **MMU与页表的转换：**  
    现代CPU不再直接使用简单的基址寄存器，而是使用更复杂的**页表基址寄存器（如x86的CR3寄存器）**。
    
    - 当进程切换时，操作系统会把该进程独有的**页表基地址**加载到CR3寄存器中。
    - 进程访问虚拟地址时，MMU根据当前CR3指向的页表，将虚拟地址翻译成物理地址2。

**为什么这样能保证不冲突？**  
因为每个进程的页表都是独立的。进程A的虚拟页0可能映射到物理页框10，而进程B的虚拟页0映射到物理页框20。它们互不干扰。即使两个进程使用了相同的虚拟地址，硬件也会把它们导向不同的物理位置。