  
# 原理
  ![[Pasted image 20260219165537.png]]

![[Pasted image 20260219170130.png]]

```cpp
class Solution {

public:

    int head[101]={0};

    int next[6001]={0};

    int to[6001]={0};

    int weight[6001]={0};

    int distance[101];

    bool visited[101];

    int cnt=1;

  

    void addEdge(int u,int v,int w){

        next[cnt]=head[u];

        to[cnt]=v;

        weight[cnt]=w;

        head[u]=cnt++;

    }

  

    int networkDelayTime(vector<vector<int>>& times, int n, int k) {

        for(auto&time:times)addEdge(time[0],time[1],time[2]);

        for(int i=0;i<=n;i++){

            distance[i]=INT_MAX;

            visited[i]=false;

        }

        priority_queue< pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> >wait;

        wait.push({0,k});

        distance[k]=0;

        while(!wait.empty()){

            pair<int,int>cur=wait.top();

            wait.pop();

            int u=cur.second;

            if(visited[u])continue;

            visited[u]=true;

            for(int ei=head[u];ei!=0;ei=next[ei]){

                int v=to[ei],w=weight[ei];

                if(!visited[v]&&distance[u]+w<distance[v]){

                    distance[v]=distance[u]+w;

                    wait.push({distance[v],v});

                }

            }

        }

        int ans=0;

        for(int i=1;i<=n;i++){

            ans=max(ans,distance[i]);

            if(!visited[i])return -1;

        }

        return ans;

    }

};
```

[1631. 最小体力消耗路径 - 力扣（LeetCode）](https://leetcode.cn/problems/path-with-minimum-effort/)

```cpp
class Solution {

public:

    int minimumEffortPath(vector<vector<int>>& heights) {

        vector<int>move{-1,0,1,0,-1};

        int n=heights.size(),m=heights[0].size();

        vector<vector<int>>weights(n,vector<int>(m,__INT_MAX__));

        weights[0][0]=0;

        vector<vector<bool>>visited(n,vector<bool>(m,false));

        auto cmp=[](const vector<int>&a,const vector<int>&b){return a[2]>b[2];};

        priority_queue<vector<int>,vector<vector<int>>,decltype(cmp)>wait(cmp);

        wait.push({0,0,0});

        while(!wait.empty()){

            vector<int>cur=wait.top();

            wait.pop();

            int x=cur[0],y=cur[1],w=cur[2];

            if(x==n-1&&y==m-1)return weights[x][y];

            if(visited[x][y])continue;

            visited[x][y]=true;

            for(int i=0;i<4;i++){

                int nx=x+move[i],ny=y+move[i+1];

                if(nx>=0&&ny>=0&&nx<n&&ny<m){

                    int cost=max(w,(int)fabs(heights[nx][ny]-heights[x][y]));

                    if(cost<weights[nx][ny]){

                        weights[nx][ny]=cost;

                        wait.push({nx,ny,cost});

                    }

                }

            }

        }

        return -1;

    }

};
```



```cpp
class Solution {

public:

    int swimInWater(vector<vector<int>>& grid) {

        vector<int>move{-1,0,1,0,-1};

        int n=grid.size();

        vector<vector<int>>distance(n,vector<int>(n,INT_MAX));

        distance[0][0]=0;

        vector<vector<bool>>visited(n,vector<bool>(n,false));

        auto cmp=[](const vector<int>&a,const vector<int>&b){return a[2]>b[2];};

        priority_queue<vector<int>,vector<vector<int>>,decltype(cmp)>wait(cmp);

        wait.push({0,0,0});

        while(!wait.empty()){

            vector<int>cur=wait.top();

            wait.pop();

            int x=cur[0],y=cur[1],w=cur[2];

            if(x==n-1&&y==n-1)return distance[x][y];

            if(visited[x][y])continue;

            visited[x][y]=true;

            for(int i=0;i<4;i++){

                int nx=x+move[i],ny=y+move[i+1];

                if(nx<n&&ny<n&&nx>=0&&ny>=0){

                    int cost=max(w,max(grid[x][y],grid[nx][ny]));

                    if(distance[nx][ny]>cost)distance[nx][ny]=cost;

                    wait.push({nx,ny,cost});

                }

            }

        }

        return -1;

    }

};
```


# 分层图最短路

