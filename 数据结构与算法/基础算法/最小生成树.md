![[Pasted image 20260211133040.png]]

 # Kruskal算法
 ![[Pasted image 20260211133252.png]]

[P3366 【模板】最小生成树 - 洛谷](https://www.luogu.com.cn/problem/P3366)

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

#define MAXN 50001
#define MAXM 200001

int father[MAXN];
vector<vector<int>>edges;
int n,m;

void build(){
    for(int i=0;i<n;i++)father[i]=i;
    edges.resize(MAXM,vector<int>(3,0));
}

int find(int x){
    if(father[x]!=x)father[x]=find(father[x]);
    return father[x];
}

bool Union(int a,int b){
    int fa=find(a),fb=find(b);
    if(fa!=fb){
        father[fa]=fb;
        return true;
    }
    return false;
}

int solve(){
    sort(edges.begin(),edges.end(),
    [](const vector<int>&a,const vector<int>&b){
        return a[2]<b[2];
    });
    int cnt=0,ans=0;
    for(auto&edge:edges){
        if(Union(edge[0],edge[1])){
            ++cnt;
            ans+=edge[2];
        }
    }
    return cnt==n-1?ans:-1;
}

int main(){
    cin>>n>>m;
    build();
    for(int i=0;i<m;i++){
        cin>>edges[i][0]>>edges[i][1]>>edges[i][2];
    }
    int ans=solve();
    if(ans==-1)cout<<"orz"<<endl;
    else cout<<ans<<endl;
    return 0;
}
```

# Prim算法
![[Pasted image 20260211135453.png]]

