> [!ABSTRACT] 在计算机的世界里，一切皆为二进制。**位运算（Bitwise Operation）不仅是编程语言中执行速度最快的运算，更是理解计算机底层架构的钥匙。** 本文将深入探讨如何仅通过位运算实现基础四则运算，并详解一种极度节省内存的数据结构——**位图**。

[TOC]

## 1. 位运算实现四则算术运算

在硬件电路中，加减乘除最终都是通过逻辑门（与、或、非、异或）实现的。通过代码模拟这个过程，能帮我们理解计算的本质。

### 1.1 加法：异或与进位的探戈

在位运算中，加法被拆分为两个并行的逻辑：<mark>找出不用进位的部分**</mark> 和 <mark>找出产生进位的部分</mark>。

#### 原理拆解

1. **无进位加法（半加）**：使用 **异或（^）**。
    
    - $0 \oplus 0 = 0$
        
    - $1 \oplus 0 = 1$
        
    - $1 \oplus 1 = 0$ (原本应为10，这里只留0，不进位)
        
    - 结论：<font color="#e74c3c">`a ^ b`</font> 得到了 `a` 和 `b` 相加后，**不考虑进位**的结果。
        
2. **获取进位**：使用 **按位与（&）** 并 **左移（<<1）**。
    
    - 只有 $1 \& 1$ 才会结果为 1，代表这一位会产生进位。
        
    - 进位必须加到它的高一位，所以要左移 1 位。
        
    - 结论：<font color="#e74c3c">`(a & b) << 1`</font> 得到了**所有的进位值**。
        

#### 案例模拟：计算 $13 + 7$

- $13$ 的二进制：`1101`
    
- $7$ 的二进制：`0111`
    

**第一轮循环：**

- `sum = 1101 ^ 0111 = 1010` (无进位和为 10)
    
- `carry = (1101 & 0111) << 1 = 0101 << 1 = 1010` (进位为 10)
    
- 此时变成计算 `1010 + 1010`
    

**第二轮循环：**

- `sum = 1010 ^ 1010 = 0000`
    
- `carry = (1010 & 1010) << 1 = 1010 << 1 = 10100` (进位为 20)
    

**第三轮循环：**

- `sum = 0000 ^ 10100 = 10100`
    
- `carry = (0000 & 10100) << 1 = 0` (进位清零，结束)
    
- **最终结果：`10100`（十进制 20）。**
    

```cpp
int add(int a, int b) {
    int ans = 0;
    while (b) {
        ans = (a ^ b);
        b = ((a & b) << 1);
        a = ans;
    }
    return ans;
}
```

### 1.2 减法：补码的艺术

在数学上，`a - b` 等同于 `a + (-b)`。在计算机中，负数是以 **补码** 形式存储的。

#### 原理拆解

- **如何求 -b？** 根据补码定义，负数等于其绝对值的反码加 1。即 <mark>`-b = ~b + 1`</mark>。
    
- 因此，`a - b` 实际上就是 <font color="#3498db">`add(a, add(~b, 1))`</font>。
    

```cpp
//得到该数的相反数（INT_MIN除外）
int neg(int n) { return add(~n, 1); }

int minus(int a,int b) {
    return add(a, neg(b));
}
```

### 1.3 乘法：模拟小学竖式乘法

回忆小学乘法：计算 $13 \times 5$。我们将 5 拆成 $4 + 1$，然后 $13 \times 4 + 13 \times 1$。 在二进制中，乘数 `b` 的每一位要么是 0，要么是 1。

#### 原理拆解

1. 遍历 `b` 的每一位。
    
2. **如果当前位是 1**，说明这一个“位权”对应的 `a` 应该被累加。
    
3. 每往高位走一步，**`a` 都要左移一位**（模拟位权翻倍）。
    

#### 案例模拟：$5 \times 6$ ($101 \times 110$)

- $b$ 的第 0 位是 0：结果不变，`a` 变成 $1010$ (左移)。
    
- $b$ 的第 1 位是 1：结果 += $1010$，`a` 变成 $10100$ (左移)。
    
- $b$ 的第 2 位是 1：结果 += $10100$，`a` 变成 $101000$ (左移)。
    
- **结束。**
    

```cpp
int multiply(int a, int b) {
    bool sign = (a > 0) ^ (b > 0) ? false : true;
    int ans = 0;
    a = a > 0 ? a : neg(a);
    b = b > 0 ? b : neg(b);
    while (b) {
        if ((b & 1) != 0) {
            ans = add(ans, a);
        }
        a <<= 1;
        b >>= 1;
    }
    return sign ? ans : neg(ans);
}
```

#### 注意：负数位移陷阱

> [!WARNING] 在 C++ 中，对负数使用 `>>` 运算符时，高位通常会根据符号位自动补 `1`（算术右移），这会导致逻辑出错。
> 
> **解决方案：** 用正数进行运算或用转为`unsigned int`类型进行运算（*这里选择前者*）
> 
> 1. <mark>**预处理**</mark>：通过 `neg()` 函数将负数统一转为正数进行运算。
>     
> 2. <mark>**符号还原**</mark>：提前记录 `a` 和 `b` 的正负关系（`sign`），并在计算结束后根据 `sign` 还原最终结果的正负性。
>

### 1.4 除法：位权的递减试探

除法是最复杂的。直接用减法实现除法（a不断减去b直到不够减）效率太低。我们采用类似“二进制搜索”的思路，**从高位向低位试探**。

#### 原理拆解

1. **对齐**：先看除数 `b` 左移多少位能刚好逼近 `a` 但不超过它。
    
2. **试减**：从高位到低位，如果 `a` 能够减去 `(b << i)`，说明商的这一位是 1，减去后继续。
    
3. **商的合并**：用位或 <font color="#3498db">`|`</font> 将每一位的商累积起来。
    

#### 案例模拟：$15 \div 3$ ($1111 \div 0011$)

- 我们从 $i=31$ 递减到 $0$。
    
- 当 $i=2$ 时，`3 << 2` 是 $12$ ($1100$)。
    
- $15 \ge 12$，所以商的第 2 位是 1（`res = 100`），`a` 变为 $15 - 12 = 3$。
    
- 当 $i=0$ 时，`3 << 0` 是 $3$ ($0011$)。
    
- $3 \ge 3$，所以商的第 0 位是 1（`res = 101`），`a` 变为 $3 - 3 = 0$。
    
- **结果：`101`（十进制 5）。**
    

```cpp
// 简化版：缺少一定边界讨论
int div(int a, int b) {
    bool sign = (a > 0) ^ (b > 0) ? false : true;
    int ans = 0;
    a = a > 0 ? a : neg(a);
    b = b > 0 ? b : neg(b);
    for (int i = 30; i >= 0; i = minus(i, 1)) {
        if ((a >> i) >= b) {
            ans |= (1 << i);
            a = minus(a, b << i);
        }
    }
    return sign ? ans: neg(ans);
}
```

---

### 1.5运算实例

[29. 两数相除 - 力扣（LeetCode）](https://leetcode.cn/problems/divide-two-integers/description/)

```cpp
class Solution {
public:
    int add(int a, int b) {
        int ans = 0;
        while (b) {
            ans = (a ^ b);
            b = ((a & b) << 1);
            a = ans;
        }
        return ans;
    }

    int neg(int n) { return add(~n, 1); }

    int minus(int a,int b) {
        return add(a, neg(b));
    }

    int multiply(int a, int b) {
        bool sign = (a > 0) ^ (b > 0) ? false : true;
        int ans = 0;
        a = a > 0 ? a : neg(a);
        b = b > 0 ? b : neg(b);
        while (b) {
            if ((b & 1) != 0) {
                ans = add(ans, a);
            }
            a <<= 1;
            b >>= 1;
        }
        return sign ? ans : neg(ans);
    }

    int div(int a, int b) {
        bool sign = (a > 0) ^ (b > 0) ? false : true;
        int ans = 0;
        a = a > 0 ? a : neg(a);
        b = b > 0 ? b : neg(b);
        for (int i = 30; i >= 0; i = minus(i, 1)) {
            if ((a >> i) >= b) {
                ans |= (1 << i);
                a = minus(a, b << i);
            }
        }
        return sign ? ans: neg(ans);
    }



public:
    int divide(int dividend, int divisor) {
    // 边界情况 1：被除数和除数都是最小负数，结果为 1
    if (dividend == INT_MIN && divisor == INT_MIN) 
        return 1;
    
    // 边界情况 2：INT_MIN / -1 会导致溢出（结果应该是 2^31，但 int 最大只能表示 2^31 - 1）
    // 根据题目常规要求，返回 INT_MAX
    else if (dividend == INT_MIN && divisor == -1) 
        return INT_MAX;
    
    // 边界情况 3：除数是 INT_MIN，而被除数不是。
    // 因为任何比 INT_MIN 绝对值小的数除以 INT_MIN，整数部分结果都是 0
    else if (dividend != INT_MIN && divisor == INT_MIN) 
        return 0;
    
    // 核心逻辑 A：如果被除数不是 INT_MIN，可以直接调用自定义的 div 函数进行位运算除法
    // 注：此处代码原句为 dividend != INT_MIN && dividend != INT_MIN，疑似笔误，应为 divisor != INT_MIN
    else if (dividend != INT_MIN) 
        return div(dividend, divisor);
    
    // 核心逻辑 B：处理被除数恰好等于 INT_MIN 的情况
    // 为了防止直接取反导致溢出，这里采用“先补偿、再计算”策略：
    else {
        // 1. 先将被除数靠近 0 一点点。
        // 如果除数是正数，就加上它；如果是负数，就减去它（即加上其绝对值）
        // 这样做的目的是让 dividend 退出 INT_MIN 状态，从而能安全进入 div 函数
        dividend = add(dividend, divisor > 0 ? divisor : neg(divisor));
        
        // 2. 计算补偿后的商
        int ans = div(dividend, divisor);
        
        // 3. 修正偏移量。
        // 因为前面手动将被除数靠近了 0（相当于少算了一次除数），所以结果需要补上这一次
        // 如果除数是正数，由于被除数是负的，商应该减 1；如果除数是负数，商应该加 1
        int offset = divisor > 0 ? neg(1) : 1;
        
        return add(ans, offset);
    }
}
};
```


## 2. 位图 (BitMap)

### 2.1 什么是位图

> [!TIP] **定义：** 位图是一种基于位的、能够极大地节省存储空间的数据结构。它利用每一个 **比特位（bit）** 来表示某种状态（通常是是否存在）。

**形象理解：** 假设我们要记录 0-7 范围内的数字是否存在。我们可以开辟一个字节（8 bits）。

- 如果数字 3 存在，就把第 3 位设为 1：`00001000`
    
- 如果数字 5 也存在，就把第 5 位设为 1：`00101000`
    

**空间优势：** 如果用 `int` 存储 1 亿个数字，需要约 `400MB`；而使用位图，只需要 $1亿 / 8 / 1024 / 1024 \approx 12.5MB$。**<font color="#27ae60">空间压缩了 32 倍。</font>**

### 2.2 位图的核心操作逻辑

1. **添加元素 (Set)**：<mark>`bits[index / 32] |= (1 << (index % 32))`</mark>
    
2. **删除元素 (Clear)**：<mark>`bits[index / 32] &= ~(1 << (index % 32))`</mark>
    
3. **查找元素 (Test)**：<mark>`return (bits[index / 32] & (1 << (index % 32))) != 0`</mark>
    

### 2.3 位图的应用场景

位图因其高效的查询和极小的空间消耗，广泛应用于大数据场景：

- **海量数据去重**：在 10 亿个 URL 中查找某个 URL 是否出现过。
    
- **快速排序/查找**：如果数据是不重复的正整数，位图本身就是一种天然的排序结果。
    
- **黑名单过滤**：判断一个 IP 地址是否在数千万个黑名单记录中。
    
- **布隆过滤器 (Bloom Filter) 的基石**：利用位图和哈希函数解决高并发下的缓存穿透问题。
    
- **操作系统资源管理**：如磁盘块的状态管理（空闲位图）、内核进程 PID 分配等。
    
#### 与有限状态机结合

---

#### 布隆过滤器
---

#### N皇后问题

##### 1.常规解法

**大致思路：** 遍历每行每个位置，判断该位置是否能放置皇后，如果能放置，累加下一行开始放置皇后的种类数。

**递归剪枝：** 每个位置放置皇后之后（如果能放置的话），都需要从下一行开始遍历每个位置并判断放置，每次进行这个过程相同但繁琐，所以可以交给递归进行。递归函数表示为==返回从 row 行到最后一行的合法方案数==。

**检查逻辑：** 检查该位置是否能够放置皇后， 

```cpp
class Solution {
public:
    int totalNQueens(int n) {
        // n < 1 时没有合法解
        if (n < 1) return 0;

        // line[i] 表示第 i 行皇后所在的列号
        vector<int> line(n);

        // 从第 0 行开始递归放皇后
        return f(n, 0, line);
    }

    // 在第 row 行放皇后，返回从 row 行到最后一行的合法方案数
    int f(int n, int row, vector<int>& line) {
        // 所有行都已经成功放置，得到一种解
        if (row == n) return 1;

        int ans = 0;

        // 尝试在当前行的每一列放皇后
        for (int j = 0; j < n; j++) {
            // 检查在 (row, j) 放皇后是否合法
            if (check(row, j, line)) {
                // 记录当前行皇后放在第 j 列
                line[row] = j;

                // 递归处理下一行
                ans += f(n, row + 1, line);
            }
        }
        return ans;
    }

    // 检查在 (i, j) 位置放皇后是否与前面行的皇后冲突
    bool check(int i, int j, vector<int>& line) {
        // 只需要检查 0 ~ i-1 行
        for (int k = 0; k < i; k++) {
            // 同列冲突
            // 对角线冲突：行差 == 列差
            if (j == line[k] || abs(k - i) == abs(line[k] - j))
                return false;
        }
        return true;
    }
};
```
##### 2.位图解法

```cpp
class Solution {
public:
    int totalNQueens(int n) {
        if (n < 1) return 0;

        // limit 的低 n 位全是 1，用于限制棋盘范围
        int limit = (1 << n) - 1;

        // line：已占用的列
        // left：左对角线攻击位置
        // right：右对角线攻击位置
        return f(limit, 0, 0, 0);
    }

    // line、left、right 都是位掩码
    int f(int limit, int line, int left, int right) {
        // 当所有列都被占满（说明成功放置了 n 个皇后）
        if (line == limit) return 1;

        int ans = 0;

        // candidate 表示当前行所有可以放皇后的合法位置
        // ~(line | left | right)：得到所有被攻击的位置的补集
        // 再与 limit 相与，去掉无效的高位
        int candidate = limit & (~(line | left | right));

        // 依次尝试 candidate 中的每一个 1
        while (candidate) {
            // 取出最右侧的 1（最低位的合法位置）
            int place = candidate & (-candidate);

            // 将该位置从 candidate 中移除
            candidate &= candidate - 1;

            // 递归：
            // line | place：占用该列
            // (left | place) >> 1：左斜线下一行左移
            // (right | place) << 1：右斜线下一行右移
            ans += f(limit,
                     line | place,
                     (left | place) >> 1,
                     (right | place) << 1);
        }
        return ans;
    }
};

```

