# 位运算与位图：从底层逻辑到极致优化

在计算机的世界里，一切皆为二进制。位运算（Bitwise Operation）不仅是编程语言中执行速度最快的运算，更是理解计算机底层架构的钥匙。本文将深入探讨如何仅通过位运算实现基础四则运算，并详解一种极度节省内存的数据结构——位图。

## 1. 位运算实现四则算术运算

在硬件电路中，加减乘除最终都是通过逻辑门（与、或、非、异或）实现的。通过代码模拟这个过程，能帮我们理解计算的本质。

### 1.1 加法：异或与进位的探戈

位运算加法主要依靠两个逻辑点：

1. **无进位加法**：使用 **异或（^）**。$0 \oplus 0 = 0$, $1 \oplus 0 = 1$, $1 \oplus 1 = 0$。这正好符合加法在不考虑进位时的结果。
    
2. **获取进位**：使用 **按位与（&）** 并 **左移（<<1）**。只有 $1 \& 1$ 才会产生进位，进位需要加到更高的一位。
    

**逻辑推导：** 将 `a + b` 分解为 `无进位和` + `进位`。重复此过程，直到进位为 0。

```
int add(int a, int b) {
    while (b != 0) {
        int sum = a ^ b;       // 无进位加法
        int carry = (a & b) << 1; // 得到进位
        a = sum;
        b = carry;
    }
    return a;
}
```

### 1.2 减法：利用补码性质

根据数学原理：`a - b = a + (-b)`。 在计算机中，负数的存储方式是 **补码**。补码的定义是：反码加 1，即 `~b + 1`。

**逻辑推导：** 直接调用我们写好的加法函数即可。

```
int sub(int a, int b) {
    return add(a, add(~b, 1));
}
```

### 1.3 乘法：模拟位权移动

乘法的本质是累加。例如 $5 \times 6$（二进制 $101 \times 110$）： $101 \times (1 \cdot 2^2 + 1 \cdot 2^1 + 0 \cdot 2^0) = (101 << 2) + (101 << 1) + 0$。

**逻辑推导：** 遍历乘数 `b` 的每一位，如果当前位为 1，则将被乘数 `a` 左移相应位数后加到结果中。

```
int mul(int a, int b) {
    int res = 0;
    while (b != 0) {
        if ((b & 1) != 0) {
            res = add(res, a);
        }
        a <<= 1;  // 被乘数左移
        b >>= 1;  // 乘数右移（如果是负数，需考虑无符号右移）
    }
    return res;
}
```

### 1.4 除法：减法与位权的试探

除法的本质是看被除数里包含多少个除数。为了效率，我们从高位向低位试探。

**逻辑推导：** 让除数左移到刚好小于被除数的最大位置，减去它，记录商，然后继续处理剩余部分。

```
// 简化版逻辑（假设为正数）
int div(int a, int b) {
    int res = 0;
    for (int i = 31; i >= 0; i = sub(i, 1)) {
        if ((a >> i) >= b) {
            res |= (1 << i);
            a = sub(a, b << i);
        }
    }
    return res;
}
```

## 2. 位图 (BitMap)

### 2.1 什么是位图

**定义：** 位图是一种基于位的、能够极大地节省存储空间的数据结构。它利用每一个比特位（bit）来表示某种状态（通常是是否存在）。

**形象理解：** 假设我们要记录 0-7 范围内的数字是否存在。我们可以开辟一个字节（8 bits）。

- 如果数字 3 存在，就把第 3 位设为 1：`00001000`
    
- 如果数字 5 也存在，就把第 5 位设为 1：`00101000`
    

**空间优势：** 如果用 `int` 存储 1 亿个数字，需要约 `400MB`；而使用位图，只需要 $1亿 / 8 / 1024 / 1024 \approx 12.5MB$。**空间压缩了 32 倍。**

### 2.2 位图的核心操作逻辑

1. **添加元素 (Set)**：`bits[index / 32] |= (1 << (index % 32))`
    
2. **删除元素 (Clear)**：`bits[index / 32] &= ~(1 << (index % 32))`
    
3. **查找元素 (Test)**：`return (bits[index / 32] & (1 << (index % 32))) != 0`
    

### 2.3 位图的应用场景

位图因其高效的查询和极小的空间消耗，广泛应用于大数据场景：

- **海量数据去重**： 在 10 亿个 URL 中查找某个 URL 是否出现过。
    
- **快速排序/查找**： 如果数据是不重复的正整数，位图本身就是一种天然的排序结果（遍历位图，输出为 1 的下标）。
    
- **黑名单过滤**： 判断一个 IP 地址或电话号码是否在数千万个黑名单记录中。
    
- **布隆过滤器 (Bloom Filter) 的基石**： 布隆过滤器通过多个哈希函数映射到位图中，用于解决缓存穿透问题，虽然存在误判率，但空间效率更高。
    
- **操作系统资源管理**： 如磁盘分区块的状态管理、内核进程 PID 分配等。
    

## 结语

位运算不仅仅是面试中的“骚操作”，它是深入理解机器执行机制的必经之路。而位图则是位运算在实际工程中处理海量数据的艺术结晶。掌握它们，能让你在面临资源受限或性能瓶颈时，拥有更广阔的思考维度。