
# 类实现前缀树

[208. 实现 Trie (前缀树) - 力扣（LeetCode）](https://leetcode.cn/problems/implement-trie-prefix-tree/)

```cpp
class Trie {

public:

    Trie() {

        root = new Node;

    }

  

    void insert(string word) {

        root->pass++;

        Node* node = root;

        for (auto& c : word) {

            int path = c - 'a';

            if (node->nexts[path] == nullptr) {

                node->nexts[path] = new Node;

            }

            node = node->nexts[path];

            ++node->pass;

        }

        ++node->end;

    }

  

    bool search(string word) {

        Node* node = root;

        for (auto& c : word) {

            int path = c - 'a';

            if (node->nexts[path] == nullptr)return false;

            node = node->nexts[path];

        }

        return node->end != 0  ;

    }

  

    bool startsWith(string prefix) {

        Node* node = root;

        for (auto& c : prefix) {

            int path = c - 'a';

            if (node->nexts[path] == nullptr)return false;

            node = node->nexts[path];

        }

        return true;

    }

  

private:

    class Node {

    public:

        int pass;

        int end;

        unordered_map<int, Node*>nexts;

  

    public:

        Node():pass(0),end(0),nexts(unordered_map<int,Node*>()) {}

    };

  

public:

    Node* root;

};
```

# 静态空间实现前缀树

[字典树的实现_牛客题霸_牛客网](https://www.nowcoder.com/practice/7f8a8553ddbf4eaab749ec988726702b)

```cpp
#include<iostream>

#include<vector>

#include<string>

using namespace std;

  

#define MAXN 150001

  

class Trie {

public:

    Trie() : trie(MAXN, vector<int>(26, 0)),

        pass(MAXN, 0),

        end(MAXN, 0),

        cnt(1) {  // 注意：cnt 初始化为 1

    }

  

    void insert(string word) {

        int cur = 1;

        ++pass[cur];

        for (auto& c : word) {

            int path = c - 'a';

            if (trie[cur][path] == 0)trie[cur][path] = ++cnt;

            cur = trie[cur][path];

            ++pass[cur];

        }

        ++end[cur];

    }

  

    void del(string word) {

        if (search(word)) {

            int cur = 1;

            for (auto& c : word) {

                int path = c - 'a';

                if (--pass[trie[cur][path]] == 0) {

                    trie[cur][path] = 0;

                    return;

                }

                cur = trie[cur][path];

            }

            --end[cur];

        }

    }

  

    bool search(string word) {

        int cur = 1;

        for (auto& c : word) {

            int path = c - 'a';

            if (trie[cur][path] == 0)return false;

            cur = trie[cur][path];

        }

        return end[cur] > 0;

    }

  

    int prefixNumber(string pre) {

        int cur = 1;

        for (auto& c : pre) {

            int path = c - 'a';

            if (trie[cur][path] == 0)return 0;

            cur = trie[cur][path];

        }

        return pass[cur];

    }

  

private:

    vector<vector<int>>trie;

    vector<int>pass;

    vector<int>end;

    int cnt;

};

  

int main() {

    int m;

    cin >> m;

    Trie t;

    while (m--) {

        int op;

        string word;

        cin >> op >> word;

        switch (op) {

        case 1:

            t.insert(word);

            break;

        case 2:

            t.del(word);

            break;

        case 3:

            if (t.search(word))cout << "YES" << endl;

            else cout << "NO" << endl;

            break;

        case 4:

            cout << t.prefixNumber(word) << endl;

            break;

        }

    }

    return 0;

}
```

## 相关题目

[接头密匙_牛客题霸_牛客网](https://www.nowcoder.com/practice/c552d3b4dfda49ccb883a6371d9a6932)

```cpp
class Solution {

private:

    class Trie {

    public:

    #define MAXN 150001

        Trie() : trie(MAXN, vector<int>(12, 0)),

            pass(MAXN, 0),

            end(MAXN, 0),

            cnt(1) {  

        }

  

        void insert(string word) {

            int cur = 1;

            ++pass[cur];

            for (auto& c : word) {

                int path;

                if (isalnum(c))path = c - '0';

                else if (c == '#')path = 10;

                else path = 11;

                if (trie[cur][path] == 0)trie[cur][path] = ++cnt;

                cur = trie[cur][path];

                ++pass[cur];

            }

            ++end[cur];

        }

  

        int prefixNumber(string pre) {

            int cur = 1;

            for (auto& c : pre) {

                int path;

                if (isalnum(c))path = c - '0';

                else if (c == '#')path = 10;

                else path = 11;

                if (trie[cur][path] == 0)return 0;

                cur = trie[cur][path];

            }

            return pass[cur];

        }

  

    private:

        vector<vector<int>>trie;

        vector<int>pass;

        vector<int>end;

        int cnt;

    };

  

public:

    vector<int> countConsistentKeys(vector<vector<int> >& b, vector<vector<int> >& a) {

        Trie tree;

        vector<int>ans;

        for (auto& nums : a) {

            string temp;

            for (int i = 0; i < nums.size() - 1; i++) {

                temp.append(to_string(nums[i + 1] - nums[i]) + '#');

            }

            tree.insert(temp);

        }

        for (auto& nums : b) {

            string temp;

            for (int i = 0; i < nums.size() - 1; i++) {

                temp.append(to_string(nums[i + 1] - nums[i]) + '#');

            }

            ans.push_back(tree.prefixNumber(temp));

        }

        return ans;

    }

};
```