1. 在数学和计算机科学中是指<font color=red>在函数的定义中使用函数自身</font>的方法，再计算机科学中还额外指一种<font color=red>通过重复将问题分解为同类的二子问题而解决问题</font>的方法
2. 递归出口：<font color=red>找全边界条件（递归中止条件）</font>
3. 递归代码的理解：<font color=red>画递归调用图/递归树</font>
	- ```
	  int fib(int x){
		  if(x==0||x==1)return 1;
		  return fib(x-1)+fib(x-2);
	  }
	  ```
	- ![[Pasted image 20251109164646.png]]
	- 该层结果返回给上一层，不能跨层返回
4. 怎么写出一个递归函数
	- 确定递归函数是干啥的，写代码过程中，只考虑当前的问题怎么解决，<font  color=red>不分析</font>下层递归怎么展开
5. 递归函数用来解决这些类似的小问题的->确定递归函数能解决什么问题，在写递归函数时，当我们需要类似小问题的答案的时候，直接调用递归函数
6. [汉诺塔问题](https://leetcode.cn/problems/hanota-lcci/)
	- 思路：简化问题，把n个盘子从A移动到C，可以用B当媒介
		1. n=1时：直接将这个盘子从A拿出放到C
		2. n=2时：假设上面的盘子是甲，下面的盘子是乙：甲A->B 乙A->C 甲B->C
		3. n时：可以把上面n-1个盘子看成一个整体（一个盘子）甲，下面的第n个盘子是乙 ：甲A->B 乙A->C 甲B->C
		4. 此时，甲：A->B这个就是一个小问题，把n-1个盘子从A移动到B，可以用C当媒介--递归，甲：B->C这个也是一个小问题，把n-1个盘子从B移动到C，可以用A当媒介--递归
		5. ```
		   递归函数move：四个参数（盘子数量x，起点柱子s，终点柱子e，媒介柱子h）s->h->e{
		   if(x==1)x s->e,return;
			   1.x-1 s->e->h move(x-1,s,h,e);
			   2.x s->e
			   3.x-1 h->s->e move(x-1,h,e,s)
		   }
		   ```
7. 递归改成非递归的必要性：
	1. 工程上几乎一定要改，除非确定数据量再大递归也一定不深，归并排序、快速排序、线段树、很多平衡树
	2. 算法笔试或者比赛中（能通过就不改）
8. <font color=red>mast公式</font>
	1. 所有子问题规模相同的递归才能用master公式，`T(n)=a*T(n/b)+O(n^c),a,b,c都是常数`
	2. ```
	   log(b,a)<c,复杂度：O(n^c)
	   log(b,a)>c,复杂度：O(n^log(b,a))
	   log(b,a)==c,复杂度：O(n^c*logn)
	   ```
	3. `T(n)=2*T(n/2)+O(n*logn)`时间复杂度是`O(n*(logn)^2`证明过程较复杂，记住即可