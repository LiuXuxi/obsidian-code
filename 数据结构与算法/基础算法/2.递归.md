## 1.master公式

> Master 公式是**分析递归时间复杂度**的“终极武器”之一，  
> 它让我们**不用展开递归树、不用解递推式**，就能直接写出复杂度。

---

### 一、为什么需要 Master 公式？

在算法中，**递归**是最常见的设计方式之一，例如：

- 归并排序
    
- 快速排序
    
- 二分查找
    
- 分治 DP
    

它们的时间复杂度通常写成 **递推关系式**：

```
T(n) = a · T(n / b) + f(n)
```

如果没有 Master 公式，你通常需要：

- 画递归树
    
- 一层一层算
    
- 或者做复杂的数学推导
    

 **Master 公式的意义**：

> **把“复杂的递归分析”变成“套公式对比”**

---

### 二、Master 公式适用的前提（非常重要）

Master 公式**不是万能的**，它只适用于下面这种形式的递归：

```cpp
T(n) = a · T(n / b) + f(n)
```

**并且满足：**

- `a ≥ 1`（子问题个数）
    
- `b > 1`（问题规模缩小比例）
    
- 每个子问题规模 **相同**
    
- `f(n)` 是非递归部分的复杂度
    

**不适用于：**

- `T(n) = T(n-1) + n`
    
- `T(n) = T(n/2) + T(n/3)`
    
- 子问题规模不一致的递归
    

---

### 三、Master 公式的核心思想

#### 1️. 先定义一个“基准函数”

```
n^{log_b(a)}
```

这是**递归部分的复杂度**，表示：

> 所有子问题在“同一层”累积起来的规模

---

#### 2️. 把 `f(n)` 和 `n^{log_b(a)}` 比较

这一步是 **Master 公式的灵魂**。

---

### 四、Master 公式的三种情况（必须背）

设：

```cpp
T(n) = a · T(n / b) + f(n)
```

定义：

```cpp
p = log_b(a)
```

---

#### 情况一：`f(n)` 比递归部分 **小**

```cpp
f(n) = O(n^{p - ε})   (ε > 0)
```

 **递归部分主导**

```cpp
T(n) = Θ(n^p)
```

**典型例子**

```cpp
T(n) = 2T(n/2) + O(n)
```

- `a = 2`
    
- `b = 2`
    
- `p = log₂2 = 1`
    
- `f(n) = n`
    

属于下一种（边界情况）

---

#### 情况二：`f(n)` 和递归部分 **同阶**

```cpp
f(n) = Θ(n^p · log^k n)
```

**多一个 log**

```cpp
T(n) = Θ(n^p · log^{k+1} n)
```

 **典型例子：归并排序**

```cpp
T(n) = 2T(n/2) + O(n)
```

- `p = 1`
    
- `f(n) = n = Θ(n^1 · log^0 n)`
    

```cpp
T(n) = Θ(n log n)
```

---

#### 情况三：`f(n)` 比递归部分 **大**

```cpp
f(n) = Ω(n^{p + ε})   (ε > 0)
```

并且满足**正则条件**：

```cpp
a · f(n / b) ≤ c · f(n)   (c < 1)
```

 **非递归部分主导**

```cpp
T(n) = Θ(f(n))
```

 **典型例子**

```cpp
T(n) = 2T(n/2) + n^2
```

- `p = 1`
    
- `f(n) = n^2`
    

```cpp
T(n) = Θ(n^2)
```

---

### 五、如何快速使用 Master 公式（实战步骤）

#### Step 1：写成标准形式

```cpp
T(n) = a · T(n / b) + f(n)
```

---

#### Step 2：算 `p = log_b(a)`

---

#### Step 3：比较 `f(n)` 和 `n^p`

- 小 → 情况一
    
- 相等 → 情况二
    
- 大 → 情况三（注意正则条件）
    

---

#### Step 4：直接写答案

---

### 六、经典例题速览

#### 例 1：二分查找

```cpp
T(n) = T(n/2) + O(1)
```

- `a = 1`
    
- `b = 2`
    
- `p = 0`
    
- `f(n) = O(1)`
    

 情况二

```
T(n) = Θ(log n)
```

---

#### 例 2：归并排序

```
T(n) = 2T(n/2) + O(n)
```

情况二

```
T(n) = Θ(n log n)
```

---

#### 例 3：递归求数组最大值

```
T(n) = 2T(n/2) + O(1)
```

- `p = 1`
    
- `f(n) = O(1)`
    

 情况一

```
T(n) = Θ(n)
```

---

### 七、Master 公式的常见坑（一定要注意）

#### 坑 1：递归规模不是 `n / b`

```
T(n) = T(n - 1) + n
```

 **不能用 Master 公式**

---

####  坑 2：多个不同规模子问题

```
T(n) = T(n/2) + T(n/3) + n
```

 **不能用 Master 公式**

---

#### 坑 3：忘了正则条件（情况三）

```
a · f(n/b) ≤ c · f(n)
```

如果不满足，结论可能是错的。

---

### 八、Master 公式 vs 递归树

|方法|优点|缺点|
|---|---|---|
|递归树|直观|慢、容易算错|
|Master 公式|快、标准|有适用范围|

 **推荐策略**：

> 先用 Master 公式  
> 不适用 → 再画递归树

---

### 九、一句话总结

> **Master 公式的本质，是比较“递归部分”和“非递归部分”谁更强。**  
> 谁主导，时间复杂度就由谁决定。


---

# 2. 带路径的递归（回溯算法）

回溯算法（Backtracking）本质上是在一棵隐式的决策树（状态空间树）上进行深度优先搜索（DFS）。其核心公式为：**做选择 -> 递归 -> 撤销选择（回溯）**。

## 模型一：组合问题（Elements Combination）

**特征**：$N$ 个数里面按一定规则找出 $K$ 个数的集合。不强调顺序（[1,2] 和 [2,1] 是同一个集合）。

### 1.1 元素无重不可复选

- **核心**：使用 `start` 变量控制搜索起始位置，防止跳回前面。
    
- **好题推荐**：[77. 组合](https://leetcode.cn/problems/combinations/ "null")、[216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/ "null")
    

### 1.2 元素有重不可复选（需去重）

- **核心逻辑**：**排序 + 树层去重**。
    
- **案例：**[**90. 子集 II**](https://leetcode.cn/problems/subsets-ii/ "null")
    

```cpp
class Solution {
public:
    vector<vector<int>> res;
    void backtrack(vector<int>& nums, int start, vector<int>& track) {
        res.push_back(track); // 记录路径
        for (int i = start; i < nums.size(); i++) {
            // 树层去重：如果发现当前元素与前一个相同，且前一个在当前层没被选
            if (i > start && nums[i] == nums[i - 1]) continue;

            track.push_back(nums[i]);
            backtrack(nums, i + 1, track);
            track.pop_back(); // 回溯
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end()); // 必须排序
        vector<int> track;
        backtrack(nums, 0, track);
        return res;
    }
};
```

### 1.3 元素无重可复选

- **核心**：递归时传递 `i` 而非 `i + 1`。
    
- **好题推荐**：[39. 组合总和](https://leetcode.cn/problems/combination-sum/ "null")
    

## 模型二：排列问题（Permutations）

**特征**：强调顺序（[1,2] 和 [2,1] 是两个不同的路径）。

### 2.1 元素无重不可复选

- **核心**：利用 **交换法** 或 `used` 数组记录已使用的元素。
    
- **案例：**[**46. 全排列**](https://leetcode.cn/problems/permutations/ "null")
    

```cpp
class Solution {
public:
    vector<vector<int>> ans;
    void traceback(vector<int>& nums, int start) {
        if (start == nums.size()) {
            ans.push_back(nums);
            return;
        }
        for (int j = start; j < nums.size(); j++) {
            swap(nums[j], nums[start]); // 交换，确定当前位置的元素
            traceback(nums, start + 1);
            swap(nums[j], nums[start]); // 还原
        }
    }
};
```

### 2.2 元素有重不可复选（需去重）

- **核心逻辑**：**每层局部哈希去重**。
    
- **案例：**[**47. 全排列 II**](https://leetcode.cn/problems/permutations-ii/ "null")
    

```cpp
class Solution {
public:
    vector<vector<int>> ans;
    void traceback(vector<int>& nums, int start) {
        if (start == nums.size()) {
            ans.push_back(nums);
            return;
        }
        unordered_set<int> hash; // 仅对当前层去重
        for (int j = start; j < nums.size(); j++) {
            if (hash.find(nums[j]) != hash.end()) continue;
            hash.insert(nums[j]);
            
            swap(nums[j], nums[start]);
            traceback(nums, start + 1);
            swap(nums[j], nums[start]);
        }
    }
};
```

## 模型三：切割/划分问题（Partitioning）

**特征**：给定一个字符串或数组，要求将其切割成满足特定条件的子块。

- **核心**：切割位置即为组合问题中的 `start`，判断当前切割出的子串是否合法。
    
- **好题推荐**：
    
    - [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/ "null")（经典）
        
    - [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/ "null")（约束较多）
        

## 模型四：搜索空间受限的路径问题（Grid/Board）

**特征**：在二维矩阵（棋盘）上移动，每一步受限制。

- **核心**：方向数组（上下左右）+ 访问标记。
    
- **好题推荐**：
    
    - [79. 单词搜索](https://leetcode.cn/problems/word-search/ "null")
        
    - [[11.位运算#N皇后问题]]（回溯的天花板题目之一）
        

## 模型五：博弈/选择优化（Game Strategy）

**特征**：在每一回合根据路径信息做出最优选择。

- **好题推荐**：
    
    - [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/ "null")
        
    - [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/ "null")
        


# 3.函数调用栈的应用

## 1.递归实现逆序栈

```cpp
#include<iostream>
#include<stack>
#include<vector>
using namespace std;

int bottom(stack<int>& s) {
    int num = s.top();
    s.pop();
    if (s.empty())return num;
    int last = bottom(s);
    s.push(num);
    return last;
}


void reverse(stack<int>& s) {
    if (s.empty()) {
        return;
    }
    int num = bottom(s);
    reverse(s);
    s.push(num);
}


int main() {
    vector<int>nums{ 1,2,3,4,5 };
    stack<int>s;
    for (auto& num : nums)s.push(num);
    while (!s.empty()) {
        int num = s.top();
        cout << num << " ";
        s.pop();
    }
    cout << endl<<"==============" << endl;
    for (auto& num : nums)s.push(num);
    reverse(s);
    while (!s.empty()) {
        int num = s.top();
        cout << num << " ";
        s.pop();
    }
    return 0;
}

```


## 2.递归实现排序栈

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
#include <climits>
#include <ctime>
#include <cstdlib>

using namespace std;

   // 计算栈深度
int deep(stack<int>& s) {
    if (s.empty()) return 0;
    int num = s.top(); s.pop();
    int depth = deep(s) + 1;
    s.push(num);
    return depth;
}

// 在前 depth 个元素中找最大值
int getMax(stack<int>& s, int depth) {
    if (depth == 0) return INT_MIN;
    int num = s.top(); s.pop();
    int ans = max(num, getMax(s, depth - 1));
    s.push(num);
    return ans;
}

// 统计最大值出现次数
int times(stack<int>& s, int depth, int m) {
    if (depth == 0) return 0;
    int num = s.top(); s.pop();
    int cnt = (num == m ? 1 : 0) + times(s, depth - 1, m);
    s.push(num);
    return cnt;
}

// 删除最大值，并把 k 个最大值压到底部
void down(stack<int>& s, int depth, int m, int k) {
    if (depth == 0) {
        while (k--) s.push(m);
        return;
    }
    int num = s.top(); s.pop();
    down(s, depth - 1, m, k);
    if (num != m) s.push(num);
}

// 栈排序（递归版）
void sortStack(stack<int>& s) {
    int depth = deep(s);
    while (depth > 0) {
        int mx = getMax(s, depth);
        int k = times(s, depth, mx);
        down(s, depth, mx, k);
        depth -= k;
    }
}

   // 暴力正确解：借助 vector 排序
void bruteSortStack(stack<int>& s) {
    vector<int> v;
    while (!s.empty()) {
        v.push_back(s.top());
        s.pop();
    }
    sort(v.begin(), v.end()); // 升序

    // 保证：栈顶最小
    for (int i = v.size() - 1; i >= 0; i--) {
        s.push(v[i]);
    }
}

// 判断两个栈是否完全一致
bool isSame(stack<int> s1, stack<int> s2) {
    while (!s1.empty() && !s2.empty()) {
        if (s1.top() != s2.top()) return false;
        s1.pop();
        s2.pop();
    }
    return s1.empty() && s2.empty();
}

// 生成随机栈
stack<int> randomStack(int maxSize, int maxValue) {
    stack<int> s;
    int size = rand() % (maxSize + 1);
    for (int i = 0; i < size; i++) {
        int val = rand() % (maxValue * 2 + 1) - maxValue;
        s.push(val);
    }
    return s;
}

// 对数器主函数
void testSortStack() {
    srand((unsigned)time(nullptr));

    int testTimes = 10000;
    int maxSize = 20;
    int maxValue = 50;

    for (int i = 0; i < testTimes; i++) {
        stack<int> s1 = randomStack(maxSize, maxValue);
        stack<int> s2 = s1;

        sortStack(s1);       // 你的递归算法
        bruteSortStack(s2);  // 暴力算法

        if (!isSame(s1, s2)) {
            cout << "出错了！" << endl;
            cout << "期望结果(top->bottom): ";
            while (!s2.empty()) {
                cout << s2.top() << " ";
                s2.pop();
            }
            cout << endl;
            return;
        }
    }

    cout << "全部测试通过！" << endl;
}

int main() {
    testSortStack();
    return 0;
}

```

## 4.嵌套函数