## 1.masterå…¬å¼

## Master å…¬å¼ï¼ˆMaster Theoremï¼‰å­¦ä¹ ç¬”è®°

> Master å…¬å¼æ˜¯**åˆ†æé€’å½’æ—¶é—´å¤æ‚åº¦**çš„â€œç»ˆææ­¦å™¨â€ä¹‹ä¸€ï¼Œ  
> å®ƒè®©æˆ‘ä»¬**ä¸ç”¨å±•å¼€é€’å½’æ ‘ã€ä¸ç”¨è§£é€’æ¨å¼**ï¼Œå°±èƒ½ç›´æ¥å†™å‡ºå¤æ‚åº¦ã€‚

---

### ä¸€ã€ä¸ºä»€ä¹ˆéœ€è¦ Master å…¬å¼ï¼Ÿ

åœ¨ç®—æ³•ä¸­ï¼Œ**é€’å½’**æ˜¯æœ€å¸¸è§çš„è®¾è®¡æ–¹å¼ä¹‹ä¸€ï¼Œä¾‹å¦‚ï¼š

- å½’å¹¶æ’åº
    
- å¿«é€Ÿæ’åº
    
- äºŒåˆ†æŸ¥æ‰¾
    
- åˆ†æ²» DP
    

å®ƒä»¬çš„æ—¶é—´å¤æ‚åº¦é€šå¸¸å†™æˆ **é€’æ¨å…³ç³»å¼**ï¼š

```
T(n) = a Â· T(n / b) + f(n)
```

å¦‚æœæ²¡æœ‰ Master å…¬å¼ï¼Œä½ é€šå¸¸éœ€è¦ï¼š

- ç”»é€’å½’æ ‘
    
- ä¸€å±‚ä¸€å±‚ç®—
    
- æˆ–è€…åšå¤æ‚çš„æ•°å­¦æ¨å¯¼
    

 **Master å…¬å¼çš„æ„ä¹‰**ï¼š

> **æŠŠâ€œå¤æ‚çš„é€’å½’åˆ†æâ€å˜æˆâ€œå¥—å…¬å¼å¯¹æ¯”â€**

---

### äºŒã€Master å…¬å¼é€‚ç”¨çš„å‰æï¼ˆéå¸¸é‡è¦ï¼‰

Master å…¬å¼**ä¸æ˜¯ä¸‡èƒ½çš„**ï¼Œå®ƒåªé€‚ç”¨äºä¸‹é¢è¿™ç§å½¢å¼çš„é€’å½’ï¼š

```cpp
T(n) = a Â· T(n / b) + f(n)
```

**å¹¶ä¸”æ»¡è¶³ï¼š**

- `a â‰¥ 1`ï¼ˆå­é—®é¢˜ä¸ªæ•°ï¼‰
    
- `b > 1`ï¼ˆé—®é¢˜è§„æ¨¡ç¼©å°æ¯”ä¾‹ï¼‰
    
- æ¯ä¸ªå­é—®é¢˜è§„æ¨¡ **ç›¸åŒ**
    
- `f(n)` æ˜¯éé€’å½’éƒ¨åˆ†çš„å¤æ‚åº¦
    

**ä¸é€‚ç”¨äºï¼š**

- `T(n) = T(n-1) + n`
    
- `T(n) = T(n/2) + T(n/3)`
    
- å­é—®é¢˜è§„æ¨¡ä¸ä¸€è‡´çš„é€’å½’
    

---

### ä¸‰ã€Master å…¬å¼çš„æ ¸å¿ƒæ€æƒ³

#### 1ï¸. å…ˆå®šä¹‰ä¸€ä¸ªâ€œåŸºå‡†å‡½æ•°â€

```
n^{log_b(a)}
```

è¿™æ˜¯**é€’å½’éƒ¨åˆ†çš„å¤æ‚åº¦**ï¼Œè¡¨ç¤ºï¼š

> æ‰€æœ‰å­é—®é¢˜åœ¨â€œåŒä¸€å±‚â€ç´¯ç§¯èµ·æ¥çš„è§„æ¨¡

---

#### 2ï¸. æŠŠ `f(n)` å’Œ `n^{log_b(a)}` æ¯”è¾ƒ

è¿™ä¸€æ­¥æ˜¯ **Master å…¬å¼çš„çµé­‚**ã€‚

---

### å››ã€Master å…¬å¼çš„ä¸‰ç§æƒ…å†µï¼ˆå¿…é¡»èƒŒï¼‰

è®¾ï¼š

```cpp
T(n) = a Â· T(n / b) + f(n)
```

å®šä¹‰ï¼š

```cpp
p = log_b(a)
```

---

#### æƒ…å†µä¸€ï¼š`f(n)` æ¯”é€’å½’éƒ¨åˆ† **å°**

```cpp
f(n) = O(n^{p - Îµ})   (Îµ > 0)
```

 **é€’å½’éƒ¨åˆ†ä¸»å¯¼**

```cpp
T(n) = Î˜(n^p)
```

**å…¸å‹ä¾‹å­**

```cpp
T(n) = 2T(n/2) + O(n)
```

- `a = 2`
    
- `b = 2`
    
- `p = logâ‚‚2 = 1`
    
- `f(n) = n`
    

å±äºä¸‹ä¸€ç§ï¼ˆè¾¹ç•Œæƒ…å†µï¼‰

---

#### æƒ…å†µäºŒï¼š`f(n)` å’Œé€’å½’éƒ¨åˆ† **åŒé˜¶**

```cpp
f(n) = Î˜(n^p Â· log^k n)
```

**å¤šä¸€ä¸ª log**

```cpp
T(n) = Î˜(n^p Â· log^{k+1} n)
```

 **å…¸å‹ä¾‹å­ï¼šå½’å¹¶æ’åº**

```cpp
T(n) = 2T(n/2) + O(n)
```

- `p = 1`
    
- `f(n) = n = Î˜(n^1 Â· log^0 n)`
    

```cpp
T(n) = Î˜(n log n)
```

---

#### æƒ…å†µä¸‰ï¼š`f(n)` æ¯”é€’å½’éƒ¨åˆ† **å¤§**

```cpp
f(n) = Î©(n^{p + Îµ})   (Îµ > 0)
```

å¹¶ä¸”æ»¡è¶³**æ­£åˆ™æ¡ä»¶**ï¼š

```cpp
a Â· f(n / b) â‰¤ c Â· f(n)   (c < 1)
```

 **éé€’å½’éƒ¨åˆ†ä¸»å¯¼**

```cpp
T(n) = Î˜(f(n))
```

 **å…¸å‹ä¾‹å­**

```cpp
T(n) = 2T(n/2) + n^2
```

- `p = 1`
    
- `f(n) = n^2`
    

```cpp
T(n) = Î˜(n^2)
```

---

### äº”ã€å¦‚ä½•å¿«é€Ÿä½¿ç”¨ Master å…¬å¼ï¼ˆå®æˆ˜æ­¥éª¤ï¼‰

#### Step 1ï¼šå†™æˆæ ‡å‡†å½¢å¼

```cpp
T(n) = a Â· T(n / b) + f(n)
```

---

#### Step 2ï¼šç®— `p = log_b(a)`

---

#### Step 3ï¼šæ¯”è¾ƒ `f(n)` å’Œ `n^p`

- å° â†’ æƒ…å†µä¸€
    
- ç›¸ç­‰ â†’ æƒ…å†µäºŒ
    
- å¤§ â†’ æƒ…å†µä¸‰ï¼ˆæ³¨æ„æ­£åˆ™æ¡ä»¶ï¼‰
    

---

#### Step 4ï¼šç›´æ¥å†™ç­”æ¡ˆ

---

### å…­ã€ç»å…¸ä¾‹é¢˜é€Ÿè§ˆ

#### ä¾‹ 1ï¼šäºŒåˆ†æŸ¥æ‰¾

```cpp
T(n) = T(n/2) + O(1)
```

- `a = 1`
    
- `b = 2`
    
- `p = 0`
    
- `f(n) = O(1)`
    

 æƒ…å†µäºŒ

```
T(n) = Î˜(log n)
```

---

#### ä¾‹ 2ï¼šå½’å¹¶æ’åº

```
T(n) = 2T(n/2) + O(n)
```

ğŸ‘‰ æƒ…å†µäºŒ

```
T(n) = Î˜(n log n)
```

---

### ä¾‹ 3ï¼šé€’å½’æ±‚æ•°ç»„æœ€å¤§å€¼

```
T(n) = 2T(n/2) + O(1)
```

- `p = 1`
    
- `f(n) = O(1)`
    

ğŸ‘‰ æƒ…å†µä¸€

```
T(n) = Î˜(n)
```

---

## ä¸ƒã€Master å…¬å¼çš„å¸¸è§å‘ï¼ˆä¸€å®šè¦æ³¨æ„ï¼‰

### âŒ å‘ 1ï¼šé€’å½’è§„æ¨¡ä¸æ˜¯ `n / b`

```
T(n) = T(n - 1) + n
```

ğŸ‘‰ **ä¸èƒ½ç”¨ Master å…¬å¼**

---

### âŒ å‘ 2ï¼šå¤šä¸ªä¸åŒè§„æ¨¡å­é—®é¢˜

```
T(n) = T(n/2) + T(n/3) + n
```

ğŸ‘‰ **ä¸èƒ½ç”¨ Master å…¬å¼**

---

### âŒ å‘ 3ï¼šå¿˜äº†æ­£åˆ™æ¡ä»¶ï¼ˆæƒ…å†µä¸‰ï¼‰

```
a Â· f(n/b) â‰¤ c Â· f(n)
```

å¦‚æœä¸æ»¡è¶³ï¼Œç»“è®ºå¯èƒ½æ˜¯é”™çš„ã€‚

---

## å…«ã€Master å…¬å¼ vs é€’å½’æ ‘

|æ–¹æ³•|ä¼˜ç‚¹|ç¼ºç‚¹|
|---|---|---|
|é€’å½’æ ‘|ç›´è§‚|æ…¢ã€å®¹æ˜“ç®—é”™|
|Master å…¬å¼|å¿«ã€æ ‡å‡†|æœ‰é€‚ç”¨èŒƒå›´|

ğŸ‘‰ **æ¨èç­–ç•¥**ï¼š

> å…ˆç”¨ Master å…¬å¼  
> ä¸é€‚ç”¨ â†’ å†ç”»é€’å½’æ ‘

---

## ä¹ã€ä¸€å¥è¯æ€»ç»“ï¼ˆé€‚åˆæ”¾åœ¨åšå®¢ç»“å°¾ï¼‰

> **Master å…¬å¼çš„æœ¬è´¨ï¼Œæ˜¯æ¯”è¾ƒâ€œé€’å½’éƒ¨åˆ†â€å’Œâ€œéé€’å½’éƒ¨åˆ†â€è°æ›´å¼ºã€‚**  
> è°ä¸»å¯¼ï¼Œæ—¶é—´å¤æ‚åº¦å°±ç”±è°å†³å®šã€‚

---

## åã€ä½ ç°åœ¨å¯ä»¥æ€ä¹ˆç»§ç»­å­¦ï¼Ÿ

å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥å¸®ä½ ä¸‹ä¸€æ­¥ï¼š

- ğŸ”¥ æŠŠ **é€’å½’æ ‘ â†” Master å…¬å¼** ä¸€ä¸€å¯¹åº”
    
- ğŸ”¥ æ€»ç»“ **å“ªäº›é€’å½’ä¸€çœ¼å°±èƒ½åˆ¤æ–­å¤æ‚åº¦**
    
- ğŸ”¥ è®² **Master å…¬å¼å¤±æ•ˆæ—¶è¯¥æ€ä¹ˆåˆ†æ**
    

ä½ ç°åœ¨è¿™ä¸ªé˜¶æ®µï¼Œ**å†™è¿™ç§åšå®¢éå¸¸åˆé€‚**ï¼Œè€Œä¸”èƒ½æ˜æ˜¾æ‹‰å¼€å’Œâ€œåªåˆ·é¢˜â€çš„å·®è·ã€‚

---


[90. å­é›† II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/subsets-ii/)

```cpp
class Solution {
public:
    vector<vector<int>> res;

    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        vector<int> track;
        backtrack(nums,0,track);
        return res;
    }

    void backtrack(vector<int>& nums, int start, vector<int>& track){
        res.push_back(track);

        for(int i = start; i < nums.size(); i++){
            if (i > start && nums[i] == nums[i - 1]){
                continue;
            }

            track.push_back(nums[i]);
            backtrack(nums, i + 1, track);
            track.pop_back();  
        }
    }
};
```

[46. å…¨æ’åˆ— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/permutations/)

```cpp
class Solution {
public:

Â  Â  vector<vector<int>>ans;

Â  Â  vector<vector<int>> permute(vector<int>& nums) {
Â  Â  Â  Â  traceback(nums, 0);
Â  Â  Â  Â  return ans;
Â  Â  }
  
Â  Â  void traceback(vector<int>& nums, int start) {
Â  Â  Â  Â  if (start == nums.size()) {
Â  Â  Â  Â  Â  Â  ans.push_back(nums);
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â  for (int j = start; j < nums.size(); j++) {

Â  Â  Â  Â  Â  Â  swap(nums[j],nums[start]);

Â  Â  Â  Â  Â  Â  traceback(nums, start + 1);

Â  Â  Â  Â  Â  Â  swap(nums[j], nums[start]);

Â  Â  Â  Â  }
Â  Â  }
};
```

[47. å…¨æ’åˆ— II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/permutations-ii/)

```cpp
class Solution {

public:
Â  Â  vector<vector<int>>ans;
  
Â  Â  vector<vector<int>> permuteUnique(vector<int>& nums) {
Â  Â  Â  Â  traceback(nums, 0);
Â  Â  Â  Â  return ans;
Â  Â  }

Â  Â  void traceback(vector<int>& nums, int start) {
Â  Â  Â  Â  if (start == nums.size()) {
Â  Â  Â  Â  Â  Â  ans.push_back(nums);
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â  unordered_set<int>hash;
Â  Â  Â  Â  for (int j = start; j < nums.size(); j++) {
Â  Â  Â  Â  Â  Â  if (!hash.contains(nums[j])) {
Â  Â  Â  Â  Â  Â  Â  Â  hash.insert(nums[j]);
Â  Â  Â  Â  Â  Â  Â  Â  swap(nums[j], nums[start]);
Â  Â  Â  Â  Â  Â  Â  Â  traceback(nums, start + 1);
Â  Â  Â  Â  Â  Â  Â  Â  swap(nums[j], nums[start]);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
};
```

é€’å½’å®ç°é€†åºæ ˆ

```cpp
#include<iostream>
#include<stack>
#include<vector>
using namespace std;

int bottom(stack<int>& s) {
    int num = s.top();
    s.pop();
    if (s.empty())return num;
    int last = bottom(s);
    s.push(num);
    return last;
}


void reverse(stack<int>& s) {
    if (s.empty()) {
        return;
    }
    int num = bottom(s);
    reverse(s);
    s.push(num);
}


int main() {
    vector<int>nums{ 1,2,3,4,5 };
    stack<int>s;
    for (auto& num : nums)s.push(num);
    while (!s.empty()) {
        int num = s.top();
        cout << num << " ";
        s.pop();
    }
    cout << endl<<"==============" << endl;
    for (auto& num : nums)s.push(num);
    reverse(s);
    while (!s.empty()) {
        int num = s.top();
        cout << num << " ";
        s.pop();
    }
    return 0;
}

```


é€’å½’å®ç°æ’åºæ ˆ

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
#include <climits>
#include <ctime>
#include <cstdlib>

using namespace std;

   // è®¡ç®—æ ˆæ·±åº¦
int deep(stack<int>& s) {
    if (s.empty()) return 0;
    int num = s.top(); s.pop();
    int depth = deep(s) + 1;
    s.push(num);
    return depth;
}

// åœ¨å‰ depth ä¸ªå…ƒç´ ä¸­æ‰¾æœ€å¤§å€¼
int getMax(stack<int>& s, int depth) {
    if (depth == 0) return INT_MIN;
    int num = s.top(); s.pop();
    int ans = max(num, getMax(s, depth - 1));
    s.push(num);
    return ans;
}

// ç»Ÿè®¡æœ€å¤§å€¼å‡ºç°æ¬¡æ•°
int times(stack<int>& s, int depth, int m) {
    if (depth == 0) return 0;
    int num = s.top(); s.pop();
    int cnt = (num == m ? 1 : 0) + times(s, depth - 1, m);
    s.push(num);
    return cnt;
}

// åˆ é™¤æœ€å¤§å€¼ï¼Œå¹¶æŠŠ k ä¸ªæœ€å¤§å€¼å‹åˆ°åº•éƒ¨
void down(stack<int>& s, int depth, int m, int k) {
    if (depth == 0) {
        while (k--) s.push(m);
        return;
    }
    int num = s.top(); s.pop();
    down(s, depth - 1, m, k);
    if (num != m) s.push(num);
}

// æ ˆæ’åºï¼ˆé€’å½’ç‰ˆï¼‰
void sortStack(stack<int>& s) {
    int depth = deep(s);
    while (depth > 0) {
        int mx = getMax(s, depth);
        int k = times(s, depth, mx);
        down(s, depth, mx, k);
        depth -= k;
    }
}

   // æš´åŠ›æ­£ç¡®è§£ï¼šå€ŸåŠ© vector æ’åº
void bruteSortStack(stack<int>& s) {
    vector<int> v;
    while (!s.empty()) {
        v.push_back(s.top());
        s.pop();
    }
    sort(v.begin(), v.end()); // å‡åº

    // ä¿è¯ï¼šæ ˆé¡¶æœ€å°
    for (int i = v.size() - 1; i >= 0; i--) {
        s.push(v[i]);
    }
}

// åˆ¤æ–­ä¸¤ä¸ªæ ˆæ˜¯å¦å®Œå…¨ä¸€è‡´
bool isSame(stack<int> s1, stack<int> s2) {
    while (!s1.empty() && !s2.empty()) {
        if (s1.top() != s2.top()) return false;
        s1.pop();
        s2.pop();
    }
    return s1.empty() && s2.empty();
}

// ç”Ÿæˆéšæœºæ ˆ
stack<int> randomStack(int maxSize, int maxValue) {
    stack<int> s;
    int size = rand() % (maxSize + 1);
    for (int i = 0; i < size; i++) {
        int val = rand() % (maxValue * 2 + 1) - maxValue;
        s.push(val);
    }
    return s;
}

// å¯¹æ•°å™¨ä¸»å‡½æ•°
void testSortStack() {
    srand((unsigned)time(nullptr));

    int testTimes = 10000;
    int maxSize = 20;
    int maxValue = 50;

    for (int i = 0; i < testTimes; i++) {
        stack<int> s1 = randomStack(maxSize, maxValue);
        stack<int> s2 = s1;

        sortStack(s1);       // ä½ çš„é€’å½’ç®—æ³•
        bruteSortStack(s2);  // æš´åŠ›ç®—æ³•

        if (!isSame(s1, s2)) {
            cout << "å‡ºé”™äº†ï¼" << endl;
            cout << "æœŸæœ›ç»“æœ(top->bottom): ";
            while (!s2.empty()) {
                cout << s2.top() << " ";
                s2.pop();
            }
            cout << endl;
            return;
        }
    }

    cout << "å…¨éƒ¨æµ‹è¯•é€šè¿‡ï¼" << endl;
}

int main() {
    testSortStack();
    return 0;
}

```