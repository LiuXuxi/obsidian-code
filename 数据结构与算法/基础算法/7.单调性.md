>[!ABSTRACT]
单调性是指在一个特定区间内，某个量或函数始终保持==递增==或==递减==的趋势。在算法中，我们关注的是==解空间==或==操作系统==的单调性。它是证明双指针、二分查找等算法可以从$O(N^2)$优化到$O(logN)$的==核心逻辑==。

# 为什么单调性是O(N)优化的关键？

当一个问题的解空间具有带调性时，他就赋予了算法==确定的方向感==，从而实现高效的“剪枝”：
- **确定唯一方向：** 如果当前的结果不满足目标（例如，和太大了），由于单调性的存在，我们能够==确定地知道==需要移动哪个指针以及朝哪个方向移动，才能让结果向目标靠近。==无需回溯或尝试其他方向。==
- **消除重复搜素：** 这种确定性的单向移动，保证了指针（例如双指针中的L和R）永远不会后退，每个元素最多只被访问一次，从而将二次遍历($O(N^2)$)压缩为线性遍历($O(N)$)。
- **有序是前提：** 单调性通常建立在==输入数据有序==（如排序数组），或==维护结构有序==（如单调队列/栈）的基础上

# 数学定义：单调性的四种类型


| 严格递增                                                     | 非严格递减/增函数                                                                | 严格递减                                                 | 非严格递增/减函数                                        |
| -------------------------------------------------------- | ------------------------------------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------ |
| 若对于区间I内任意$x_1<x_2$,总有$f(x_1)<f(x_1)$成立。常用于需要精确、无重复递增的场景。 | 若对于区间I内任意$x_1<x_2$,总有$f(x_1)\leqslant f(x_1)$成立。允许函数值保持不变，例如数组去重中慢指针的位置。 | 若对于区间I内任意$x_1<x_2$,总有$f(x_1)>f(x_1)$成立。常用于反序或逆序排列的场景 | 若对于区间I内任意$x_1<x_2$,总有$f(x_1)\geqslant f(x_1)$成立。 |

# 实例：单调性驱动双指针移动

以==对撞双指针==解决有序数组A中的“两数之和”问题为例，其核心在于==A\[L]+A\[R]$的和==相对于L和R的移动具有单调性

 > [!NOTE] 
> | <div style="min-width:150px">当前状态</div> | <div style="min-width:200px">期望变化</div> | <div style="min-width:250px">唯一正确操作</div> | 
> | :--- | :--- | :--- | 
> | A\[L]+A\[R]>T(和太大) | 减小和 | ==必须==移动R向左（R--）。因为A\[L]是当前能提供的最小增量，移动L只会使和更大 |
> | A\[L]+A\[R]<T(和太小) | 增大和 | ==必须==移动L向左（L++）。因为A\[R]是当前能提供的最大减量，移动R只会使和更小 |

>[!ABSTRACT]
>**结论：** 正是数组A本身的递增单调性，使得对和$f(L,R)=A[L]+A[R]$的调整方向成为==确定性==的选择，从而消除了$O(N^2)$中的内存循环。