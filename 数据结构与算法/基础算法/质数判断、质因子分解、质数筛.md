
![[Pasted image 20260227143813.png]]


![[Pasted image 20260227143956.png]]


![[Pasted image 20260227144439.png]]

# 质因子分解

> **将一个合数（大于1的整数）分解成一系列质数相乘的过程**

```cpp
class Solution {

public:

    int countPrimes(int n) {

        if(n<=1)return 0;

        int ans=0;

        for(int i=2;i*i<=n;i++){

            if(n%i==0){

                ++ans;

                while(n%i==0)n/=i;

            }

        }

        if(n>1)++ans;

        return ans;

    }

};
```

[952. 按公因数计算最大组件大小 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-component-size-by-common-factor/submissions/700948791/)
```cpp
class Solution {

public:

    vector<int>factor;

    vector<int>father;

    vector<int>size;

  

    void build(int n){

        factor.resize(n,-1);

        father.resize(n,0);

        for(int i=0;i<n;i++)father[i]=i;

        size.resize(n,1);

    }

  

    int find(int x){

        if(father[x]!=x)father[x]=find(father[x]);

        return father[x];

    }

  

    void Union(int a,int b){

        int fa=find(a),fb=find(b);

        if(fa!=fb){

            father[fa]=fb;

            size[fb]+=size[fa];

        }

    }

  

    int largestComponentSize(vector<int>& nums) {

        int n=nums.size();

        int s=0;

        for(auto&num:nums)s=max(s,num);

        build(s+1);

        for(int i=0;i<n;i++){

            int x=nums[i];

            for(int j=2;j*j<=x;j++){

                if(x%j==0){

                    if(factor[j]==-1)factor[j]=i;

                    else Union(factor[j],i);

                    while(x%j==0)x/=j;

                }

            }

            if(x>1){

                if(factor[x]==-1)factor[x]=i;

                else Union(factor[x],i);

            }

        }

        int ans=0;

        for(int i=0;i<n;i++)ans=max(ans,size[i]);

        return ans;

    }

};
```

# 质数筛

![[Pasted image 20260227153716.png]]

   