
![[Pasted image 20260227143813.png]]

# 质数判断

## 小整数判断质数

![[Pasted image 20260227143956.png]]

## 大整数判断质数
![[Pasted image 20260227144439.png]]

```cpp
#include <bits/stdc++.h>

using namespace std;

  

typedef __int128 ll;

typedef pair<int, int> pii;

  

template<typename T> inline T read() {

    T x = 0, f = 1; char ch = 0;

    for(; !isdigit(ch); ch = getchar()) if(ch == '-') f = -1;

    for(; isdigit(ch); ch = getchar()) x = (x << 3) + (x << 1) + (ch - '0');

    return x * f;

}

  

template<typename T> inline void write(T x) {

    if(x < 0) putchar('-'), x = -x;

    if(x > 9) write(x / 10);

    putchar(x % 10 + '0');

}

  

template<typename T> inline void print(T x, char ed = '\n') {

    write(x), putchar(ed);

}

  

ll t, n;

  

ll qpow(ll a, ll b, ll mod) {

    ll ret = 1;

    while(b) {

        if(b & 1) ret = (ret * a) % mod;

        a = (a * a) % mod;

        b >>= 1;

    }

    return ret % mod;

}

  

vector<ll> p = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};

  

bool miller_rabin(ll n) {

    if(n < 3 || n % 2 == 0) return n == 2;

    ll u = n - 1, t = 0;

    while(u % 2 == 0) u /= 2, ++ t;

    for(auto a : p) {

        if(n == a) return 1;

        if(n % a == 0) return 0;

        ll v = qpow(a, u, n);

        if(v == 1) continue;

        ll s = 1;

        for(; s <= t; ++ s) {

            if(v == n - 1) break;

            v = v * v % n;

        }

        if(s > t) return 0;

    }

    return 1;

}

  

int main() {

    t = read<ll>();

    while(t --) {

        n = read<ll>();

        if(miller_rabin(n)) puts("Yes");

        else puts("No");

    }

    return 0;

}
```
# 质因子分解

> **将一个合数（大于1的整数）分解成一系列质数相乘的过程**

```cpp
class Solution {

public:

    int countPrimes(int n) {

        if(n<=1)return 0;

        int ans=0;

        for(int i=2;i*i<=n;i++){

            if(n%i==0){

                ++ans;

                while(n%i==0)n/=i;

            }

        }

        if(n>1)++ans;

        return ans;

    }

};
```

[952. 按公因数计算最大组件大小 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-component-size-by-common-factor/submissions/700948791/)
```cpp
class Solution {

public:

    vector<int>factor;

    vector<int>father;

    vector<int>size;

  

    void build(int n){

        factor.resize(n,-1);

        father.resize(n,0);

        for(int i=0;i<n;i++)father[i]=i;

        size.resize(n,1);

    }

  

    int find(int x){

        if(father[x]!=x)father[x]=find(father[x]);

        return father[x];

    }

  

    void Union(int a,int b){

        int fa=find(a),fb=find(b);

        if(fa!=fb){

            father[fa]=fb;

            size[fb]+=size[fa];

        }

    }

  

    int largestComponentSize(vector<int>& nums) {

        int n=nums.size();

        int s=0;

        for(auto&num:nums)s=max(s,num);

        build(s+1);

        for(int i=0;i<n;i++){

            int x=nums[i];

            for(int j=2;j*j<=x;j++){

                if(x%j==0){

                    if(factor[j]==-1)factor[j]=i;

                    else Union(factor[j],i);

                    while(x%j==0)x/=j;

                }

            }

            if(x>1){

                if(factor[x]==-1)factor[x]=i;

                else Union(factor[x],i);

            }

        }

        int ans=0;

        for(int i=0;i<n;i++)ans=max(ans,size[i]);

        return ans;

    }

};
```

# 质数筛

![[Pasted image 20260227153716.png]]

[204. 计数质数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-primes/)
```cpp
class Solution {

public:

    int countPrimes(int n) {

        return ehrlich(n-1);

    }

  

    int ehrlich(int n){

        if(n<=1)return 0;

        vector<bool>visited(n+1,false);

        for(int i=2;i*i<=n;i++){

            if(!visited[i]){

                for(int j=i*i;j<=n;j+=i)visited[j]=true;

            }

        }

        int cnt=0;

        for(int i=2;i<=n;i++)cnt+=visited[i]?0:1;

        return cnt;

    }

  

    int ehrlich_for_count(int n){

        if(n<=1)return 0;

        vector<bool>visited(n+1,false);

        int cnt=(n+1)/2;

        for(int i=3;i*i<=n;i++){

            if(!visited[i]){

                for(int j=i*i;j<=n;j+=2*i){

                    if(!visited[j]){

                        visited[j]=true;

                        --cnt;

                    }

                }

            }

        }

        return cnt;

    }

};
```