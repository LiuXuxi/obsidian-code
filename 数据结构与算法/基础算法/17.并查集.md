
# 原理

![[Pasted image 20260206174442.png]]

## 模板

[并查集的实现_牛客题霸_牛客网](https://www.nowcoder.com/practice/e7ed657974934a30b2010046536a5372)

```cpp
#include<iostream>
#include<vector>
using namespace std;

class UnionFind {
private:
    vector<int>father;
    vector<int>size;

    int find(int num) {
        int root = num;
        while (root != father[root])root = father[root];
        while (num != root) {
            father[num] = root;
            num = father[num];
        }
        return root;
    }

public:
    UnionFind(int n) {
        father.resize(n+1,0);
        size.resize(n+1,1);
        for (int i = 0; i < father.size(); i++)father[i] = i;
    }

    bool isSame(int a, int b) {
        int fa = find(a);
        int fb = find(b);
        return fa == fb;
    }

    void Union(int a, int b) {
        int fa = find(a);
        int fb = find(b);
        if (fa != fb) {
            if (size[fa] > size[fb]) {
                size[fa] += size[fb];
                father[fb] = fa;
            }
            else {
                size[fb] += size[fa];
                father[fa] = fb;
            }
        }
    }
};

int main() {
    int n, m;
    cin >> n >> m;
    UnionFind sln(n);
    while (m--) {
        int opt, a, b;
        cin >> opt >> a >> b; 
        switch (opt) {
        case 1:
            if (sln.isSame(a, b))cout << "Yes" << endl;
            else cout << "No" << endl;
            break;
        case 2:
            sln.Union(a, b);
        }
    }
    return 0;
}
```



## 轻量模板

[记录详情 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/record/261379259)

```cpp
#include<iostream>
#include<vector>
using namespace std;

class UnionFind {
private:
    vector<int>father;

    int find(int num) {
        if (father[num] != num)father[num] = find(father[num]);
        return father[num];
    }

public:
    UnionFind(int n) {
        father.resize(n+1,0);
        for (int i = 0; i < father.size(); i++)father[i] = i;
    }

    bool isSame(int a, int b) {
        return find(a) == find(b);
    }

    void Union(int a, int b) {
        father[find(a)] = find(b);
    }
};

int main() {
    int n, m;
    cin >> n >> m;
    UnionFind sln(n);
    while (m--) {
        int opt, a, b;
        cin >> opt >> a >> b; 
        switch (opt) {
        case 2:
            if (sln.isSame(a, b))cout << "Y" << endl;
            else cout << "N" << endl;
            break;
        case 1:
            sln.Union(a, b);
            break;
        }
    }
    return 0;
}
```

## 经典用法

[765. 情侣牵手 - 力扣（LeetCode）](https://leetcode.cn/problems/couples-holding-hands/)

```cpp
class Solution {

public:

    vector<int>father;

    int cnt;

  

    int minSwapsCouples(vector<int>& row) {

        build(row.size()/2);

        for (int i = 0; i < row.size(); i+=2) {

            Union(row[i] / 2, row[i + 1] / 2);

        }

        return row.size()/2-cnt;

    }

  

    void build(int n) {

        father.resize(n);

        for(int i=0;i<n;i++)father[i]=i;

        cnt = n;

    }

  

    int find(int x) {

        if (x != father[x])father[x] = find(father[x]);

        return father[x];

    }

  

    void Union(int a, int b) {

        if(find(a)!=find(b)){

            father[find(a)] = find(b);

            --cnt;

        }

    }

};
```

[839. 相似字符串组 - 力扣（LeetCode）](https://leetcode.cn/problems/similar-string-groups/)

```cpp
class Solution {

private:

    vector<int> father;

    int cnt;

  

    void build(int n) {

        father.resize(n);

        for (int i = 0; i < n; ++i) {

            father[i] = i;

        }

        cnt = n;

    }

  

    int find(int x) {

        if (father[x] != x) {

            father[x] = find(father[x]);

        }

        return father[x];

    }

  

    void Union(int a, int b) {

        int rootA = find(a);

        int rootB = find(b);

        if (rootA != rootB) {

            father[rootA] = rootB;

            --cnt;

        }

    }

  

    bool check(const string& a, const string& b) {

        if (a.size() != b.size()) return false;

        int diff = 0;

        for (int i = 0; i < a.size(); i++) {

            if (a[i] != b[i]) {

                ++diff;

                if (diff > 2) return false;

            }

        }

        return diff == 0 || diff == 2;

    }

  

public:

    int numSimilarGroups(vector<string>& strs) {

        int n = strs.size();

        build(n);

        for (int i = 0; i < n; i++) {

            for (int j = i + 1; j < n; j++) {

                if (check(strs[i], strs[j])) {

                    Union(i, j);

                }

            }

        }

        return cnt;

    }

};
```

[200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/submissions/696904662/)

```cpp
class Solution {
public:
    vector<int>father;
    int cnt;

    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        build(grid, n * m);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == '1') {
                    if(j>=1&&grid[i][j-1]=='1')Union(index(i, j - 1, m), index(i, j, m));
                    if(i>=1&&grid[i-1][j]=='1')Union(index(i - 1, j, m), index(i, j, m));
                }
            }
        }
        return cnt;
    }

    int index(int i, int j, int m) { return i * m + j; }

    void build(vector<vector<char>>&grid,int size) {
        father.resize(size);
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == '1') {
                    ++cnt;
                    int idx = index(i, j, grid[0].size());
                    father[idx] = idx;
                }
            }
        }
    }

    int find(int num) {
        if (father[num] != num)father[num] = find(father[num]);
        return father[num];
    }

    void Union(int a, int b) {
        int fa = find(a);
        int fb = find(b);
        if (fa != fb) {
            --cnt;
            father[fa] = fb;
        }
    }
};
```

# 拓展

![[Pasted image 20260206174422.png]]

[947. 移除最多的同行或同列石头 - 力扣（LeetCode）](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/)

```cpp
class Solution {
public:
    vector<int>father;
    int cnt;

    int removeStones(vector<vector<int>>& stones) {
        unordered_map<int, int>cols, lines;
        build(stones.size());
        for (int i = 0; i < stones.size(); i++) {
            int col = stones[i][0];
            int line = stones[i][1];
            if (cols.contains(col)) Union(i, cols[col]);
            else cols.insert({ col,i });
            if (lines.contains(line)) Union(i, lines[line]);
            else lines.insert({ line,i });
        }
        return stones.size() - cnt;
    }

    void build(int n) {
        father.resize(n);
        for (int i = 0; i < n; i++)father[i] = i;
        cnt = n;
    }

    int find(int x) {
        if (father[x] != x)father[x] = find(father[x]);
        return father[x];
    }

    void Union(int a, int b) {
        int fa = find(a), fb = find(b);
        if (fa != fb) {
            father[fa] = fb;
            --cnt;
        }
    }
};
```

[2092. 找出知晓秘密的所有专家 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-people-with-secret/)

```cpp
class Solution {
public:
    vector<int>father;
    vector<bool>screct;
public:
    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {
        build(n);
        Union(0, firstPerson);
        vector<int>ans;
        sort(meetings.begin(), meetings.end(),
            [](const vector<int>& a, const vector<int>& b) {
                return a[2] < b[2];
            });
        for (int l = 0, r; l < meetings.size();) {
            r = l;
            while (r < meetings.size() && meetings[r][2] == meetings[l][2])++r;
            for (int i = l; i < r; i++) Union(meetings[i][0], meetings[i][1]);
            for (int i = l; i < r; i++) {
                int a = meetings[i][0], b = meetings[i][1];
                if (!screct[find(a)])father[a] = a;
                if (!screct[find(b)])father[b] = b;
            }
            l = r;
        }
        for (int i = 0; i < n; i++) {
            if (screct[find(i)])ans.push_back(i);
        }
        return ans;
    }

    void build(int n) {
        father.resize(n, 0);
        screct.resize(n, false);
        for (int i = 0; i < n; i++)father[i] = i;
        screct[0] = true;
    }

    int find(int x) {
        if (father[x] != x)father[x] = find(father[x]);
        return father[x];
    }

    void Union(int a, int b) {
        int fa = find(a);
        int fb = find(b);
        if (fa != fb) {
            father[fa] = fb;
            screct[fb] = screct[fb] || screct[fa];
        }
    }
};

```

[2421. 好路径的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-good-paths/)

```cpp
class Solution {
public:
    int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {
        build(vals.size());
        int ans = vals.size();
        sort(edges.begin(), edges.end(),
            [&](const vector<int>& a, const vector<int>& b) {
                return max(vals[a[0]],vals[a[1]]) < max(vals[b[0]],vals[b[1]]);
            });
        for (auto& edge : edges) ans += Union(edge[0], edge[1],vals);
        return ans;
    }

private:
    vector<int>father;
    vector<int>maxcnt;
private:
    void build(int n) {
        father.resize(n);
        maxcnt.resize(n,1);
        for (int i = 0; i < n; i++)father[i] = i;
    }

    int find(int x) {
        if (father[x] != x)father[x] = find(father[x]);
        return father[x];
    }

    int Union(int a, int b, vector<int>& vals) {
        int fa = find(a), fb = find(b);
        int path = 0;
        if (vals[fa] > vals[fb])father[fb] = fa;
        else if (vals[fb] > vals[fa])father[fa] = fb;
        else {
            path = maxcnt[fa] * maxcnt[fb];
            father[fa] = fb;
            maxcnt[fb] += maxcnt[fa];
        }
        return path;
    }
};
```