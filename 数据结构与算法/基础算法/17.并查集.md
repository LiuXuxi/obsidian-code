
# 原理

## 模板

[并查集的实现_牛客题霸_牛客网](https://www.nowcoder.com/practice/e7ed657974934a30b2010046536a5372)

```cpp
#include<iostream>
#include<vector>
using namespace std;

class UnionFind {
private:
    vector<int>father;
    vector<int>size;

    int find(int num) {
        int root = num;
        while (root != father[root])root = father[root];
        while (num != root) {
            father[num] = root;
            num = father[num];
        }
        return root;
    }

public:
    UnionFind(int n) {
        father.resize(n+1,0);
        size.resize(n+1,1);
        for (int i = 0; i < father.size(); i++)father[i] = i;
    }

    bool isSame(int a, int b) {
        int fa = find(a);
        int fb = find(b);
        return fa == fb;
    }

    void Union(int a, int b) {
        int fa = find(a);
        int fb = find(b);
        if (fa != fb) {
            if (size[fa] > size[fb]) {
                size[fa] += size[fb];
                father[fb] = fa;
            }
            else {
                size[fb] += size[fa];
                father[fa] = fb;
            }
        }
    }
};

int main() {
    int n, m;
    cin >> n >> m;
    UnionFind sln(n);
    while (m--) {
        int opt, a, b;
        cin >> opt >> a >> b; 
        switch (opt) {
        case 1:
            if (sln.isSame(a, b))cout << "Yes" << endl;
            else cout << "No" << endl;
            break;
        case 2:
            sln.Union(a, b);
        }
    }
    return 0;
}
```



## 轻量模板

[记录详情 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/record/261379259)

```cpp
#include<iostream>
#include<vector>
using namespace std;

class UnionFind {
private:
    vector<int>father;

    int find(int num) {
        if (father[num] != num)father[num] = find(father[num]);
        return father[num];
    }

public:
    UnionFind(int n) {
        father.resize(n+1,0);
        for (int i = 0; i < father.size(); i++)father[i] = i;
    }

    bool isSame(int a, int b) {
        return find(a) == find(b);
    }

    void Union(int a, int b) {
        father[find(a)] = find(b);
    }
};

int main() {
    int n, m;
    cin >> n >> m;
    UnionFind sln(n);
    while (m--) {
        int opt, a, b;
        cin >> opt >> a >> b; 
        switch (opt) {
        case 2:
            if (sln.isSame(a, b))cout << "Y" << endl;
            else cout << "N" << endl;
            break;
        case 1:
            sln.Union(a, b);
            break;
        }
    }
    return 0;
}
```

## 经典用法

[765. 情侣牵手 - 力扣（LeetCode）](https://leetcode.cn/problems/couples-holding-hands/)

```cpp
class Solution {

public:

    vector<int>father;

    int cnt;

  

    int minSwapsCouples(vector<int>& row) {

        build(row.size()/2);

        for (int i = 0; i < row.size(); i+=2) {

            Union(row[i] / 2, row[i + 1] / 2);

        }

        return row.size()/2-cnt;

    }

  

    void build(int n) {

        father.resize(n);

        for(int i=0;i<n;i++)father[i]=i;

        cnt = n;

    }

  

    int find(int x) {

        if (x != father[x])father[x] = find(father[x]);

        return father[x];

    }

  

    void Union(int a, int b) {

        if(find(a)!=find(b)){

            father[find(a)] = find(b);

            --cnt;

        }

    }

};
```

[839. 相似字符串组 - 力扣（LeetCode）](https://leetcode.cn/problems/similar-string-groups/)

```cpp
class Solution {

private:

    vector<int> father;

    int cnt;

  

    void build(int n) {

        father.resize(n);

        for (int i = 0; i < n; ++i) {

            father[i] = i;

        }

        cnt = n;

    }

  

    int find(int x) {

        if (father[x] != x) {

            father[x] = find(father[x]);

        }

        return father[x];

    }

  

    void Union(int a, int b) {

        int rootA = find(a);

        int rootB = find(b);

        if (rootA != rootB) {

            father[rootA] = rootB;

            --cnt;

        }

    }

  

    bool check(const string& a, const string& b) {

        if (a.size() != b.size()) return false;

        int diff = 0;

        for (int i = 0; i < a.size(); i++) {

            if (a[i] != b[i]) {

                ++diff;

                if (diff > 2) return false;

            }

        }

        return diff == 0 || diff == 2;

    }

  

public:

    int numSimilarGroups(vector<string>& strs) {

        int n = strs.size();

        build(n);

        for (int i = 0; i < n; i++) {

            for (int j = i + 1; j < n; j++) {

                if (check(strs[i], strs[j])) {

                    Union(i, j);

                }

            }

        }

        return cnt;

    }

};
```