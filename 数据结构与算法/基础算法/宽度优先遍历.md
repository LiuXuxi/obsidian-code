
# 1.基本BFS

![[Pasted image 20260210140128.png]] 
[1162. 地图分析 - 力扣（LeetCode）](https://leetcode.cn/problems/as-far-from-land-as-possible/submissions/697724280/)

- **stickers**: `["control", "heart", "party"]`
    
- **target**: `"parrot"`

![[Pasted image 20260210161750.png]]

![[Pasted image 20260210162146.png]]

![[Pasted image 20260210162551.png]]

![[Pasted image 20260210163031.png]]

```cpp
class Solution {

public:

    vector<int>move{-1,0,1,0,-1};

  

    int maxDistance(vector<vector<int>>& grid) {

        int n=grid.size(),m=grid[0].size();

        int sea=0;

        queue<pair<int,int>>wait;

        vector<vector<bool>>visited(n,vector<bool>(m,false));

        for(int i=0;i<n;i++){

            for(int j=0;j<m;j++){

                if(grid[i][j]){

                    visited[i][j]=true;

                    wait.push({i,j});

                }else ++sea;

            }

        }

        if(sea==0||sea==n*m)return -1;

        int ans=0;

        while(!wait.empty()){

            ans++;

            int size=wait.size();

            for(int i=0;i<size;i++){

                pair<int,int>pos=wait.front();

                wait.pop();

                for(int j=0;j<4;j++){

                    int nx=pos.first+move[j];

                    int ny=pos.second+move[j+1];

                    if(nx>=0&&ny>=0&&nx<n&&ny<m&&visited[nx][ny]==false){

                        visited[nx][ny]=true;

                        wait.push({nx,ny});

                    }

                }

            }

        }

        return ans-1;

    }

};
```

[691. 贴纸拼词 - 力扣（LeetCode）](https://leetcode.cn/problems/stickers-to-spell-word/)

```cpp
class Solution {

public:

    int minStickers(vector<string>& stickers, string target) {

        unordered_set<string>visited;

        vector<list<string>>graph(26);

        for(auto&sticker:stickers){

            sort(sticker.begin(),sticker.end());

            for(int i=0;i<sticker.size();i++){

                if(i==0||sticker[i]!=sticker[i-1]){

                    graph[sticker[i]-'a'].push_back(sticker);

                }

            }

        }

        sort(target.begin(),target.end());

        visited.insert(target);

        queue<string>wait;

        wait.push(target);

        int ans=1;

        while(!wait.empty()){

            int size=wait.size();

            for(int i=0;i<size;i++){

                string cur=wait.front();

                wait.pop();

                for(auto&s:graph[cur[0]-'a']){

                    string next=getnext(cur,s);

                    if(!next.size())return ans;

                    auto it=visited.find(next);

                    if(it==visited.end()){

                        visited.insert(next);

                        wait.push(next);

                    }

                }

            }

            ++ans;

        }

        return -1;

    }

  

    string getnext(string&cur,string&s){

        string next;

        for(int i=0,j=0;i<cur.size();){

            if(j==s.size())next.push_back(cur[i++]);

            else{

                if(cur[i]==s[j])++i,++j;

                else if(cur[i]<s[j])next.push_back(cur[i++]);

                else ++j;

            }

        }

        return next;

    }

};
```

# 2.与双端队列结合

![[Pasted image 20260210140113.png]]

[2290. 到达角落需要移除障碍物的最小数目 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/submissions/697767953/)

```cpp
class Solution {

public:

    vector<int>move{-1,0,1,0,1};

  

    int minimumObstacles(vector<vector<int>>& grid) {

        int n=grid.size(),m=grid[0].size();

        vector<vector<int>>distance(n,vector<int>(m,__INT_MAX__));

        distance[0][0]=0;

        deque<pair<int,int>>wait;

        wait.push_back({0,0});

        while(!wait.empty()){

            pair<int,int>pos=wait.front();

            wait.pop_front();

            int x=pos.first,y=pos.second;

            if(x==n-1&&y==m-1)return distance[n-1][m-1];

            for(int i=0;i<4;i++){

                int nx=x+move[i];

                int ny=y+move[i+1];

                if(nx>=0&&ny>=0&&nx<n&&ny<m&&

                distance[nx][ny]>distance[x][y]+grid[nx][ny]){

                    distance[nx][ny]=distance[x][y]+grid[nx][ny];

                    if(grid[nx][ny])wait.push_back({nx,ny});

                    else wait.push_front({nx,ny});

                }

            }

        }

        return -1;

    }

};
```

[1368. 使网格图至少有一条有效路径的最小代价 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/submissions/697773542/)

```cpp
class Solution {

public:

    vector<vector<int>>move{{},{0,1},{0,-1},{1,0},{-1,0}};

  

    int minCost(vector<vector<int>>& grid) {

        int n=grid.size(),m=grid[0].size();

        vector<vector<int>>distance(n,vector<int>(m,__INT_MAX__));

        distance[0][0]=0;

        deque<pair<int,int>>wait;

        wait.push_back({0,0});

        while(!wait.empty()){

            pair<int,int>pos=wait.front();

            wait.pop_front();

            int x=pos.first,y=pos.second;

            if(x==n-1&&y==m-1)return distance[n-1][m-1];

            for(int i=1;i<=4;i++){

                int nx=x+move[i][0];

                int ny=y+move[i][1];

                int weight=grid[x][y]==i?0:1;

                if(nx>=0&&ny>=0&&nx<n&&ny<m&&

                distance[nx][ny]>distance[x][y]+weight){

                    distance[nx][ny]=distance[x][y]+weight;

                    if(weight)wait.push_back({nx,ny});

                    else wait.push_front({nx,ny});

                }

            }

        }

        return -1;

    }

};
```

# 3.与优先队列结合

