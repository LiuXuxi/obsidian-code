# 1.最大公约数

> **最大公约数**和**最小公倍数**在头文件`#include<numeric>`中已有实现函数，分别为`gcd();`和`lcm`。代码较少，也可以在算法题自定义。

---

## 1.最大公约数的求法

> **最大公约数**是指两个或多个整数共有约数中**最大**的一个，也叫**最大公因数**。

```cpp
//原理为欧几里得算法，可以直接用结果
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

---

## 2.最小公倍数的求法

> **最小公倍数**是指两个或多个整数公有的倍数中**最小**的一个

```cpp
int lcm(int a, int b) {
    return a / gcd(a, b) * b;  // 先除后乘，避免溢出
}
```

---

## 3.作为工具解题

### [878. 第 N 个神奇数字 - 力扣（LeetCode）](https://leetcode.cn/problems/nth-magical-number/)

对于已给定的$n$，**得到的答案一定在固定的范围内**，因此我们可以考虑使用二分答案法

**二分边界**：

==左边界==：最小可以很小，小到为1，但通过数学规律 *（被除数如果能被除数整除，被除数一定大于除数）*，我们不难猜出==第一个神奇数==为`min(a,b)`。

==有边界==：最大可以很大，大到`LLONG_MAX`，但是设想==当只给条件为给定一个整数a，求出给定第n个神奇数时==，答案一定为$n*a$，现在再加入$b$，则答案最大为`n * min(a, b)`。

==注意==：为了==避免溢出==，我们需要将`n`的类型扩大为`long long`，但是==不可以==写成`(long lon g)(n*min(a,b))`，因为`n*min(a,b)`得到的答案为`int`类型，在==扩大为`long long`之前就可能已经溢出。==

**`check` 逻辑：** 给定固定整数$m$，返回小于等于$m$的神奇数是否大于$n$
    ==运用容斥原理：== 小于等于$m$的能被$a$整除的数的个数为$m/a$，同理能被$b$整除的数的个数为$m/b$，能同时被$a$和$b$整除的数的个数为`m/lcm(a,b)`，根据容斥原理可以得到神奇数个数为`m/a+m/b-m/lcm(a,b)`。
        
- **决策方向：**
    
    - 最小化最大值：若 `check` 成功，说明 $m$ 可能太大，记录答案，向左找。
        
    - 最大化最小值：若 `check` 成功，说明 $m$ 可能太小，向右找。
        

```cpp
class Solution {
public:
    int nthMagicalNumber(int n, int a, int b) {
        long long ans = 0, _lcm = lcm(a, b);
        for (long long l = min(a,b), r = (long long)n * min(a, b); l <= r;) {
            long long m = l + (r - l) / 2;
            if (check(n, a, b, m, _lcm)) {
                ans = m;
                r = m - 1;
            }
            else l = m + 1;
        }
        return ans %1000000007;
    }

    long long gcd(long long a,long long b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    long long lcm(long long a, long long b) {
        return a / gcd(a, b) * b;
    }

    bool check(int n, long long a, long long b,long long m,long long _lcm) {
        return (m / a + m / b - m / _lcm) >= n;
    }
};
```

---

# 2.同余原理

## 1.同余介绍

> 当我们想要得到一个很大的数值（**真实值**）$mod$一个给定的值得到的数值（**答案值**）时，由于真实值可能很大（==甚至大到超出`long long`类型范围时==），直接计算出真实值再进行除模运算会导致**数值溢出**，这种情况下就需要运用到**同余原理**。

计算真实值时我们运用到的运算有四则运算，所以同余原理也同样分为**加减乘除**四种情况。

| 特征        | 描述                                                                                                                        |
| --------- | ------------------------------------------------------------------------------------------------------------------------- |
| **核心定义**​ | 两个整数 a 和 b，如果它们除以同一个正整数 m 所得的余数相同，则称 a 与 b 对模 m 同余，记作 $a ≡ b (mod m)$。                                                    |
| **等价表述**​ | $a ≡ b (mod m)$ ==等价于 ==m 能够整除 $(a - b)$，即 m                                                                              |
| **基本性质**​ | ==反身性== ($a ≡ a (mod m)$)、==对称性== (若 $a ≡ b (mod m)，则 b ≡ a (mod m)$)、==传递性== (若 $a ≡ b, b ≡ c，则 a ≡ c (mod m)$)，是一种等价关系。 |
| **运算性质**​ | 同余式可以==相加、相减、相乘==。即，若 $a ≡ b (mod m), c ≡ d (mod m)$，则 $a ± c ≡ b ± d (mod m)，a × c ≡ b × d (mod m)$。                     |

**注意：** 当答案值为负数时，需要转换为正数。`ans >= 0 ? ans : ans + mod`

## 2.加法同余

```cpp
int add(int a, int b, int mod) {
    a = a % mod;
    b = b % mod;
    int ans = (a + b) % mod;
    return ans >= 0 ? ans : ans + mod;
}
```

直接计算`a+b`可能会溢出，但是在同余原理下，将`a`和`b`同时`mod`，再相加模除，==得到的答案值不变==。

---


## 3，乘法同余

```cpp
int multiply(int a, int b, int mod) {
    a = a % mod;
    b = b % mod;
    long long ans = a * b;
    ans %= mod;
    return ans >= 0 ? ans : ans + mod;
}
```

a和b进行mod之后相乘==仍可能会溢出==，所以需用==更大范围的类型==接受相乘的结果再进行后续操作。

---

## 4.减法同余

```cpp
int minus(int a, int b, int mod) {
    a = a % mod;
    b = b % mod;
    int ans = (a - b) % mod;
    return ans >= 0 ? ans : ans + mod;
}
```

减法同余和加法相同。

---

## 5.除法同余


---

## 6.作为解题工具

### [2575. 找出字符串的可整除数组 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/submissions/692986052/)



```cpp
class Solution {
public:
    vector<int> divisibilityArray(string word, int m) {
        vector<int>ans;
        long long sum = 0;
        for (int i = 0; i < word.size(); i++) {
            sum = (sum % m * 10 + (word[i] - '0')) % m;
            if (sum)ans.push_back(0);
            else ans.push_back(1);
        }
        return ans;
    }
};
```

---

### [1497. 检查数组对是否可以被 k 整除 - 力扣（LeetCode）](https://leetcode.cn/problems/check-if-array-pairs-are-divisible-by-k/)

```cpp
class Solution {

public:

    bool canArrange(vector<int>& arr, int k){

        vector<int>cnt(k, 0);

        for (auto& num : arr) {

            num = (num % k + k) % k;

            ++cnt[num];

        }

        if (cnt[0] % 2 || (k % 2 ? 0 : cnt[k / 2] % 2))return false;

        for (int i = 1; i <= k / 2; i++) {

            if (cnt[i] != cnt[k - i])return false;

        }

        return true;

    }

};
```

