# 1.最大公约数

> **最大公约数**和**最小公倍数**在头文件`#include<numeric>`中已有实现函数，分别为`gcd();`和`lcm`。代码较少，也可以在算法题自定义。

---

## 1.最大公约数的求法

> **最大公约数**是指两个或多个整数共有约数中**最大**的一个，也叫**最大公因数**。

```cpp
//原理为欧几里得算法，可以直接用结果
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

---

## 2.最小公倍数的求法

> **最小公倍数**是指两个或多个整数公有的倍数中**最小**的一个

```cpp
int lcm(int a, int b) {
    return a / gcd(a, b) * b;  // 先除后乘，避免溢出
}
```

---

## 3.作为工具解题

### [878. 第 N 个神奇数字 - 力扣（LeetCode）](https://leetcode.cn/problems/nth-magical-number/)

对于已给定的$n$，**得到的答案一定在固定的范围内**，因此我们可以考虑使用二分答案法

**二分边界**：

==左边界==：最小可以很小，小到为1，但通过数学规律 *（被除数如果能被除数整除，被除数一定大于除数）*，我们不难猜出==第一个神奇数==为`min(a,b)`。

==有边界==：最大可以很大，大到`LLONG_MAX`，但是设想==当只给条件为给定一个整数a，求出给定第n个神奇数时==，答案一定为$n*a$，现在再加入$b$，则答案最大为`n * min(a, b)`。

==注意==：为了==避免溢出==，我们需要将`n`的类型扩大为`long long`，但是==不可以==写成`(long lon g)(n*min(a,b))`，因为`n*min(a,b)`得到的答案为`int`类型，在==扩大为`long long`之前就可能已经溢出。==

**`check` 逻辑：** 给定固定整数$m$，返回小于等于$m$的神奇数是否大于$n$
    ==运用容斥原理：== 小于等于$m$的能被$a$整除的数的个数为$m/a$，同理能被$b$整除的数的个数为$m/b$，能同时被$a$和$b$整除的数的个数为`m/lcm(a,b)`，根据容斥原理可以得到神奇数个数为`m/a+m/b-m/lcm(a,b)`。
        
- **决策方向：**
    
    - 最小化最大值：若 `check` 成功，说明 $m$ 可能太大，记录答案，向左找。
        
    - 最大化最小值：若 `check` 成功，说明 $m$ 可能太小，向右找。
        

```cpp
class Solution {
public:
    int nthMagicalNumber(int n, int a, int b) {
        long long ans = 0, _lcm = lcm(a, b);
        for (long long l = min(a,b), r = (long long)n * min(a, b); l <= r;) {
            long long m = l + (r - l) / 2;
            if (check(n, a, b, m, _lcm)) {
                ans = m;
                r = m - 1;
            }
            else l = m + 1;
        }
        return ans %1000000007;
    }

    long long gcd(long long a,long long b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    long long lcm(long long a, long long b) {
        return a / gcd(a, b) * b;
    }

    bool check(int n, long long a, long long b,long long m,long long _lcm) {
        return (m / a + m / b - m / _lcm) >= n;
    }
};
```

---

### 裴蜀定理
#### 1. 核心数学原理：裴蜀定理

**裴蜀定理**指出：

> 对于任何整数 $a, b$ 和它们的最大公约数 $d = \text{gcd}(a, b)$，关于 $x, y$ 的线性组合方程 $ax + by = z$ 有整数解，当且仅当 $z$ 是 $d$ 的倍数（即 $z \pmod d = 0$）。

[365. 水壶问题 - 力扣（LeetCode）](https://leetcode.cn/problems/water-and-jug-problem/)

在“水壶问题”中，无论你怎么倒水，两个水壶中水的**总和**的变化，本质上都是在对 $x$ 和 $y$ 进行加法或减法操作：

- **把装满 $x$ 的水壶倒进大桶**：总水量 $+x$。
    
- **把 $x$ 水壶里的水倒掉**：总水量 $-x$。
    
- **同理处理 $y$**：总水量 $\pm y$。
    

因此，任何时候桶里的水量 $z$ 都可以表示为：

$$z = a \cdot x + b \cdot y$$

（其中 $a, b$ 是你操作 $x$ 和 $y$ 水壶的次数，可以是正整数或负整数）。

根据裴蜀定理，这个 $z$（也就是你的 `target`）必须能被 $\text{gcd}(x, y)$ 整除。

---

#### 2. 为什么只需要 `gcd`？

你可能会问：倒水不是还有“把一个壶的水倒进另一个壶”这种操作吗？

其实，**“壶与壶之间互倒”并不改变总水量**。

- 操作前总水量：$V$
    
- 操作后总水量：依然是 $V$
    
    只有在从水龙头接水或往水槽倒水时，总水量才会改变。而每次改变的增量/减量，要么是 $x$，要么是 $y$。
    

所以，最终能不能凑出 `target`，完全取决于 `target` 是否在 $x$ 和 $y$ 能够“步进”的最小单位（即 $GCD$）的格点上。

---

#### 3. 代码逻辑逐行解析


```cpp
if (x + y < target) return false;
```

- **物理限制**：如果你两个水壶加起来一共只能装 5 升水，你是不可能测量出 6 升水的。这是最基本的边界条件。
    


```cpp
return !(target % gcd(x, y));
```

- `gcd(x, y)`：算出 $x$ 和 $y$ 能凑出的“最小水滴单位”。
    
- `target % gcd == 0`：判断目标水量是否是这个最小单位的整数倍。
    
- `!(...)`：在 C++ 中，如果余数为 0，`!` 之后变为 `true`，表示可以达成。
    

---

#### 4. 举个例子

假设 $x = 4, y = 6, target = 2$：

1. $\text{gcd}(4, 6) = 2$。
    
2. $2 \pmod 2 = 0$，返回 `true`。
    

- **实际操作**：装满 6 升，倒进 4 升壶里，6 升壶剩下 2 升。成功！
    

假设 $x = 4, y = 6, target = 3$：

1. $\text{gcd}(4, 6) = 2$。
    
2. $3 \pmod 2 = 1$，返回 `false`。
    

- **直观理解**：你每次操作都是以“2”为单位（因为 4 和 6 都是偶数），你永远不可能凑出一个奇数 3。
#### 5.代码

```cpp
class Solution {

public:

    bool canMeasureWater(int x, int y, int target) {

        if(x+y<target)return false;

        return !(target % gcd(x, y));

    }

};
```

---

### [1819. 序列中不同最大公约数的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-different-subsequences-gcds/submissions/693052486/)

#### 1. 核心逻辑：从“枚举子序列”转为“验证 GCD”

通常我们会想：取几个数，算算它们的 GCD 是多少？但数组很大时这行不通。

逆向思维： 我们枚举每一个可能的 GCD 值 $g$（从 1 到数组最大值），问：“数组中是否存在一个子序列，其最大公约数恰好是 $g$？”

#### 判定准则（关键）：

如果所有是 $g$ 的倍数的数（如 $g, 2g, 3g \dots$）聚在一起求 GCD，结果正好等于 $g$，那么这个 $g$ 就是可以被凑出来的。

---

#### 2. 代码逐行详解


```cpp
class Solution {
public:
    int countDifferentSubsequenceGCDs(vector<int>& nums) {
        // 1. 预处理：使用布尔数组标记哪些数字存在
        // 虽然 nums 长度达 10^5，但数值范围也在 2*10^5 左右
        // 这里的 exit 数组就是我们的“值域位图”
        bool exit[200005] = { false };
        int r = 0, ans = 0;
        for (auto& num : nums) {
            exit[num] = true;
            r = max(num, r); // 找到数组中的最大值，确定枚举边界
        }

        // 2. 外层循环：枚举所有可能的 GCD 值 g
        for (int g = 1; g <= r; g++) {
            int cur = 0; // cur 用于存储当前所有 g 的倍数的累积 GCD

            // 3. 内层循环：步长为 g，只检查 g 的倍数 (g, 2g, 3g...)
            // 这种跳跃式遍历是 $O(M \log M)$ 复杂度的核心
            for (int next = g; next <= r; next += g) {
                if (exit[next]) { // 如果这个倍数在原数组中确实存在
                    if (cur == 0) {
                        cur = next; // 找到第一个倍数
                    } else {
                        cur = gcd(cur, next); // 重点：不断求 GCD 
                    }
                    
                    // 4. 剪枝优化
                    // 只要当前的累积 GCD 已经降到了 g，就没必要再往后找更大的倍数了
                    // 因为 GCD 只会越求越小，不可能再变大
                    if (cur == g) {
                        ++ans;
                        break; 
                    }
                }
            }
        }
        return ans;
    }
};
```

---

#### 3. 为什么这个算法足够快？

- 调和级数复杂度：
    
    内层循环的次数分别是 $M/1, M/2, M/3 \dots$。
    
    数学上，这个总和是 $M \times (1 + \frac{1}{2} + \frac{1}{3} + \dots + \frac{1}{M})$。
    
    这个级数近似于 $\ln M$。因此，总时间复杂度为 $O(M \log M)$，其中 $M$ 是数值范围。
    
- 空间复杂度：
    
    使用了 exit 数组，空间复杂度为 $O(M)$。
    

---

#### 4. 关键点拨：为什么 `gcd(所有倍数) == g` 就能证明 $g$ 是有效的？

- **充分性**：如果 `gcd(某些倍数) == g`，那这些倍数本身就是一个合法的子序列。
    
- **必要性**：如果连所有是 $g$ 的倍数的数加在一起求 GCD 都降不到 $g$（比如结果是 $2g$），那么取其中的任何一部分子集，结果也一定是 $2g$ 的倍数，永远不可能达到 $g$。
    

---

#### 5. 注意事项

- **`cur == 0` 的处理**：这是为了处理找到的第一个倍数。在数学上，也可以理解为 $GCD(0, x) = x$。
    
- **C++ `gcd` 函数**：代码中直接调用了 `gcd`。在 C++17 中，这包含在 `<numeric>` 头文件中。如果编译器版本较低，需要手动实现辗转相除法。

---

# 2.同余原理

## 1.同余介绍

> 当我们想要得到一个很大的数值（**真实值**）$mod$一个给定的值得到的数值（**答案值**）时，由于真实值可能很大（==甚至大到超出`long long`类型范围时==），直接计算出真实值再进行除模运算会导致**数值溢出**，这种情况下就需要运用到**同余原理**。

计算真实值时我们运用到的运算有四则运算，所以同余原理也同样分为**加减乘除**四种情况。

| 特征        | 描述                                                                                                                        |
| --------- | ------------------------------------------------------------------------------------------------------------------------- |
| **核心定义**​ | 两个整数 a 和 b，如果它们除以同一个正整数 m 所得的余数相同，则称 a 与 b 对模 m 同余，记作 $a ≡ b (mod m)$。                                                    |
| **等价表述**​ | $a ≡ b (mod m)$ ==等价于 ==m 能够整除 $(a - b)$，即 m                                                                              |
| **基本性质**​ | ==反身性== ($a ≡ a (mod m)$)、==对称性== (若 $a ≡ b (mod m)，则 b ≡ a (mod m)$)、==传递性== (若 $a ≡ b, b ≡ c，则 a ≡ c (mod m)$)，是一种等价关系。 |
| **运算性质**​ | 同余式可以==相加、相减、相乘==。即，若 $a ≡ b (mod m), c ≡ d (mod m)$，则 $a ± c ≡ b ± d (mod m)，a × c ≡ b × d (mod m)$。                     |

**注意：** 当答案值为负数时，需要转换为正数。`ans >= 0 ? ans : ans + mod`

## 2.加法同余

```cpp
int add(int a, int b, int mod) {
    a = a % mod;
    b = b % mod;
    int ans = (a + b) % mod;
    return ans >= 0 ? ans : ans + mod;
}
```

直接计算`a+b`可能会溢出，但是在同余原理下，将`a`和`b`同时`mod`，再相加模除，==得到的答案值不变==。

---


## 3，乘法同余

```cpp
int multiply(int a, int b, int mod) {
    a = a % mod;
    b = b % mod;
    long long ans = a * b;
    ans %= mod;
    return ans >= 0 ? ans : ans + mod;
}
```

a和b进行mod之后相乘==仍可能会溢出==，所以需用==更大范围的类型==接受相乘的结果再进行后续操作。

---

## 4.减法同余

```cpp
int minus(int a, int b, int mod) {
    a = a % mod;
    b = b % mod;
    int ans = (a - b) % mod;
    return ans >= 0 ? ans : ans + mod;
}
```

减法同余和加法相同。

---

## 5.除法同余


---

## 6.作为解题工具

### [2575. 找出字符串的可整除数组 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/submissions/692986052/)



```cpp
class Solution {
public:
    vector<int> divisibilityArray(string word, int m) {
        vector<int>ans;
        long long sum = 0;
        for (int i = 0; i < word.size(); i++) {
            sum = (sum % m * 10 + (word[i] - '0')) % m;
            if (sum)ans.push_back(0);
            else ans.push_back(1);
        }
        return ans;
    }
};
```

---

### [1497. 检查数组对是否可以被 k 整除 - 力扣（LeetCode）](https://leetcode.cn/problems/check-if-array-pairs-are-divisible-by-k/)

```cpp
class Solution {

public:

    bool canArrange(vector<int>& arr, int k){

        vector<int>cnt(k, 0);

        for (auto& num : arr) {

            num = (num % k + k) % k;

            ++cnt[num];

        }

        if (cnt[0] % 2 || (k % 2 ? 0 : cnt[k / 2] % 2))return false;

        for (int i = 1; i <= k / 2; i++) {

            if (cnt[i] != cnt[k - i])return false;

        }

        return true;

    }

};
```

