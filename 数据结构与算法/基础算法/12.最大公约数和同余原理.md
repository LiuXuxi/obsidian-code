# 1.最大公约数

> **最大公约数**和**最小公倍数**在头文件`#include<numeric>`中已有实现函数，分别为`gcd();`和`lcm`。代码较少，也可以在算法题自定义。

## 1.最大公约数的求法

> **最大公约数**是指两个或多个整数共有约数中**最大**的一个，也叫**最大公因数**。

```cpp
//原理为欧几里得算法，可以直接用结果
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

## 2.最小公倍数的求法

> **最小公倍数**是指两个或多个整数公有的倍数中**最小**的一个

```cpp
int lcm(int a, int b) {
    return a / gcd(a, b) * b;  // 先除后乘，避免溢出
}
```

## 3.作为工具解题

[878. 第 N 个神奇数字 - 力扣（LeetCode）](https://leetcode.cn/problems/nth-magical-number/)

对于已给定的$n$，**得到的答案一定在固定的范围内**，因此我们可以考虑使用二分答案法

**二分边界**：

最小可以很小，小到为1，但通过数学规律 *（被除数如果能被除数整除，被除数一定大于除数）*，我们不难猜出第一个神奇数为`min(a,b)`，

```cpp
class Solution {
public:
    int nthMagicalNumber(int n, int a, int b) {
        long long ans = 0, _lcm = lcm(a, b);
        for (long long l = min(a,b), r = (long long)n * min(a, b); l <= r;) {
            long long m = l + (r - l) / 2;
            if (check(n, a, b, m, _lcm)) {
                ans = m;
                r = m - 1;
            }
            else l = m + 1;
        }
        return ans %1000000007;
    }

    long long gcd(long long a,long long b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    long long lcm(long long a, long long b) {
        return a / gcd(a, b) * b;
    }

    bool check(int n, long long a, long long b,long long m,long long _lcm) {
        return (m / a + m / b - m / _lcm) >= n;
    }
};
```
# 2.同余原理

