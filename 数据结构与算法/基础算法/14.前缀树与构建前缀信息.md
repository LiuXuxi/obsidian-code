
# 前缀树

## 类实现前缀树

[208. 实现 Trie (前缀树) - 力扣（LeetCode）](https://leetcode.cn/problems/implement-trie-prefix-tree/)

```cpp
class Trie {

public:

    Trie() {

        root = new Node;

    }

  

    void insert(string word) {

        root->pass++;

        Node* node = root;

        for (auto& c : word) {

            int path = c - 'a';

            if (node->nexts[path] == nullptr) {

                node->nexts[path] = new Node;

            }

            node = node->nexts[path];

            ++node->pass;

        }

        ++node->end;

    }

  

    bool search(string word) {

        Node* node = root;

        for (auto& c : word) {

            int path = c - 'a';

            if (node->nexts[path] == nullptr)return false;

            node = node->nexts[path];

        }

        return node->end != 0  ;

    }

  

    bool startsWith(string prefix) {

        Node* node = root;

        for (auto& c : prefix) {

            int path = c - 'a';

            if (node->nexts[path] == nullptr)return false;

            node = node->nexts[path];

        }

        return true;

    }

  

private:

    class Node {

    public:

        int pass;

        int end;

        unordered_map<int, Node*>nexts;

  

    public:

        Node():pass(0),end(0),nexts(unordered_map<int,Node*>()) {}

    };

  

public:

    Node* root;

};
```

## 静态空间实现前缀树

[字典树的实现_牛客题霸_牛客网](https://www.nowcoder.com/practice/7f8a8553ddbf4eaab749ec988726702b)

```cpp
#include<iostream>

#include<vector>

#include<string>

using namespace std;

  

#define MAXN 150001

  

class Trie {

public:

    Trie() : trie(MAXN, vector<int>(26, 0)),

        pass(MAXN, 0),

        end(MAXN, 0),

        cnt(1) {  // 注意：cnt 初始化为 1

    }

  

    void insert(string word) {

        int cur = 1;

        ++pass[cur];

        for (auto& c : word) {

            int path = c - 'a';

            if (trie[cur][path] == 0)trie[cur][path] = ++cnt;

            cur = trie[cur][path];

            ++pass[cur];

        }

        ++end[cur];

    }

  

    void del(string word) {

        if (search(word)) {

            int cur = 1;

            for (auto& c : word) {

                int path = c - 'a';

                if (--pass[trie[cur][path]] == 0) {

                    trie[cur][path] = 0;

                    return;

                }

                cur = trie[cur][path];

            }

            --end[cur];

        }

    }

  

    bool search(string word) {

        int cur = 1;

        for (auto& c : word) {

            int path = c - 'a';

            if (trie[cur][path] == 0)return false;

            cur = trie[cur][path];

        }

        return end[cur] > 0;

    }

  

    int prefixNumber(string pre) {

        int cur = 1;

        for (auto& c : pre) {

            int path = c - 'a';

            if (trie[cur][path] == 0)return 0;

            cur = trie[cur][path];

        }

        return pass[cur];

    }

  

private:

    vector<vector<int>>trie;

    vector<int>pass;

    vector<int>end;

    int cnt;

};

  

int main() {

    int m;

    cin >> m;

    Trie t;

    while (m--) {

        int op;

        string word;

        cin >> op >> word;

        switch (op) {

        case 1:

            t.insert(word);

            break;

        case 2:

            t.del(word);

            break;

        case 3:

            if (t.search(word))cout << "YES" << endl;

            else cout << "NO" << endl;

            break;

        case 4:

            cout << t.prefixNumber(word) << endl;

            break;

        }

    }

    return 0;

}
```

## 相关题目

[接头密匙_牛客题霸_牛客网](https://www.nowcoder.com/practice/c552d3b4dfda49ccb883a6371d9a6932)

```cpp
class Solution {

private:

    class Trie {

    public:

    #define MAXN 150001

        Trie() : trie(MAXN, vector<int>(12, 0)),

            pass(MAXN, 0),

            end(MAXN, 0),

            cnt(1) {  

        }

  

        void insert(string word) {

            int cur = 1;

            ++pass[cur];

            for (auto& c : word) {

                int path;

                if (isalnum(c))path = c - '0';

                else if (c == '#')path = 10;

                else path = 11;

                if (trie[cur][path] == 0)trie[cur][path] = ++cnt;

                cur = trie[cur][path];

                ++pass[cur];

            }

            ++end[cur];

        }

  

        int prefixNumber(string pre) {

            int cur = 1;

            for (auto& c : pre) {

                int path;

                if (isalnum(c))path = c - '0';

                else if (c == '#')path = 10;

                else path = 11;

                if (trie[cur][path] == 0)return 0;

                cur = trie[cur][path];

            }

            return pass[cur];

        }

  

    private:

        vector<vector<int>>trie;

        vector<int>pass;

        vector<int>end;

        int cnt;

    };

  

public:

    vector<int> countConsistentKeys(vector<vector<int> >& b, vector<vector<int> >& a) {

        Trie tree;

        vector<int>ans;

        for (auto& nums : a) {

            string temp;

            for (int i = 0; i < nums.size() - 1; i++) {

                temp.append(to_string(nums[i + 1] - nums[i]) + '#');

            }

            tree.insert(temp);

        }

        for (auto& nums : b) {

            string temp;

            for (int i = 0; i < nums.size() - 1; i++) {

                temp.append(to_string(nums[i + 1] - nums[i]) + '#');

            }

            ans.push_back(tree.prefixNumber(temp));

        }

        return ans;

    }

};
```

### 作为剪枝优化

[212. 单词搜索 II - 力扣（LeetCode）](https://leetcode.cn/problems/word-search-ii/)

```cpp
class Solution {
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        build(words);
        vector<string>ans;
        for (int i = 0; i < board.size(); i++) {
            for (int j = 0; j < board[i].size(); j++) {
                dfs(board, ans, i, j, 1);
            }
        }
        return ans;
    }

    int dfs(vector<vector<char>>& board, vector<string>& ans, int i, int j, int t) {
        if (i < 0 || i >= board.size() || j < 0 || j >= board[i].size() || board[i][j] == 0)return 0;
        int path = board[i][j] - 'a';
        t = tree[t][path];
        if (pass[t] == 0)return 0;
        int fix = 0;
        if (end[t] != "") {
            ++fix;
            ans.push_back(end[t]);
            end[t] = "";
        }
        board[i][j] = 0;
        fix += dfs(board, ans, i - 1, j, t);
        fix += dfs(board, ans, i + 1, j, t);
        fix += dfs(board, ans, i, j - 1, t);
        fix += dfs(board, ans, i, j + 1, t);
        pass[t] -= fix;
        board[i][j] = path + 'a';
        return fix;
    }

public:
    const int MAXN = 150001;
    vector<vector<int>>tree;
    vector<int>pass;
    vector<string>end;
    int cnt;

public:
    void build(vector<string>& words) {
        tree.resize(MAXN, vector<int>(26, 0));
        pass.resize(MAXN,0);
        end.resize(MAXN,"");
        cnt = 1;
        for (auto& word : words) {
            int cur = 1;
            ++pass[cur];
            for (auto& c : word) {
                int path = c - 'a';
                if (tree[cur][path] == 0)tree[cur][path] = ++cnt;
                cur = tree[cur][path];
                ++pass[cur];
            }
            end[cur] = word;
        }
    }
};
```


# 构建前缀信息——解决子数组相关问题

## 构建前缀和

[303. 区域和检索 - 数组不可变 - 力扣（LeetCode）](https://leetcode.cn/problems/range-sum-query-immutable/description/)

```cpp
class NumArray {

public:

    NumArray(vector<int>& nums) {

        preSum.resize(nums.size()+1,0);

        for (int i = 0; i < nums.size(); i++) {

            preSum[i+1] = preSum[i] + nums[i];

        }

    }

  

    int sumRange(int left, int right) {

        return preSum[right+1] - preSum[left];

    }

  

private:

    vector<int>preSum;

};
```

[未排序数组中累加和为给定值的最长子数组长度_牛客题霸_牛客网](https://www.nowcoder.com/practice/36fb0fd3c656480c92b569258a1223d5)

```cpp
#include<iostream>

#include<vector>

#include<unordered_map>

using namespace std;

  

int compute(vector<int>& nums, int k) {

    int ans = 0;

    unordered_map<int, int> map;

    map[0] = -1;

    for (int i = 0, sum = 0; i < nums.size(); i++) {

        sum += nums[i];

        // 检查是否存在前缀和 sum-k

        if (map.find(sum - k) != map.end())  // 修改这里

            ans = max(ans, i - map[sum - k]);

        // 只记录第一次出现的前缀和

        if (map.find(sum) == map.end())      // 修改这里

            map[sum] = i;

    }

    return ans;

}

  

int main() {

    int n, k;

    cin >> n >> k;

    vector<int> nums(n);

    for (auto& num : nums) cin >> num;

    cout << compute(nums, k);

    return 0;

}
```

[560. 和为 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-sum-equals-k/)

```cpp
class Solution {

public:

    int subarraySum(vector<int>& nums, int k) {

        unordered_map<int, int>map;

        int ans = 0;

        map[0] = 1;

        for (int i = 0,sum=0; i < nums.size(); i++) {

            sum += nums[i];

            ans += map.contains(sum - k) ? map[sum - k] : 0;

            map[sum] = map.contains(sum)?map[sum]+1:1;

        }

        return ans;

    }

};
```

