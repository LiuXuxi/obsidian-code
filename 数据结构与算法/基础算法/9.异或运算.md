>[!ABSTRACT]
>异或运算（Exclusive OR，简称 **XOR**）是计算机底层非常高效且神奇的二元逻辑运算。它的核心逻辑可以用一句话概括：**相同为 0，不同为 1**。
>在位运算符号中，通常用 `^` 表示。

---

[TOC]

# 1. 异或的基本规则

我们可以通过真值表来直观查看异或的运算结果：

|**A**|**B**|**A ^ B**|**解释**|
|---|---|---|---|
|0|0|**0**|相同|
|0|1|**1**|不同|
|1|0|**1**|不同|
|1|1|**0**|相同|

---

# 2. 异或的重要性质

掌握以下几个性质是解决算法题的关键：

1. **归零性：** $x \oplus x = 0$（任何数与自身异或，结果必为 0）。
    
2. **恒等性：** $x \oplus 0 = x$（任何数与 0 异或，结果不变）。
    
3. **交换律：** $a \oplus b = b \oplus a$。
    
4. **结合律：** $(a \oplus b) \oplus c = a \oplus (b \oplus c)$。

5. **逆运算性质：** 如果 $a \oplus b = c$，那么必有 $a \oplus c = b$ 以及 $b \oplus c = a$。（整体异或和如果是`x`，整体中某个部分的异或和如果是`y`，那么剩下部分的异或和是`x^y`


---

# 3. 为什么叫“不进位加法”？

如果你观察二进制加法：

- $0 + 0 = 0$
    
- $0 + 1 = 1$
    
- $1 + 0 = 1$
    
- $1 + 1 = 10$ (二进制，即 0 进位 1)
    

你会发现异或的结果正好就是**二进制加法舍弃进位**后的结果。因此，在底层电路设计中，异或门是半加器的核心组件。


# 4. 异或的经典算法应用

由于异或具有“自反性”和“交换律”，它在处理**成对出现**的数据时非常强大。

## A. 找出1种出现奇数次的数字

[136. 只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/single-number/?envType=problem-list-v2&envId=bit-manipulation)

**题目：** 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

- **思路：** 将数组中所有数字全部异或在一起。
    
- **原理：** 成对的数字会因为 $x \oplus x = 0$ 全部抵消掉，最后剩下的就是那个唯一的数字。
    
```cpp
class Solution {

public:

    int singleNumber(vector<int>& nums) {

        int ans = 0;

        for (auto& i : nums)ans ^= i;

        return ans;

    }

};
```

---

## B. 不使用临时变量交换两数

[面试题 16.01. 交换数字 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-numbers-lcci/?envType=problem-list-v2&envId=bit-manipulation)

利用异或可以实现在不申请额外空间的情况下交换变量 $a$ 和 $b$：

1. `a = a ^ b;`
    
2. `b = a ^ b;` // 此时 b = (原来的 a ^ b) ^ b = 原来的 a
    
3. `a = a ^ b;` // 此时 a = (原来的 a ^ b) ^ 原来的 a = 原来的 b
    
```cpp
class Solution {

public:

    vector<int> swapNumbers(vector<int>& numbers) {

        numbers[0]=numbers[0]^numbers[1];

        numbers[1]=numbers[0]^numbers[1];

        numbers[0]=numbers[0]^numbers[1];

        return numbers;

    }

};
```

---
## C.返回两个数的最大值

[面试题 16.07. 最大数值 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-lcci/?envType=problem-list-v2&envId=bit-manipulation)

**1. 核心辅助函数解析**

- **`flip(int n)`**:
    
    - 功能：将 `0` 变为 `1`，将 `1` 变为 `0`。
        
    - 原理：`n ^ 1`。如果 $n=1$，$1 \oplus 1 = 0$；如果 $n=0$，$0 \oplus 1 = 1$。
        
- **`sign(int n)`**:
    
    - 功能：判断数字的符号。**正数（及0）返回 1，负数返回 0**。
        
    - 原理：`n >> 31 & 1` 提取最高位（符号位）。在补码中，负数符号位为 `1`，正数为 `0`。
        
    - 后续调用 `flip`，将结果反转：负数变成 `0`，正数变成 `1`。
        



**2. 主逻辑解析：开关的设计**

代码通过 `returnA` 和 `returnB` 两个“互斥”的变量（一个为 1，另一个必为 0）来决定最终结果。

1. 第一步：处理溢出风险

如果直接计算 `c = a - b`，当 `a` 为正大数且 `b` 为负大数时会发生溢出。代码通过以下逻辑避开了这个问题：

- **`diff = sa ^ sb`**:
    
    - 如果 `a` 和 `b` **符号不同**，`diff` 为 `1`。
        
    - 如果 `a` 和 `b` **符号相同**，`diff` 为 `0`。
        
2. 第二步：决定何时返回 A (`returnA`)

`int returnA = diff * sa + same * sc;` 这是一个精妙的选择逻辑：

1. **当 $a, b$ 符号不同时 (`diff = 1, same = 0`)**:
    
    - 此时不需要看 $c = a - b$ 的符号（因为可能溢出）。
        
    - 直接看 $a$ 的符号 `sa`。如果 $a$ 是正数 (`sa=1`)，则 `returnA = 1 * 1 + 0 = 1`。
        
2. **当 $a, b$ 符号相同时 (`diff = 0, same = 1`)**:
    
    - 此时 $a - b$ 绝对不会溢出。
        
    - 看 $c$ 的符号 `sc`。如果 $a-b \ge 0$ (`sc=1`)，则 `returnA = 0 + 1 * 1 = 1`。
        

3. 第三步：计算最终结果

- `returnB = flip(returnA)`: 确保 `returnA` 和 `returnB` 只有一个是 `1`。
    
- `return returnA * a + returnB * b;`:
    
    - 如果 `returnA` 为 1，结果就是 $1 \cdot a + 0 \cdot b = a$。
        
    - 如果 `returnA` 为 0，结果就是 $0 \cdot a + 1 \cdot b = b$。
        



**3. 逻辑总结表**

|**情况**|**sa**|**sb**|**diff**|**same**|**sc (a-b)**|**returnA**|**结果**|
|---|---|---|---|---|---|---|---|
|**a正, b负**|1|0|1|0|(忽略)|$1 \cdot 1 + 0 = 1$|**a**|
|**a负, b正**|0|1|1|0|(忽略)|$1 \cdot 0 + 0 = 0$|**b**|
|**同号, a>b**|1/0|1/0|0|1|1|$0 + 1 \cdot 1 = 1$|**a**|
|**同号, a<b**|1/0|1/0|0|1|0|$0 + 1 \cdot 0 = 0$|**b**|

```cpp
class Solution {

private:

    int sign(int n) {

        return flip(n >> 31 & 1);

    }

  

    int flip(int n) {

        return n ^ 1;

    }

public:

    int maximum(int a, int b) {

        long long c=(long long)a-b;//防止报错

        int sa = sign(a), sb = sign(b), sc = sign(c);

        int diff = sa ^ sb;

        int same = flip(diff);

        int returnA = diff * sa + same * sc;

        int returnB = flip(returnA);

        return returnA * a + returnB * b;

    }

};
```



---

## D.找到缺失的数字

[268. 丢失的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/missing-number/?envType=problem-list-v2&envId=bit-manipulation)

**1. 核心原理：成对抵消**

异或运算（XOR）有一个关键特性：

- **$x \oplus x = 0$**（任何数与自身异或结果为 0）
    
- **$x \oplus 0 = x$**（任何数与 0 异或结果不变）
    

**2. 代码逻辑拆解**

1. 第一步：同步异或


```cpp
for (int i = 0; i < nums.size(); i++) {
    a ^= i;       // a 累积了 0 到 n-1 的异和
    b ^= nums[i]; // b 累积了数组中所有实际存在的数字异和
}
```

这一步建立了两组数据的对比：

1. 变量 `a` 负责记录**下标**（即预期中应该出现的数字部分）。
    
2. 变量 `b` 负责记录**数组内容**（即实际出现的数字）。
    

3. 第二步：补齐边界

```cpp
a ^= nums.size(); // 将最后一个预期数字 n 异或进去
```

由于循环只到了 `nums.size() - 1`，所以需要手动把数字 $n$ 补上。此时，变量 `a` 包含了从 $0$ 到 $n$ 的所有整数异或结果。

3. 第三步：相消求剩


```cpp
return a ^ b;
```

根据异或的**结合律**和**交换律**，`a ^ b` 相当于把 $[0, n]$ 所有的预期数字和数组里所有的实际数字全部搅合在一起异或。

- **出现两次的数字：** 那些既在下标里出现、也在数组里出现的数字，异或后全部变为 $0$。
    
- **出现一次的数字：** 只有那个“缺失的数字”在下标（预期）中出现过一次，而在数组中没有。
    
- 最终结果：$0 \oplus 0 \oplus \dots \oplus \text{缺失数字} = \text{缺失数字}$。
    

---

**3. 形象化理解**

假设 $n=3$，数组为 `[3, 0, 1]`，缺失 $2$。

|**步骤**|**参与运算的数字**|**逻辑表达**|
|---|---|---|
|**预期 (a)**|`0, 1, 2, 3`|$0 \oplus 1 \oplus 2 \oplus 3$|
|**实际 (b)**|`3, 0, 1`|$3 \oplus 0 \oplus 1$|
|**最终 (a^b)**|`(0^0) ^ (1^1) ^ (3^3) ^ 2`|**结果为 2**|

```cpp
class Solution {

public:

    int missingNumber(vector<int>& nums) {

        int a = 0, b = 0;

        for (int i = 0; i < nums.size(); i++) {

            a ^= i;

            b ^= nums[i];

        }

        a ^= nums.size();

        return a ^ b;

    }

};
```


---

# 进阶算法



## 1. Brian Kernigha（`n & (n - 1)`：消除最右侧的 1）

这是 **Brian Kernighan 算法**的核心。它的作用是将 $n$ 的二进制表示中**最右侧的那个 1 变成 0**。

- **原理：**
    
    - 假设 $n$ 的二进制最后几位是 `...1000`（即最右侧的 1 后面有若干个 0）。
        
    - 那么 $n - 1$ 的二进制对应位会变成 `...0111`（借位原理）。
        
    - 执行 `n & (n - 1)` 时，最右侧的 1 及其后面的部分变成了 `1000 & 0111 = 0000`。
        
- **应用场景：**
    
    - **计算汉明重量（Hamming Weight）：** 统计一个整数二进制中 1 的个数。每执行一次该运算，1 的计数器加一，直到 $n$ 变为 0。
        
    - **判断是否为 2 的幂：** 如果 $n > 0$ 且 `(n & (n - 1)) == 0`，说明该数二进制中只有一个 1，即它是 2 的幂。
        

>`n & (n - 1)` 的精髓在于它**对 $1$ 的敏感性**。
> 如果你想**统计** $1$ 的个数，它是计数器。
   如果你想**验证** $1$ 的个数，它是校验器。
   如果你想**利用**已知较小数的 $1$ 的个数，它是状态转移的桥梁。

### A.计算汉明重量

**题目描述：** 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位为 ‘1’ 的个数。

- **常规思路：** 循环 32 次，每次右移一位看最后一位是否为 1。
    
- **优化思路：** 使用 `n & (n - 1)`。每执行一次这个操作，`n` 中的一个 $1$ 就会消失。操作执行了多少次，就有多少个 $1$。
    
```cpp
int hammingWeight(uint32_t n) {
    int cnt = 0;
    while (n ) {
        n &= (n - 1); // 消除最右侧的 1
        cnt++;      // 计数
    }
    return cnt;
}
```

- **解析：** 这种方法的时间复杂度仅为 $O(k)$，其中 $k$ 是二进制中 $1$ 的个数，比 $O(32)$ 的全遍历更快。
---
### B.2 的幂
[231. 2 的幂 - 力扣](https://leetcode.cn/problems/power-of-two/?envType=problem-list-v2&envId=bit-manipulation)
**题目描述：** 给你一个整数 $n$，请你判断该整数是否是 2 的幂次方。

- **逻辑推导：**  如果一个数是 2 的幂（如 2, 4, 8, 16），它的二进制形式中有且仅有一个 $1$。
    
    - 例如：$8$ 的二进制是 `1000`。
        
- **位运算技巧：** 既然只有一个 $1$，那么消除掉这个唯一的 $1$ 之后，结果必然等于 $0$。
    

```cpp
bool isPowerOfTwo(int n) {
    // 2的幂必须大于0，且消除掉唯一的1后应为0
    return n > 0 && (n & (n - 1)) == 0;
}
```

- **解析：** 这是判断 2 的幂的最简写法。注意必须先排除 $n \le 0$ 的情况。
- ---
### C.比特位计数

[338. 比特位计数 ](https://leetcode.cn/problems/counting-bits/submissions/688109440/?envType=problem-list-v2&envId=bit-manipulation)

**题目描述：** 给你一个整数 $n$，对于 $0 \le i \le n$ 中的每个 $i$ ，计算其二进制表示中 $1$ 的个数 ，返回一个长度为 $n + 1$ 的数组。

- **动态规划思路：** * 设 `dp[i]` 为数字 $i$ 的 $1$ 的个数。
    
    - 我们知道 `i & (i - 1)` 得到的数肯定比 `i` 小，且正好少了一个 $1$。
        
    - 因此：`dp[i] = dp[i & (i - 1)] + 1`。
        


```cpp
vector<int> countBits(int n) {
    vector<int> res(n + 1, 0);
    for (int i = 1; i <= n; i++) {
        // i 的 1 的个数 = (消除掉一个1后的那个数) 的 1 的个数 + 1
        res[i] = res[i & (i - 1)] + 1;
    }
    return res;
}
```

- **解析：** 该算法通过位运算实现了 $O(n)$ 的线性时间复杂度，且代码极其简洁。
    



---

## 2.Lowbit（ `n & ((~n) + 1)`：提取最右侧的 1）

这个表达式通常写成 **`n & -n`**，它是 **Lowbit 算法**的核心。它的作用是**只保留二进制中最右侧的 1，其余位全部清零**。

- **原理：**
    
    - 在计算机中，`(~n) + 1` 正是 $n$ 的**补码**（即 `-n`）。
        
    - 假设 $n = 6$（二进制 `...0110`）。
        
    - 则 $-n = \text{取反} + 1 = `...1001` + 1 = `...1010`。
        
    - 执行 `n & -n`：`0110 & 1010 = 0010`（十进制的 2）。
        
- **应用场景：**
    
    - **树状数组（Binary Indexed Tree）：** 用于高效计算前缀和。
        
    - **分离异或和：** 在处理“数组中两个只出现一次的数字”时（如 LeetCode 260），利用此操作找到 $a$ 和 $b$ 不同的那一位，从而将数组分为两组。
        
### A.找到2种出现了奇数次的数字

[260. 只出现一次的数字 III ](https://leetcode.cn/problems/single-number-iii/description/?envType=problem-list-v2&envId=bit-manipulation)

**1. 第一步：得到 $a$ 和 $b$ 的异或和**


```cpp
int eor1 = 0;
for (auto& num : nums) eor1 ^= num;
```

- **原理**：根据异或运算的“归零性”（$x \oplus x = 0$）和“恒等性”（$x \oplus 0 = x$），成对出现的数字会全部抵消。
    
- **结果**：遍历结束后，`eor1` 的值等于 $a \oplus b$。由于 $a \neq b$，`eor1` 必定不为 0。
    



**2. 第二步：寻找区分点（提取最右侧的 1）**

```cpp
int rightone = eor1 == INT_MIN ? eor1 : eor1 & (-eor1);
```

- **目的**：在 $a \oplus b$ 的二进制表示中，找到一个为 `1` 的位。这一位说明在此位置上，$a$ 和 $b$ 的二进制值是一个为 `0`，另一个为 `1`。
    
- **方法**：使用 `n & -n` 技巧提取最右侧的 1。
    
- **溢出处理**：特意判断 `INT_MIN`。对 `INT_MIN` 直接取负会触发溢出，但是我们知道`INT_MIN` 的得到最右侧的`1`就是它本身，所以可以通过三元表达式规避了此风险。
    

**3. 第三步：分而治之（分组异或）**

```cpp
int eor2 = 0;
for (auto& num : nums) {
    if ((rightone & num) == 0) eor2 ^= num;
}
```

- **策略**：利用 `rightone` 这一位作为“分水岭”，将原数组逻辑上分为两组：
    
    1. **第一组**：所有在 `rightone` 这一位上为 `0` 的数字。
        
    2. **第二组**：所有在 `rightone` 这一位上为 `1` 的数字。
        
- **关键点**：
    
    - 相同的数字（成对出现的）必定会被分进同一个组，因为它们的位信息完全一致。
        
    - **$a$ 和 $b$ 必定会被分进不同的组**，因为它们在 `rightone` 这一位上不同。
        
- **结果**：循环结束后，`eor2` 实际上就是其中某一个只出现一次的数字（假设是 $a$）。
    

**4. 第四步：找回另一个数字**

```cpp
return { eor2, eor1 ^ eor2 };
```

- **原理**：这里运用了异或的 **“自反性”**。
    
- **推导**：既然 `eor1 = a ^ b`，且我们已经找到了 `eor2 = a`，那么 `eor1 ^ eor2` 展开就是 `(a ^ b) ^ a`。根据交换律和归零性，结果等于 `b`。
    

> **该算法展示了位运算在处理“成对抵消”问题上的极致优化：**

| **阶段**    | **操作**                       | **目的**                  |
| --------- | ---------------------------- | ----------------------- |
| **整体异或**  | `eor1 = a ^ b`               | 消去成对数字，留下两个目标数的混合信息     |
| **提取特征位** | `lowbit` 运算                  | 找到 $a$ 和 $b$ 之间的一个本质差异位 |
| **分组筛选**  | `if ((rightone & num) == 0)` | 将两个目标数彻底隔离开             |
| **逆运算还原** | `eor1 ^ eor2`                | 利用整体异或和还原出第二个缺失数        |

```cpp
class Solution {

public:

    vector<int> singleNumber(vector<int>& nums) {

        int eor1 = 0;

        for (auto& num : nums)eor1 ^= num;

        int rightone = eor1==INT_MIN?eor1:eor1&(-eor1);

        int eor2 = 0;

        for (auto& num : nums) {

            if ((rightone & num) == 0)eor2 ^= num;

        }

        return { eor2,eor1 ^ eor2 };

    }

};
```

---
### B.返回出现次数小于m次的那种数

[137. 只出现一次的数字 II ](https://leetcode.cn/problems/single-number-ii/description/?envType=problem-list-v2&envId=bit-manipulation)

**1. 核心思想：模 $k$ 加法**

如果一个数字出现了 3 次，那么它的二进制表示中，每一个为 `1` 的位也总共出现了 3 次。

- 我们统计数组中所有数字在第 $i$ 位上 `1` 出现的总次数。
    
- 如果某一位的总次数能被 3 整除，说明那个“只出现一次的数字”在该位上是 `0`。
    
- 如果不能被 3 整除（余数必为 1），说明那个“只出现一次的数字”在该位上是 `1`。
    

---

 **2. 代码逻辑拆解**

1. 第一步：建立位计数器
```cpp
vector<int> cnt(32); // 建立一个长度为 32 的数组，对应 int 的 32 个位
```

2. 第二步：逐位累加

```cpp
for (auto& num : nums) {
    for (int i = 0; i < 32; i++) {
        cnt[i] += num >> i & 1; // 提取 num 的第 i 位并累加到 cnt[i]
    }
}
```

- `num >> i & 1`：通过右移 $i$ 位并与 $1$ 执行按位与，可以得到该数字在第 $i$ 位是 $0$ 还是 $1$。
    
- 遍历结束后，`cnt[i]` 存储了整个数组在二进制第 $i$ 位上 `1` 的个数之和。
    

**第三步：还原目标数字**
```cpp
int ans = 0;
for (int i = 0; i < 32; i++) {
    ans |= cnt[i] % 3 == 0 ? 0 : 1 << i;
}
```

- `cnt[i] % 3`：对 3 取模。如果结果不为 0（即余数为 1），说明目标数字在这一位是 1。
    
- `ans |= (1 << i)`：利用按位或运算，将这个 `1` 填回结果 `ans` 的对应位置上。
    
**3. 举例验证**

假设数组为 `[2, 2, 3, 2]`（二进制为 `10, 10, 11, 10`）：

|**位位置 (i)**|**数字对应的位**|**cnt[i] 总和**|**cnt[i] % 3**|**ans 的对应位**|
|---|---|---|---|---|
|**第 0 位**|`0, 0, 1, 0`|**1**|**1**|**1**|
|**第 1 位**|`1, 1, 1, 1`|**4**|**1**|**1**|
|**其他位**|`0, 0, 0, 0`|**0**|**0**|**0**|

最终 `ans` 的二进制为 `...0011`，即十进制的 **3**。

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        vector<int>cnt(32);
        for (auto& num : nums) {
            for (int i = 0; i < 32; i++) {
                cnt[i] += num >> i & 1;
            }
        }
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            ans |= cnt[i]%3==0?0:1 << i;
        }
        return ans;
    }
};
```

---

## 总结对比

| **表达式**           | **别名**          | **核心功能**     | **结果示例 (n=6, 110)**      |
| ----------------- | --------------- | ------------ | ------------------------ |
| **`n & (n - 1)`** | Brian Kernighan | **干掉**最右边的 1 | `110 & 101 = 100` (变成 4) |
| **`n & -n`**      | Lowbit          | **取出**最右边的 1 | `110 & 010 = 010` (变成 2) |



