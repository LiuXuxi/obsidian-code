>[!ABSTRACT]
>异或运算（Exclusive OR，简称 **XOR**）是计算机底层非常高效且神奇的二元逻辑运算。它的核心逻辑可以用一句话概括：**相同为 0，不同为 1**。
>在位运算符号中，通常用 `^` 表示。





---

## 1. 异或的基本规则

我们可以通过真值表来直观查看异或的运算结果：

|**A**|**B**|**A ^ B**|**解释**|
|---|---|---|---|
|0|0|**0**|相同|
|0|1|**1**|不同|
|1|0|**1**|不同|
|1|1|**0**|相同|

---

## 2. 异或的重要性质

掌握以下几个性质是解决算法题的关键：

1. **归零性：** $x \oplus x = 0$（任何数与自身异或，结果必为 0）。
    
2. **恒等性：** $x \oplus 0 = x$（任何数与 0 异或，结果不变）。
    
3. **交换律：** $a \oplus b = b \oplus a$。
    
4. **结合律：** $(a \oplus b) \oplus c = a \oplus (b \oplus c)$。

5. **逆运算性质：** 如果 $a \oplus b = c$，那么必有 $a \oplus c = b$ 以及 $b \oplus c = a$。（整体异或和如果是`x`，整体中某个部分的异或和如果是`y`，那么剩下部分的异或和是`x^y`


---

## 3. 为什么叫“不进位加法”？

如果你观察二进制加法：

- $0 + 0 = 0$
    
- $0 + 1 = 1$
    
- $1 + 0 = 1$
    
- $1 + 1 = 10$ (二进制，即 0 进位 1)
    

你会发现异或的结果正好就是**二进制加法舍弃进位**后的结果。因此，在底层电路设计中，异或门是半加器的核心组件。


## 4. 异或的经典算法应用

由于异或具有“自反性”和“交换律”，它在处理**成对出现**的数据时非常强大。

### A. 找出1种出现奇数次的数字

[136. 只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/single-number/?envType=problem-list-v2&envId=bit-manipulation)

**题目：** 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

- **思路：** 将数组中所有数字全部异或在一起。
    
- **原理：** 成对的数字会因为 $x \oplus x = 0$ 全部抵消掉，最后剩下的就是那个唯一的数字。
    
```cpp
class Solution {

public:

    int singleNumber(vector<int>& nums) {

        int ans = 0;

        for (auto& i : nums)ans ^= i;

        return ans;

    }

};
```
### B. 不使用临时变量交换两数

[面试题 16.01. 交换数字 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-numbers-lcci/?envType=problem-list-v2&envId=bit-manipulation)

利用异或可以实现在不申请额外空间的情况下交换变量 $a$ 和 $b$：

1. `a = a ^ b;`
    
2. `b = a ^ b;` // 此时 b = (原来的 a ^ b) ^ b = 原来的 a
    
3. `a = a ^ b;` // 此时 a = (原来的 a ^ b) ^ 原来的 a = 原来的 b
    
```cpp
class Solution {

public:

    vector<int> swapNumbers(vector<int>& numbers) {

        numbers[0]=numbers[0]^numbers[1];

        numbers[1]=numbers[0]^numbers[1];

        numbers[0]=numbers[0]^numbers[1];

        return numbers;

    }

};
```


### C.返回两个数的最大值

[面试题 16.07. 最大数值 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-lcci/?envType=problem-list-v2&envId=bit-manipulation)

**1. 核心辅助函数解析**

- **`flip(int n)`**:
    
    - 功能：将 `0` 变为 `1`，将 `1` 变为 `0`。
        
    - 原理：`n ^ 1`。如果 $n=1$，$1 \oplus 1 = 0$；如果 $n=0$，$0 \oplus 1 = 1$。
        
- **`sign(int n)`**:
    
    - 功能：判断数字的符号。**正数（及0）返回 1，负数返回 0**。
        
    - 原理：`n >> 31 & 1` 提取最高位（符号位）。在补码中，负数符号位为 `1`，正数为 `0`。
        
    - 后续调用 `flip`，将结果反转：负数变成 `0`，正数变成 `1`。
        



**2. 主逻辑解析：开关的设计**

代码通过 `returnA` 和 `returnB` 两个“互斥”的变量（一个为 1，另一个必为 0）来决定最终结果。

1. 第一步：处理溢出风险

如果直接计算 `c = a - b`，当 `a` 为正大数且 `b` 为负大数时会发生溢出。代码通过以下逻辑避开了这个问题：

- **`diff = sa ^ sb`**:
    
    - 如果 `a` 和 `b` **符号不同**，`diff` 为 `1`。
        
    - 如果 `a` 和 `b` **符号相同**，`diff` 为 `0`。
        

2. 第二步：决定何时返回 A (`returnA`)

`int returnA = diff * sa + same * sc;` 这是一个精妙的选择逻辑：

1. **当 $a, b$ 符号不同时 (`diff = 1, same = 0`)**:
    
    - 此时不需要看 $c = a - b$ 的符号（因为可能溢出）。
        
    - 直接看 $a$ 的符号 `sa`。如果 $a$ 是正数 (`sa=1`)，则 `returnA = 1 * 1 + 0 = 1`。
        
2. **当 $a, b$ 符号相同时 (`diff = 0, same = 1`)**:
    
    - 此时 $a - b$ 绝对不会溢出。
        
    - 看 $c$ 的符号 `sc`。如果 $a-b \ge 0$ (`sc=1`)，则 `returnA = 0 + 1 * 1 = 1`。
        

#### 第三步：计算最终结果

- `returnB = flip(returnA)`: 确保 `returnA` 和 `returnB` 只有一个是 `1`。
    
- `return returnA * a + returnB * b;`:
    
    - 如果 `returnA` 为 1，结果就是 $1 \cdot a + 0 \cdot b = a$。
        
    - 如果 `returnA` 为 0，结果就是 $0 \cdot a + 1 \cdot b = b$。
        

---

### 3. 逻辑总结表

|**情况**|**sa**|**sb**|**diff**|**same**|**sc (a-b)**|**returnA**|**结果**|
|---|---|---|---|---|---|---|---|
|**a正, b负**|1|0|1|0|(忽略)|$1 \cdot 1 + 0 = 1$|**a**|
|**a负, b正**|0|1|1|0|(忽略)|$1 \cdot 0 + 0 = 0$|**b**|
|**同号, a>b**|1/0|1/0|0|1|1|$0 + 1 \cdot 1 = 1$|**a**|
|**同号, a<b**|1/0|1/0|0|1|0|$0 + 1 \cdot 0 = 0$|**b**|

---

### 4. 注意事项

在 C++ 中，`a - b` 溢出依然是一个潜在的 **Undefined Behavior (未定义行为)**。虽然这段代码在逻辑上通过 `diff` 屏蔽了溢出时的 `sc` 值，但在执行 `int c = a - b;` 这一行时，硬件层面已经可能触发溢出。

更稳妥的做法是将 a 和 b 强转为 long long 再做减法：

long long c = (long long)a - (long long)b;

### C. 提取二进制最后一位 1 (Lowbit)

正如你之前代码中看到的 `eor & (-eor)`：

- 虽然这是利用了补码特性，但它经常与异或配合。
    
- 在处理像 **LeetCode 260（两个只出现一次的数字）** 这样的题时，先用异或得到两个不同数字的异或和，再利用这个“最后一位 1”将原数组分为两组。
    

---

