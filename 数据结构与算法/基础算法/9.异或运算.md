>[!ABSTRACT]
>异或运算（Exclusive OR，简称 **XOR**）是计算机底层非常高效且神奇的二元逻辑运算。它的核心逻辑可以用一句话概括：**相同为 0，不同为 1**。
>在位运算符号中，通常用 `^` 表示。

---

# 1. 异或的基本规则

我们可以通过真值表来直观查看异或的运算结果：

|**A**|**B**|**A ^ B**|**解释**|
|---|---|---|---|
|0|0|**0**|相同|
|0|1|**1**|不同|
|1|0|**1**|不同|
|1|1|**0**|相同|

---

# 2. 异或的重要性质

掌握以下几个性质是解决算法题的关键：

1. **归零性：** $x \oplus x = 0$（任何数与自身异或，结果必为 0）。
    
2. **恒等性：** $x \oplus 0 = x$（任何数与 0 异或，结果不变）。
    
3. **交换律：** $a \oplus b = b \oplus a$。
    
4. **结合律：** $(a \oplus b) \oplus c = a \oplus (b \oplus c)$。

5. **逆运算性质：** 如果 $a \oplus b = c$，那么必有 $a \oplus c = b$ 以及 $b \oplus c = a$。（整体异或和如果是`x`，整体中某个部分的异或和如果是`y`，那么剩下部分的异或和是`x^y`


---

# 3. 为什么叫“不进位加法”？

如果你观察二进制加法：

- $0 + 0 = 0$
    
- $0 + 1 = 1$
    
- $1 + 0 = 1$
    
- $1 + 1 = 10$ (二进制，即 0 进位 1)
    

你会发现异或的结果正好就是**二进制加法舍弃进位**后的结果。因此，在底层电路设计中，异或门是半加器的核心组件。


# 4. 异或的经典算法应用

由于异或具有“自反性”和“交换律”，它在处理**成对出现**的数据时非常强大。

## A. 找出1种出现奇数次的数字

[136. 只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/single-number/?envType=problem-list-v2&envId=bit-manipulation)

**题目：** 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

- **思路：** 将数组中所有数字全部异或在一起。
    
- **原理：** 成对的数字会因为 $x \oplus x = 0$ 全部抵消掉，最后剩下的就是那个唯一的数字。
    
```cpp
class Solution {

public:

    int singleNumber(vector<int>& nums) {

        int ans = 0;

        for (auto& i : nums)ans ^= i;

        return ans;

    }

};
```

---

## B. 不使用临时变量交换两数

[面试题 16.01. 交换数字 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-numbers-lcci/?envType=problem-list-v2&envId=bit-manipulation)

利用异或可以实现在不申请额外空间的情况下交换变量 $a$ 和 $b$：

1. `a = a ^ b;`
    
2. `b = a ^ b;` // 此时 b = (原来的 a ^ b) ^ b = 原来的 a
    
3. `a = a ^ b;` // 此时 a = (原来的 a ^ b) ^ 原来的 a = 原来的 b
    
```cpp
class Solution {

public:

    vector<int> swapNumbers(vector<int>& numbers) {

        numbers[0]=numbers[0]^numbers[1];

        numbers[1]=numbers[0]^numbers[1];

        numbers[0]=numbers[0]^numbers[1];

        return numbers;

    }

};
```

---
## C.返回两个数的最大值

[面试题 16.07. 最大数值 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-lcci/?envType=problem-list-v2&envId=bit-manipulation)

**1. 核心辅助函数解析**

- **`flip(int n)`**:
    
    - 功能：将 `0` 变为 `1`，将 `1` 变为 `0`。
        
    - 原理：`n ^ 1`。如果 $n=1$，$1 \oplus 1 = 0$；如果 $n=0$，$0 \oplus 1 = 1$。
        
- **`sign(int n)`**:
    
    - 功能：判断数字的符号。**正数（及0）返回 1，负数返回 0**。
        
    - 原理：`n >> 31 & 1` 提取最高位（符号位）。在补码中，负数符号位为 `1`，正数为 `0`。
        
    - 后续调用 `flip`，将结果反转：负数变成 `0`，正数变成 `1`。
        



**2. 主逻辑解析：开关的设计**

代码通过 `returnA` 和 `returnB` 两个“互斥”的变量（一个为 1，另一个必为 0）来决定最终结果。

1. 第一步：处理溢出风险

如果直接计算 `c = a - b`，当 `a` 为正大数且 `b` 为负大数时会发生溢出。代码通过以下逻辑避开了这个问题：

- **`diff = sa ^ sb`**:
    
    - 如果 `a` 和 `b` **符号不同**，`diff` 为 `1`。
        
    - 如果 `a` 和 `b` **符号相同**，`diff` 为 `0`。
        
2. 第二步：决定何时返回 A (`returnA`)

`int returnA = diff * sa + same * sc;` 这是一个精妙的选择逻辑：

1. **当 $a, b$ 符号不同时 (`diff = 1, same = 0`)**:
    
    - 此时不需要看 $c = a - b$ 的符号（因为可能溢出）。
        
    - 直接看 $a$ 的符号 `sa`。如果 $a$ 是正数 (`sa=1`)，则 `returnA = 1 * 1 + 0 = 1`。
        
2. **当 $a, b$ 符号相同时 (`diff = 0, same = 1`)**:
    
    - 此时 $a - b$ 绝对不会溢出。
        
    - 看 $c$ 的符号 `sc`。如果 $a-b \ge 0$ (`sc=1`)，则 `returnA = 0 + 1 * 1 = 1`。
        

3. 第三步：计算最终结果

- `returnB = flip(returnA)`: 确保 `returnA` 和 `returnB` 只有一个是 `1`。
    
- `return returnA * a + returnB * b;`:
    
    - 如果 `returnA` 为 1，结果就是 $1 \cdot a + 0 \cdot b = a$。
        
    - 如果 `returnA` 为 0，结果就是 $0 \cdot a + 1 \cdot b = b$。
        



**3. 逻辑总结表**

|**情况**|**sa**|**sb**|**diff**|**same**|**sc (a-b)**|**returnA**|**结果**|
|---|---|---|---|---|---|---|---|
|**a正, b负**|1|0|1|0|(忽略)|$1 \cdot 1 + 0 = 1$|**a**|
|**a负, b正**|0|1|1|0|(忽略)|$1 \cdot 0 + 0 = 0$|**b**|
|**同号, a>b**|1/0|1/0|0|1|1|$0 + 1 \cdot 1 = 1$|**a**|
|**同号, a<b**|1/0|1/0|0|1|0|$0 + 1 \cdot 0 = 0$|**b**|

```cpp
class Solution {

private:

    int sign(int n) {

        return flip(n >> 31 & 1);

    }

  

    int flip(int n) {

        return n ^ 1;

    }

public:

    int maximum(int a, int b) {

        long long c=(long long)a-b;//防止报错

        int sa = sign(a), sb = sign(b), sc = sign(c);

        int diff = sa ^ sb;

        int same = flip(diff);

        int returnA = diff * sa + same * sc;

        int returnB = flip(returnA);

        return returnA * a + returnB * b;

    }

};
```



---

## D.找到缺失的数字

[268. 丢失的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/missing-number/?envType=problem-list-v2&envId=bit-manipulation)

**1. 核心原理：成对抵消**

异或运算（XOR）有一个关键特性：

- **$x \oplus x = 0$**（任何数与自身异或结果为 0）
    
- **$x \oplus 0 = x$**（任何数与 0 异或结果不变）
    

**2. 代码逻辑拆解**

1. 第一步：同步异或


```cpp
for (int i = 0; i < nums.size(); i++) {
    a ^= i;       // a 累积了 0 到 n-1 的异和
    b ^= nums[i]; // b 累积了数组中所有实际存在的数字异和
}
```

这一步建立了两组数据的对比：

1. 变量 `a` 负责记录**下标**（即预期中应该出现的数字部分）。
    
2. 变量 `b` 负责记录**数组内容**（即实际出现的数字）。
    

3. 第二步：补齐边界

```cpp
a ^= nums.size(); // 将最后一个预期数字 n 异或进去
```

由于循环只到了 `nums.size() - 1`，所以需要手动把数字 $n$ 补上。此时，变量 `a` 包含了从 $0$ 到 $n$ 的所有整数异或结果。

3. 第三步：相消求剩


```cpp
return a ^ b;
```

根据异或的**结合律**和**交换律**，`a ^ b` 相当于把 $[0, n]$ 所有的预期数字和数组里所有的实际数字全部搅合在一起异或。

- **出现两次的数字：** 那些既在下标里出现、也在数组里出现的数字，异或后全部变为 $0$。
    
- **出现一次的数字：** 只有那个“缺失的数字”在下标（预期）中出现过一次，而在数组中没有。
    
- 最终结果：$0 \oplus 0 \oplus \dots \oplus \text{缺失数字} = \text{缺失数字}$。
    

---

**3. 形象化理解**

假设 $n=3$，数组为 `[3, 0, 1]`，缺失 $2$。

|**步骤**|**参与运算的数字**|**逻辑表达**|
|---|---|---|
|**预期 (a)**|`0, 1, 2, 3`|$0 \oplus 1 \oplus 2 \oplus 3$|
|**实际 (b)**|`3, 0, 1`|$3 \oplus 0 \oplus 1$|
|**最终 (a^b)**|`(0^0) ^ (1^1) ^ (3^3) ^ 2`|**结果为 2**|

```cpp
class Solution {

public:

    int missingNumber(vector<int>& nums) {

        int a = 0, b = 0;

        for (int i = 0; i < nums.size(); i++) {

            a ^= i;

            b ^= nums[i];

        }

        a ^= nums.size();

        return a ^ b;

    }

};
```


---

# Brian Kernighan算法

>**Brian Kernighan 算法**是一种极其高效的位运算算法，用于计算一个整数的二进制表示中 **1 的个数**（也被称为计算汉明重量 Hamming Weight）。
该算法的核心在于精妙的位运算技巧：**`n & (n - 1)`** 和 **`n & ((~n)+1)`**。

---

## 1. `n & (n - 1)`：消除最右侧的 1

这是 **Brian Kernighan 算法**的核心。它的作用是将 $n$ 的二进制表示中**最右侧的那个 1 变成 0**。

- **原理：**
    
    - 假设 $n$ 的二进制最后几位是 `...1000`（即最右侧的 1 后面有若干个 0）。
        
    - 那么 $n - 1$ 的二进制对应位会变成 `...0111`（借位原理）。
        
    - 执行 `n & (n - 1)` 时，最右侧的 1 及其后面的部分变成了 `1000 & 0111 = 0000`。
        
- **应用场景：**
    
    - **计算汉明重量（Hamming Weight）：** 统计一个整数二进制中 1 的个数。每执行一次该运算，1 的计数器加一，直到 $n$ 变为 0。
        
    - **判断是否为 2 的幂：** 如果 $n > 0$ 且 `(n & (n - 1)) == 0`，说明该数二进制中只有一个 1，即它是 2 的幂。
        

---

## 2. `n & ((~n) + 1)`：提取最右侧的 1

这个表达式通常写成 **`n & -n`**，它是 **Lowbit 算法**的核心。它的作用是**只保留二进制中最右侧的 1，其余位全部清零**。

- **原理：**
    
    - 在计算机中，`(~n) + 1` 正是 $n$ 的**补码**（即 `-n`）。
        
    - 假设 $n = 6$（二进制 `...0110`）。
        
    - 则 $-n = \text{取反} + 1 = `...1001` + 1 = `...1010`。
        
    - 执行 `n & -n`：`0110 & 1010 = 0010`（十进制的 2）。
        
- **应用场景：**
    
    - **树状数组（Binary Indexed Tree）：** 用于高效计算前缀和。
        
    - **分离异或和：** 在处理“数组中两个只出现一次的数字”时（如 LeetCode 260），利用此操作找到 $a$ 和 $b$ 不同的那一位，从而将数组分为两组。
        
### A.找到2种出现了奇数次的数字

[260. 只出现一次的数字 III ](https://leetcode.cn/problems/single-number-iii/description/?envType=problem-list-v2&envId=bit-manipulation)

```cpp
class Solution {

public:

    vector<int> singleNumber(vector<int>& nums) {

        int eor1 = 0;

        for (auto& num : nums)eor1 ^= num;

        int rightone = eor1==INT_MIN?eor1:eor1&(-eor1);

        int eor2 = 0;

        for (auto& num : nums) {

            if ((rightone & num) == 0)eor2 ^= num;

        }

        return { eor2,eor1 ^ eor2 };

    }

};
```

### B.

---

## 总结对比

|**表达式**|**别名**|**核心功能**|**结果示例 (n=6, 110)**|
|---|---|---|---|
|**`n & (n - 1)`**|Brian Kernighan|**干掉**最右边的 1|`110 & 101 = 100` (变成 4)|
|**`n & -n`**|Lowbit|**取出**最右边的 1|`110 & 010 = 010` (变成 2)|

---

