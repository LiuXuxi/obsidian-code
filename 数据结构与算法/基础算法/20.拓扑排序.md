[210. 课程表 II - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-ii/submissions/697488715/)

```cpp
class Solution {

public:

    vector<list<int>>edges;

    vector<int>indegrees;

  

    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {

        build(numCourses,prerequisites);

        vector<int>ans;

        queue<int>wait;

        for(int i=0;i<indegrees.size();i++){

            if(indegrees[i]==0){

                wait.push(i);

            }

        }

        int cnt=0;

        while(!wait.empty()){

            ++cnt;

            int cur=wait.front();

            ans.push_back(cur);

            wait.pop();

            for(auto&i:edges[cur]){

                if(--indegrees[i]==0)wait.push(i);

            }

        }

        return cnt==numCourses?ans:vector<int>();

    }

  

    void build(int n,vector<vector<int>>& prerequisites){

        edges.resize(n);

        indegrees.resize(n);

        for(auto&group:prerequisites){

            ++indegrees[group[0]];

            edges[group[1]].push_front(group[0]);

        }

    }

};
```

[记录详情 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/record/262106527)

```cpp
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

class Solution{
public:
    vector<int>head;
    vector<int>next;
    vector<int>to;
    vector<int>indegree;
    int cnt;

    void build(int n, int m){  // 改为接收两个参数
        head.resize(n+1,0);
        next.resize(m+1,0);    // 根据边数分配
        to.resize(m+1,0);      // 根据边数分配
        indegree.resize(n+1,0); // 根据顶点数分配
        cnt=1;
    }

    void addEdge(int u,int v){
        if(cnt >= next.size()) return; // 防止越界
        next[cnt]=head[u];
        to[cnt]=v;
        head[u]=cnt++;
        ++indegree[v];
    }

    vector<int> topoSort(int n){
        priority_queue<int,vector<int>,greater<>>wait;
        for(int i=1;i<=n;i++){  // 改为i<=n
            if(indegree[i]==0)wait.push(i);
        }
        vector<int>ans;
        int count=0;
        while(!wait.empty()){
            int cur=wait.top();
            wait.pop();
            ++count;
            ans.push_back(cur);
            for(int ei=head[cur];ei>0;ei=next[ei]){
                int v = to[ei];  // 获取目标顶点
                if(--indegree[v]==0)wait.push(v);  // 修正
            }
        }
        return count==n?ans:vector<int>();
    }
};

int main(){
    int n,m;
    cin>>n>>m;
    Solution sln;
    sln.build(n, m);  // 传入顶点数和边数
    int u,v;
    while(m--){
        cin>>u>>v;
        sln.addEdge(u,v);
    }
    vector<int>ans=sln.topoSort(n);
    for(auto&i:ans)cout<<i<<" ";
    return 0;
}
```