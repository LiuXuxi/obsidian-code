# 1.原理

[210. 课程表 II - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-ii/submissions/697488715/)

```cpp
class Solution {

public:

    vector<list<int>>edges;

    vector<int>indegrees;

  

    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {

        build(numCourses,prerequisites);

        vector<int>ans;

        queue<int>wait;

        for(int i=0;i<indegrees.size();i++){

            if(indegrees[i]==0){

                wait.push(i);

            }

        }

        int cnt=0;

        while(!wait.empty()){

            ++cnt;

            int cur=wait.front();

            ans.push_back(cur);

            wait.pop();

            for(auto&i:edges[cur]){

                if(--indegrees[i]==0)wait.push(i);

            }

        }

        return cnt==numCourses?ans:vector<int>();

    }

  

    void build(int n,vector<vector<int>>& prerequisites){

        edges.resize(n);

        indegrees.resize(n);

        for(auto&group:prerequisites){

            ++indegrees[group[0]];

            edges[group[1]].push_front(group[0]);

        }

    }

};
```

[记录详情 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/record/262106527)

```cpp
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

class Solution{
public:
    vector<int>head;
    vector<int>next;
    vector<int>to;
    vector<int>indegree;
    int cnt;

    void build(int n, int m){  // 改为接收两个参数
        head.resize(n+1,0);
        next.resize(m+1,0);    // 根据边数分配
        to.resize(m+1,0);      // 根据边数分配
        indegree.resize(n+1,0); // 根据顶点数分配
        cnt=1;
    }

    void addEdge(int u,int v){
        if(cnt >= next.size()) return; // 防止越界
        next[cnt]=head[u];
        to[cnt]=v;
        head[u]=cnt++;
        ++indegree[v];
    }

    vector<int> topoSort(int n){
        priority_queue<int,vector<int>,greater<>>wait;
        for(int i=1;i<=n;i++){  // 改为i<=n
            if(indegree[i]==0)wait.push(i);
        }
        vector<int>ans;
        int count=0;
        while(!wait.empty()){
            int cur=wait.top();
            wait.pop();
            ++count;
            ans.push_back(cur);
            for(int ei=head[cur];ei>0;ei=next[ei]){
                int v = to[ei];  // 获取目标顶点
                if(--indegree[v]==0)wait.push(v);  // 修正
            }
        }
        return count==n?ans:vector<int>();
    }
};

int main(){
    int n,m;
    cin>>n>>m;
    Solution sln;
    sln.build(n, m);  // 传入顶点数和边数
    int u,v;
    while(m--){
        cin>>u>>v;
        sln.addEdge(u,v);
    }
    vector<int>ans=sln.topoSort(n);
    for(auto&i:ans)cout<<i<<" ";
    return 0;
}
```

[LCR 114. 火星词典 - 力扣（LeetCode）](https://leetcode.cn/problems/Jf1JuT/)

```cpp
class Solution {

public:

    vector<list<int>>edges;

    vector<int>indegree;

  

    void build(int n){

        edges.resize(n);

        indegree.resize(n,-1);

    }

  

    void addEdge(int u,int v){

        ++indegree[v];

        edges[u].push_front(v);

    }

  

    string alienOrder(vector<string>& words) {

        build(26);

        for(auto&word:words){

            for(auto&c:word){

                if(indegree[c-'a']==-1){

                    indegree[c-'a']=0;

                }

            }

        }

        for(int i=0;i<words.size()-1;i++){

            string next=words[i+1];

            string cur=words[i];

            int len=min(cur.size(),next.size());

            int j=0;

            for(;j<len;j++){

                if(cur[j]!=next[j]){

                    addEdge(cur[j]-'a',next[j]-'a');

                    break;

                }

            }

            if(j<cur.size()&&j==next.size())return "";

        }

        string ans;

        queue<int>wait;

        int kinds=0;

        for(int i=0;i<edges.size();i++){

            if(indegree[i]!=-1)++kinds;

            if(indegree[i]==0)wait.push(i);

        }

        while(!wait.empty()){

            int cur=wait.front();

            wait.pop();

            ans.push_back(cur+'a');

            for(auto&v:edges[cur]){

                if(--indegree[v]==0)wait.push(v);

            }

        }

        return ans.size()==kinds?ans:"";

    }

};
```

[936. 戳印序列 - 力扣（LeetCode）](https://leetcode.cn/problems/stamping-the-sequence/)

```cpp
class Solution {

public:

    vector<int>indegree;

    vector<list<int>>edges;

  

    void build(int n,int m){

        indegree.resize(n-m+1,m);

        edges.resize(n);

    }

  

    void addEdge(int u,int v){

        edges[u].push_front(v);

    }

  

    vector<int> movesToStamp(string stamp, string target) {

        int n=target.size(),m=stamp.size();

        build(n,m);

        queue<int>wait;

        vector<int>ans;

        for(int i=0;i<=n-m;i++){

            for(int j=0;j<m;j++){

                if(stamp[j]==target[i+j]){

                    if(--indegree[i]==0)wait.push(i);

                }else{

                    addEdge(i+j,i);

                }

            }

        }

        vector<bool>visited(n,false);

        while(!wait.empty()){

            int cur=wait.front();

            wait.pop();

            ans.push_back(cur);

            for(int i=0;i<m;i++){

                if(!visited[i+cur]){

                    visited[i+cur]=true;

                    for(auto&j:edges[cur+i]){

                        if(--indegree[j]==0)wait.push(j);

                    }

                }

            }

        }

        if(ans.size()!=n-m+1)return {};

        for(int i=0;i<ans.size()/2;i++)swap(ans[ans.size()-1-i],ans[i]);

        return ans;

    }

};
```

# 2.拓展

![[Pasted image 20260209182622.png]]

[记录详情 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/record/262165619)

```cpp
#include<iostream>

#include<vector>

#include<queue>

using namespace std;

  

int n,m;

int u,v;

vector<int>head;

vector<int>Next;

vector<int>to;

int cnt=1;

vector<int>lines;

vector<int>indegree;

queue<int>wait;

int mod=80112002;

  

void build(){

    head.resize(n+1,0);

    Next.resize(m+2,0);

    to.resize(m+2,0);

    lines.resize(n+1,0);

    indegree.resize(n+1,0);

}

  

void addEdge(int u,int v){

    Next[cnt]=head[u];

    to[cnt]=v;

    head[u]=cnt++;

    ++indegree[v];

}

  

int solve(){

    for(int i=1;i<=n;i++){

        if(indegree[i]==0){

            wait.push(i);

            lines[i]=1;

        }

    }

    int ans=0,size=0;

    while(!wait.empty()){

        int cur=wait.front();

        wait.pop();

        if(head[cur]==0)ans=(ans+lines[cur])%mod;

        else{

            for(int ei=head[cur];ei!=0;ei=Next[ei]){

                int v=to[ei];

                lines[v]=(lines[v]+lines[cur])%mod;

                if(--indegree[v]==0)wait.push(v);

            }

        }

    }

    return ans;

}

  

int main(){

    cin>>n>>m;

    build();

    for(int i=0;i<m;i++){

        cin>>u>>v;

        addEdge(u,v);

    }

    cout<<solve();

}
```

[851. 喧闹和富有 - 力扣（LeetCode）](https://leetcode.cn/problems/loud-and-rich/submissions/697568760/)

```cpp
class Solution {

public:

    static const int MAXN=500;

    static const int MAXM=MAXN * (MAXN - 1) / 2;

    int head[MAXN]{};

    int next[MAXM]{};

    int to[MAXM]{};

    int indegree[MAXN]{};

    int cnt=1;

    queue<int>wait;

  

    void addEdge(int u,int v){

        next[cnt]=head[u];

        to[cnt]=v;

        head[u]=cnt++;

        ++indegree[v];

    }

  

    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {

        int n=quiet.size();

        for(auto&rich:richer)addEdge(rich[0],rich[1]);

        for(int i=0;i<n;i++){

            if(indegree[i]==0)wait.push(i);

        }

        vector<int>ans;

        for(int i=0;i<n;i++)ans.push_back(i);

        while(!wait.empty()){

            int cur=wait.front();

            wait.pop();

            for(int ei=head[cur];ei!=0;ei=next[ei]){

                int v=to[ei];

                ans[v]=quiet[ans[v]]<quiet[ans[cur]]?ans[v]:ans[cur];

                if(--indegree[v]==0)wait.push(v);

            }

        }

        return ans;

    }

};
```

[2050. 并行课程 III - 力扣（LeetCode）](https://leetcode.cn/problems/parallel-courses-iii/submissions/697573682/)

```cpp
class Solution {

public:

    static const int MAXN=50002;

    static const int MAXM=50002;

    int head[MAXN]{};

    int next[MAXM]{};

    int to[MAXM]{};

    int indegree[MAXN]{};

    int cnt=1;

    queue<int>wait;

  

    void addEdge(int u,int v){

        next[cnt]=head[u];

        to[cnt]=v;

        head[u]=cnt++;

        ++indegree[v];

    }

  

    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {

        for(auto&rich:relations)addEdge(rich[0],rich[1]);

        for(int i=1;i<=n;i++){

            if(indegree[i]==0)wait.push(i);

        }

        vector<int>ans(n+1,0);

        for(int i=1;i<=n;i++)ans[i]=time[i-1];

        while(!wait.empty()){

            int cur=wait.front();

            wait.pop();

            for(int ei=head[cur];ei!=0;ei=next[ei]){

                int v=to[ei];

                ans[v] = max(ans[v], ans[cur] + time[v-1]);

                if(--indegree[v]==0)wait.push(v);

            }

        }

        int res=0;

        for(auto&i:ans)res=max(res,i);

        return res;

    }

};
```

[2127. 参加会议的最多员工数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/submissions/697584092/)

```cpp
class Solution {

public:

    int maximumInvitations(vector<int>& favorite) {

        int n=favorite.size();

        vector<int>indegree(n,0);

        for(int i=0;i<n;i++)++indegree[favorite[i]];

        queue<int>wait;

        for(int i=0;i<n;i++){

            if(indegree[i]==0)wait.push(i);

        }

        vector<int>deep(n,0);

        while(!wait.empty()){

            int cur=wait.front();

            wait.pop();

            int next=favorite[cur];

            deep[next]=max(deep[next],deep[cur]+1);

            if(--indegree[next]==0)wait.push(next);

        }

        int sumofSmallRing=0,bigRing=0;

        for(int i=0;i<n;i++){

            if(indegree[i]>0){

                int ringsize=1;

                indegree[i]=0;

                for(int j=favorite[i];j!=i;j=favorite[j]){

                    ++ringsize;

                    indegree[j]=0;

                }

                if(ringsize==2){

                    sumofSmallRing+=2+deep[i]+deep[favorite[i]];

                }else{

                    bigRing=max(bigRing,ringsize);

                }

            }

        }

        return max(sumofSmallRing,bigRing);

    }

};
```