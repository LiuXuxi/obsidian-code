# 基础原理

![[Pasted image 20260205200732.png]]
[239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/)

```cpp
class Solution {
public:
   vector<int> maxSlidingWindow(vector<int>& nums, int k) {
       if (nums.empty())return {};
       deque<int>value;
       vector<int>ans;
       value.push_back(0);
       for (int i = 1; i < k; i++) {
           while (!value.empty() && nums[value.back()] <= nums[i])value.pop_back();
           value.push_back(i);
       }
       ans.push_back(nums[value.front()]);
       for (int i = k; i < nums.size(); i++) {
           while (!value.empty() && nums[value.back()] <= nums[i])value.pop_back();
           value.push_back(i);
           if (i-k==value.front())value.pop_front();
           ans.push_back(nums[value.front()]);
       }
       return ans;
   }
};
```

[1438. 绝对差不超过限制的最长连续子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/)

```cpp
class Solution {
public:
    deque<int>maxIndex;
    deque<int>minIndex;
    int longestSubarray(vector<int>& nums, int limit) {
        if (nums.size() < 1)return 0;
        int ans = 0;
        for (int l = 0, r = 0; l < nums.size(); l++) {
            while (r < nums.size() && check(nums,r, limit))push(nums,r++);
            ans = max(ans, r - l);
            pop(l);
        }
        return ans;
    }

    bool check(vector<int>&nums,int index, int limit) {
        int maxValue = maxIndex.empty() ? nums[index] : max(nums[index], nums[maxIndex.front()]);
        int minValue = minIndex.empty() ? nums[index] : min(nums[index], nums[minIndex.front()]);
        return (maxValue - minValue) <= limit;
    }

    void push(vector<int>&nums,int index) {
        while (!maxIndex.empty() && nums[index] >= nums[maxIndex.back()])maxIndex.pop_back();
        maxIndex.push_back(index);
        while (!minIndex.empty() && nums[index] <= nums[minIndex.back()])minIndex.pop_back();
        minIndex.push_back(index);
    }

    void pop(int index) {
        if (index == maxIndex.front())maxIndex.pop_front();
        if (index == minIndex.front())minIndex.pop_front();
    }
};
```