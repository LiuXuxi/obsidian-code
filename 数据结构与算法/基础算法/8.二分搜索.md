> [!ABSTRACT]
> 二分搜索（Binary Search）是一种在**有序数组**中查找特定元素的效率极高的算法。它的核心思想是“折半查找”，通过不断缩小搜索范围来定位目标。

[TOC]
# 1. 基本原理

## 1.搜索原理

二分搜索每次都会查看搜索范围的正中间元素：

1. 如果中间元素正好是目标值，则搜索成功。
    
2. 如果目标值比中间元素==小==，则在==左半部分==继续查找。
    
3. 如果目标值比中间元素==大==，则在==右半部分==继续查找。
    
4. 重复以上步骤，直到找到目标或搜索范围为空。


## 2.算法复杂度

与线性搜索（按顺序一个一个找）相比，二分搜索在处理大数据集时优势巨大。

- **时间复杂度：** $O(\log n)$
    
    - 例如：在 100 万个数据中查找，线性搜索最多需要 100 万次，而二分搜索最多只需约 20 次。
        
- **空间复杂度：** * 迭代法：$O(1)$
    
    - 递归法：$O(\log n)$（受递归栈深度影响）
---

## 3. 使用前提与注意事项

- **是否有序：** 使用二分搜索大多情况数组得是有序的（升序或降序）。如果数组无序，需要根据题目条件考虑是否进行排序，而排序的成本通常是 $O(n \log n)$，有时不需要排序。总之，分析题目==单调性==才是使用二分搜索的依据，也是我们分析问题的重点。
    
- **查找范围：** 注意边界条件（如 `low <= high`）以及中间值的计算，防止在某些编程语言中出现整数溢出（例如使用 `low + (high - low) / 2`或者`low+((high-low)>>1)` 更安全）。
---

# 经典例题

## 1.序数组上的二分搜索

### 在有序数组中确定num存在还是不存在

[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)

> 这是二分搜索最经典的例题，也是二分最简单的应用。

**查找范围：** l<=r

**单调性分析：** 由于数组是有序的，所以对于数组上的任意一个数字，==它的左边的数字一定比它小，右边的数组一定比它大==。

**查找策略：** 
1. 每次查找边界（l-r)的中值`nums[m]`
	- 如果`nums[m]`等于target，找到了target，则==返回中值索引m==
	- 如果`nums[m]`大于target，说明target一定在`nums[m]`左边，==缩小右边界==`r=m-1`
	- 如果`nums[m]`小于target，说明target一定在`nums[m]`右边，==缩小左边界==`l=m+1`
2. 若是l>r，则说明找不到，返回==-1==


```cpp
class Solution {

public:

    int search(vector<int>& nums, int target) {

        for (int l = 0, r = nums.size() - 1, m; l <= r;) {

            m = l + (r - l) / 2;

            if (nums[m] == target) return m;

            else if (nums[m] > target)r = m - 1;

            else l = m + 1;

        }

        return -1;

    }

};
```

---
### 在有序数组中找>=num的最左位置

[35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/description/)

> 这是查找存在num是否存在的变形，在每次查找时，除了缩小边界范围，还增加了==记录答案==这一操作，这也是寻找答案的一个重要操作。这在算法中常被称为 **Lower Bound**（下界）。

**查找范围：** l<=r

**单调性分析：** 由于数组是有序的，所以对于数组上的任意一个数字，==它的左边的数字一定比它小，右边的数组一定比它大==。

**查找策略：** 
1. ==初始化答案`ans=nums.size()`==，当找不到>=target的最左位置时，说明数组所有数都比target小，返回插入的索引值`nums.size()`
 2. 每次查找边界（l-r）的中值`nums[m]`
	- 如果`nums[m]`大于等于target，说明target要么在`nums[m]`左边，要么等于`nums[m]`，==此时记录答案==`ans=m`，==缩小右边界==`r=m-1`
	- 如果`nums[m]`小于target，说明target一定在`nums[m]`右边，==缩小左边界==`l=m+1`


```
class Solution {

public:

    int searchInsert(vector<int>& nums, int target) {

        int ans =nums.size(), m=-1;

        for (int l = 0, r = nums.size() - 1; l <= r;) {

            m = l + (r - l) / 2;

            if (nums[m] >= target) {

                ans = m;

                r = m - 1;

            }

            else l = m + 1;

        }

        return ans;

    }

};
```

---
### 在有序数组中找<=num的最右位置

[34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

> 逻辑和寻找$\ge num$相似但条件==相反==，这是常用于寻找 **Upper Bound** 的变体。

 **查找范围：** `l <= r`

**单调性分析：** 

由于数组是非递减有序的，相同的数字会排列在一起。

- 寻找**最左位置**：当找到 `nums[m] == target` 时，左边可能还有相等的数，需向左收缩。
    
- 寻找**最右位置**：当找到 `nums[m] == target` 时，右边可能还有相等的数，需向右收缩。

**查找策略：**

 1. 寻找左边界 (First Position)

- **初始化答案：** `leftAns = -1`。
    
- **策略：**
    
    - 如果 `nums[m] >= target`：说明左边可能还有 `target` 或者当前就是第一个。
        
        > **记录答案** `leftAns = m`，**缩小右边界** `r = m - 1`。
        
    - 如果 `nums[m] < target`：说明 `target` 在右边。
        
        > **缩小左边界** `l = m + 1`。
        

 2. 寻找右边界 (Last Position)

- **初始化答案：** `rightAns = -1`。
    
- **策略：**
    
    - 如果 `nums[m] <= target`：说明右边可能还有 `target` 或者当前就是最后一个。
        
        > **记录答案** `rightAns = m`，**缩小左边界** `l = m + 1`。
        
    - 如果 `nums[m] > target`：说明 `target` 在左边。
        
        > **缩小右边界** `r = m - 1`。

```cpp
class Solution { 
public:
    int binarySearch(vector<int>& nums, int target, bool lower) {
        int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target || (lower && nums[mid] >= target)) {
                right = mid - 1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        int leftIdx = binarySearch(nums, target, true);
        int rightIdx = binarySearch(nums, target, false) - 1;
        if (leftIdx <= rightIdx && rightIdx < nums.size() && nums[leftIdx] == target && nums[rightIdx] == target) {
            return vector<int>{leftIdx, rightIdx};
        } 
        return vector<int>{-1, -1};
    }
};
```

## 2.无序数组上的二分搜索

[162. 寻找峰值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-peak-element/description/)

> 虽然数组整体是**无序**的，但题目要求查找的是“峰值”（比左右邻居都大的元素）。通过比较相邻元素，我们可以发现局部区域存在**单调性趋势**，从而利用二分搜索在 $O(\log n)$ 时间内找到其中一个峰值。

 **查找范围：**`l <= r`

 **单调性分析：**

由于题目假设 $nums[-1] = nums[n] = -\infty$，且相邻元素不相等，数组在任意位置 `m` 只有两种趋势：

1. **处于“上坡”路段：** 如果 `nums[m] < nums[m + 1]`，说明右侧一定存在更高点，即==峰值在右边==。
    
2. **处于“下坡”路段：** 如果 `nums[m] > nums[m + 1]`，说明左侧一定存在更高点（或者当前 `m` 就是峰值），即==峰值在左边==。
    
> **核心逻辑：** 这种“局部单调性”引导我们向更高的方向走，最终一定会遇到一个峰值。

---

**查找策略：**

- **初始化答案：** `ans = 0`。
    
- **边界处理：** 如果数组长度为 1，直接返回 0。
    
    - 优先判断首尾是否为峰值（如 `nums[0] > nums[1]`）。
        
- **二分过程：**
    
    - 取中点 `m`，比较它与相邻元素的关系。
        
    - ==如果 `nums[m] < nums[m - 1]`：==
        
        > 说明左侧更高，处于下坡，==缩小右边界== `r = m - 1`。
        
    - ==否则如果 `nums[m] < nums[m + 1]`：==
        
        > 说明右侧更高，处于上坡，==缩小左边界== `l = m + 1`。
        
    - ==否则：==
        
        > `nums[m]` 既大于左边也大于右边，==记录答案== `ans = m` 并 `break`。
        

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size();
        // 特殊情况处理
        if (n == 1) return 0;
        if (nums[0] > nums[1]) return 0;
        if (nums[n - 1] > nums[n - 2]) return n - 1;

        int l = 1, r = n - 2, ans = 0;
        while (l <= r) {
            int m = l + (r - l) / 2;
            // 局部单调性判断
            if (nums[m] < nums[m - 1]) {
                r = m - 1; // 往高处走，向左找
            } else if (nums[m] < nums[m + 1]) {
                l = m + 1; // 往高处走，向右找
            } else {
                ans = m;   // 找到峰值
                break;
            }
        }
        return ans;
    }
};
```

---
[33. 搜索旋转排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)