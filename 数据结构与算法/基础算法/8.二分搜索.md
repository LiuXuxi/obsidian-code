> [!ABSTRACT]
> 二分搜索（Binary Search）是一种在**有序数组**中查找特定元素的效率极高的算法。它的核心思想是“折半查找”，通过不断缩小搜索范围来定位目标。

[TOC]
# 1. 基本原理

## 1.搜索原理

二分搜索每次都会查看搜索范围的正中间元素：

1. 如果中间元素正好是目标值，则搜索成功。
    
2. 如果目标值比中间元素==小==，则在==左半部分==继续查找。
    
3. 如果目标值比中间元素==大==，则在==右半部分==继续查找。
    
4. 重复以上步骤，直到找到目标或搜索范围为空。


## 2.算法复杂度

与线性搜索（按顺序一个一个找）相比，二分搜索在处理大数据集时优势巨大。

- **时间复杂度：** $O(\log n)$
    
    - 例如：在 100 万个数据中查找，线性搜索最多需要 100 万次，而二分搜索最多只需约 20 次。
        
- **空间复杂度：** * 迭代法：$O(1)$
    
    - 递归法：$O(\log n)$（受递归栈深度影响）
---

## 3. 使用前提与注意事项

- **是否有序：** 使用二分搜索大多情况数组得是有序的（升序或降序）。如果数组无序，需要根据题目条件考虑是否进行排序，而排序的成本通常是 $O(n \log n)$，有时不需要排序。总之，分析题目==单调性==才是使用二分搜索的依据，也是我们分析问题的重点。
    
- **查找范围：** 注意边界条件（如 `low <= high`）以及中间值的计算，防止在某些编程语言中出现整数溢出（例如使用 `low + (high - low) / 2`或者`low+((high-low)>>1)` 更安全）。
---

# 2.经典例题

## 1.序数组上的二分搜索

### 在有序数组中确定num存在还是不存在

[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)

> 这是二分搜索最经典的例题，也是二分最简单的应用。

**查找范围：** l<=r

**单调性分析：** 由于数组是有序的，所以对于数组上的任意一个数字，==它的左边的数字一定比它小，右边的数组一定比它大==。

**查找策略：** 
1. 每次查找边界（l-r)的中值`nums[m]`
	- 如果`nums[m]`等于target，找到了target，则==返回中值索引m==
	- 如果`nums[m]`大于target，说明target一定在`nums[m]`左边，==缩小右边界==`r=m-1`
	- 如果`nums[m]`小于target，说明target一定在`nums[m]`右边，==缩小左边界==`l=m+1`
2. 若是l>r，则说明找不到，返回==-1==


```cpp
class Solution {

public:

    int search(vector<int>& nums, int target) {

        for (int l = 0, r = nums.size() - 1, m; l <= r;) {

            m = l + (r - l) / 2;

            if (nums[m] == target) return m;

            else if (nums[m] > target)r = m - 1;

            else l = m + 1;

        }

        return -1;

    }

};
```

---
### 在有序数组中找>=num的最左位置

[35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/description/)

> 这是查找存在num是否存在的变形，在每次查找时，除了缩小边界范围，还增加了==记录答案==这一操作，这也是寻找答案的一个重要操作。这在算法中常被称为 **Lower Bound**（下界）。

**查找范围：** l<=r

**单调性分析：** 由于数组是有序的，所以对于数组上的任意一个数字，==它的左边的数字一定比它小，右边的数组一定比它大==。

**查找策略：** 
1. ==初始化答案`ans=nums.size()`==，当找不到>=target的最左位置时，说明数组所有数都比target小，返回插入的索引值`nums.size()`
 2. 每次查找边界（l-r）的中值`nums[m]`
	- 如果`nums[m]`大于等于target，说明target要么在`nums[m]`左边，要么等于`nums[m]`，==此时记录答案==`ans=m`，==缩小右边界==`r=m-1`
	- 如果`nums[m]`小于target，说明target一定在`nums[m]`右边，==缩小左边界==`l=m+1`


```
class Solution {

public:

    int searchInsert(vector<int>& nums, int target) {

        int ans =nums.size(), m=-1;

        for (int l = 0, r = nums.size() - 1; l <= r;) {

            m = l + (r - l) / 2;

            if (nums[m] >= target) {

                ans = m;

                r = m - 1;

            }

            else l = m + 1;

        }

        return ans;

    }

};
```

---
### 在有序数组中找<=num的最右位置

[34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

> 逻辑和寻找$\ge num$相似但条件==相反==，这是常用于寻找 **Upper Bound** 的变体。

 **查找范围：** `l <= r`

**单调性分析：** 

由于数组是非递减有序的，相同的数字会排列在一起。

- 寻找**最左位置**：当找到 `nums[m] == target` 时，左边可能还有相等的数，需向左收缩。
    
- 寻找**最右位置**：当找到 `nums[m] == target` 时，右边可能还有相等的数，需向右收缩。

**查找策略：**

 1. 寻找左边界 (First Position)

- **初始化答案：** `leftAns = -1`。
    
- **策略：**
    
    - 如果 `nums[m] >= target`：说明左边可能还有 `target` 或者当前就是第一个。
        
        > **记录答案** `leftAns = m`，**缩小右边界** `r = m - 1`。
        
    - 如果 `nums[m] < target`：说明 `target` 在右边。
        
        > **缩小左边界** `l = m + 1`。
        

 2. 寻找右边界 (Last Position)

- **初始化答案：** `rightAns = -1`。
    
- **策略：**
    
    - 如果 `nums[m] <= target`：说明右边可能还有 `target` 或者当前就是最后一个。
        
        > **记录答案** `rightAns = m`，**缩小左边界** `l = m + 1`。
        
    - 如果 `nums[m] > target`：说明 `target` 在左边。
        
        > **缩小右边界** `r = m - 1`。

```cpp
class Solution { 
public:
    int binarySearch(vector<int>& nums, int target, bool lower) {
        int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target || (lower && nums[mid] >= target)) {
                right = mid - 1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        int leftIdx = binarySearch(nums, target, true);
        int rightIdx = binarySearch(nums, target, false) - 1;
        if (leftIdx <= rightIdx && rightIdx < nums.size() && nums[leftIdx] == target && nums[rightIdx] == target) {
            return vector<int>{leftIdx, rightIdx};
        } 
        return vector<int>{-1, -1};
    }
};
```

## 2.无序数组上的二分搜索

### 1.局部爬坡优势

[162. 寻找峰值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-peak-element/description/)

> 虽然数组整体是**无序**的，但题目要求查找的是“峰值”（比左右邻居都大的元素）。通过比较相邻元素，我们可以发现局部区域存在**单调性趋势**，从而利用二分搜索在 $O(\log n)$ 时间内找到其中一个峰值。

 **查找范围：**`l <= r`

 **单调性分析：**

由于题目假设 $nums[-1] = nums[n] = -\infty$，且相邻元素不相等，数组在任意位置 `m` 只有两种趋势：

1. **处于“上坡”路段：** 如果 `nums[m] < nums[m + 1]`，说明右侧一定存在更高点，即==峰值在右边==。
    
2. **处于“下坡”路段：** 如果 `nums[m] > nums[m + 1]`，说明左侧一定存在更高点（或者当前 `m` 就是峰值），即==峰值在左边==。
    
> **核心逻辑：** 这种“局部单调性”引导我们向更高的方向走，最终一定会遇到一个峰值。


**查找策略：**

- **初始化答案：** `ans = 0`。
    
- **边界处理：** 如果数组长度为 1，直接返回 0。
    
    - 优先判断首尾是否为峰值（如 `nums[0] > nums[1]`）。
        
- **二分过程：**
    
    - 取中点 `m`，比较它与相邻元素的关系。
        
    - ==如果 `nums[m] < nums[m - 1]`：==
        
        > 说明左侧更高，处于下坡，==缩小右边界== `r = m - 1`。
        
    - ==否则如果 `nums[m] < nums[m + 1]`：==
        
        > 说明右侧更高，处于上坡，==缩小左边界== `l = m + 1`。
        
    - ==否则：==
        
        > `nums[m]` 既大于左边也大于右边，==记录答案== `ans = m` 并 `break`。
        

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size();
        // 特殊情况处理
        if (n == 1) return 0;
        if (nums[0] > nums[1]) return 0;
        if (nums[n - 1] > nums[n - 2]) return n - 1;

        int l = 1, r = n - 2, ans = 0;
        while (l <= r) {
            int m = l + (r - l) / 2;
            // 局部单调性判断
            if (nums[m] < nums[m - 1]) {
                r = m - 1; // 往高处走，向左找
            } else if (nums[m] < nums[m + 1]) {
                l = m + 1; // 往高处走，向右找
            } else {
                ans = m;   // 找到峰值
                break;
            }
        }
        return ans;
    }
};
```

---

### 2.分段有序

[33. 搜索旋转排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)

> 数组虽然被旋转了（例如 `[4,5,6,7,0,1,2]`），但它依然是由两个有序段组成的。在任何一个断点进行二分，**左右两边至少有一半是有序的**。我们可以利用这一半的有序性来缩小搜索范围。

**查找范围：**`l <= r`

**单调性分析：**

对于区间 `[l, r]` 和中点 `m`：

1. **左半段有序：** 如果 `nums[l] <= nums[m]`，说明 `[l, m]` 这一段是递增的。
    
    - 如果 `target` 落在 `[nums[l], nums[m])` 之间，则去左边找；否则去右边。
        
2. **右半段有序：** 如果 `nums[l] > nums[m]`，说明断点在左侧，那么右半段 `[m, r]` 必定是递增的。
    
    - 如果 `target` 落在 `(nums[m], nums[r]]` 之间，则去右边找；否则去左边。
        

> **核心逻辑：** 先确定哪一半是有序的，再根据有序段的范围判断 `target` 是否在其中，从而决定舍弃哪一半。

**查找策略：**

- **初始化答案：** `ans = -1`（未找到时的默认值）。
    
- **二分过程：**
    
    - 如果 `nums[m] == target`，直接记录 `ans = m` 并 `break`。
        
    - **判断左半部分是否有序 (`nums[l] <= nums[m]`)：**
        
        - 如果 `target` 在左半部分范围内，则收缩右边界 `r = m - 1`。
            
        - 否则，去右半部分找 `l = m + 1`。
            
    - **否则（右半部分必定有序）：**
        
        - 如果 `target` 在右半部分范围内，则收缩左边界 `l = m + 1`。
            
        - 否则，去左半部分找 `r = m - 1`。
            

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        
        while (l <= r) {
            int m = l + (r - l) / 2;
            if (nums[m] == target) return m;

            // 1. 判断左半部分是否有序
            if (nums[l] <= nums[m]) {
                // target 落在左侧有序区间内
                if (target >= nums[l] && target < nums[m]) {
                    r = m - 1;
                } else {
                    l = m + 1;
                }
            } 
            // 2. 否则右半部分必定有序
            else {
                // target 落在右侧有序区间内
                if (target > nums[m] && target <= nums[r]) {
                    l = m + 1;
                } else {
                    r = m - 1;
                }
            }
        }
        return -1;
    }
};
```

---

[81. 搜索旋转排序数组 II - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/)

>这是第 33 题的升级版，也是面试中常用来考察思维严谨性的题目。
>**挑战点：** 当 `nums[l] == nums[m] == nums[r]` 时，我们无法判断哪一半是有序的。例如 `[1, 0, 1, 1, 1]` 和 `[1, 1, 1, 0, 1]`，中点和两头相等，目标值 `0` 可能在左也可能在右。

**查找范围：**`l <= r`

**单调性分析：**

由于存在重复元素，原本通过 `nums[l] <= nums[m]` 判断左半部分有序的逻辑会因“相等”而失效。

- **特殊情况：** 如果 `nums[l] == nums[m]` 且 `nums[m] == nums[r]`。
    
    > **处理策略：** 此时无法排除任何一半，只能简单地让 `l++` 和 `r--`，缩小范围后再继续二分。
    
- **其余情况：** 依然遵循第 33 题的逻辑，通过比较确定哪一段是有序的。
    


**查找策略：**

- **初始化答案：** `false`（题目要求返回布尔值）。
    
- **二分过程：**
    
    1. 如果 `nums[m] == target`，返回 `true`。
        
    2. **去重缩距（核心）：** 如果 `nums[l] == nums[m] && nums[m] == nums[r]`：
        
        > 执行 `l++; r--;`。
        
    3. **判断左半部分是否有序：**
        
        - 如果 `nums[l] <= nums[m]`：
            
            - `target` 在 `[nums[l], nums[m])` 之间，则 `r = m - 1`。
                
            - 否则 `l = m + 1`。
                
    4. **判断右半部分是否有序：**
        
        - 否则（右半部分有序）：
            
            - `target` 在 `(nums[m], nums[r]]` 之间，则 `l = m + 1`。
                
            - 否则 `r = m - 1`。

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        
        while (l <= r) {
            int m = l + (r - l) / 2;
            if (nums[m] == target) return true;

            // 核心：处理无法判断有序性的特殊情况
            if (nums[l] == nums[m] && nums[m] == nums[r]) {
                l++;
                r--;
            }
            // 剩下的逻辑同第 33 题
            else if (nums[l] <= nums[m]) {                                                                                                                                                                                                                                                                  
                if (target >= nums[l] && target < nums[m]) r = m - 1;      
                else l = m + 1;      
            }       else {      
                if (target > nums[m] && target <= nums[r]) l = m + 1;      
                else r = m - 1;      
            }
        }
        return false;      
    }
};
```

# 3.进阶应用-二分答案法

普通的二分搜索是在**数据**（数组）中找目标值，而二分答案是在**可能的解的范围**（答案空间）中找最优解。

## 1.什么是二分答案？

> 有些问题的目标不是找一个存在的数，而是求一个**满足条件的最小值**或**最大值**。如果随着“答案”的增加，问题满足条件的可能性具有**单调性**（例如：答案越小越容易满足，答案越大越难满足），那就可以二分这个“答案”。

## 2.二分策略

**核心点：** 分析单调性、建立f函数。

1. 估计==最终答案可能的范围==是什么
2. 分析==问题的答案==和==给定条件==之间的==单调性==
3. 建立一个check函数，==当答案固定的情况下==，判断==给定的条件是否达标==
4. 在==最终答案可能的范围上不断二分搜索==，每次用check函数判断，直到二分结束，==找到最合适的答案==

## 3.题目训练

[875. 爱吃香蕉的珂珂 - 力扣（LeetCode）](https://leetcode.cn/problems/koko-eating-bananas/submissions/687358078/?envType=problem-list-v2&envId=binary-search)

1. **答案空间（$k$ 的范围）：** 最小每小时吃 1 根，最大每小时吃掉最大一堆的数量。
    
2. **单调性分析：**
    
    - 如果每小时吃 $k$ 根能吃完，那么吃 $k+1$ 根一定也能吃完（速度越快越容易吃完）。
        
        *我们要找的是满足条件的最小 $k$，这本质上就是找 “$\ge$ 满足条件的最左位置”。*
        
1. **`check(k)` 函数：** 遍历所有堆，计算以速度 $k$ 吃完总共需要多少小时，看是否 $\le h$。

```cpp
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        int l = 1, r = *max_element(piles.begin(), piles.end());
        int ans = r;

        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (check(piles, h, mid)) {
                ans = mid;    // mid 速度可行，记录下来
                r = mid - 1;  // 尝试更小的速度
            } else {
                l = mid + 1;  // mid 速度太慢，必须加速
            }
        }
        return ans;
    }

private:
    bool check(vector<int>& piles, int h, int k) {
        long hours = 0;
        for (int p : piles) {
            // 计算当前堆需要的小时数（向上取整）
            hours += (p + k - 1) / k;
        }
        return hours <= h;
    }
};
```

[410. 分割数组的最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/split-array-largest-sum/description/?envType=problem-list-v2&envId=binary-search)      

. **答案空间：** 当数组全为0时答案==最小为0==，当$k$为1时，答案==最大为数组元素之和==
    
2. **单调性分析：**
> 当
3. **`check(k)` 函数：** 遍历所有数组进行数组分割，计算在分割数组的和==不超过==$sum$的情况==最少==要分割成多少个数组，用$cnt$记录并返回

```cpp
class Solution {

public:

    int splitArray(vector<int>& nums, int k) {

        int ans = 0;

        long sum = 0;

        for (auto& i : nums)sum += i;

        for (long l = 0, r = sum, m; l <= r;) {

            m = l + (r - l) / 2;

            if (check(nums, m) <= k) {

                ans = m;

                r = m - 1;

            }

            else l = m + 1;

        }

        return ans;

    }

  

    int check(vector<int>nums, int sum) {

        int cnt = 1;

        for (int i = 0,add=0; i < nums.size(); i++) {

            if(nums[i]>sum)return INT_MAX;

            add += nums[i];

            if (add > sum) {

                ++cnt;

                add = nums[i];

            }

        }

        return cnt;

    }

};
```