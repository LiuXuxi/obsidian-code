> [!ABSTRACT]
> 二分搜索（Binary Search）是一种在**有序数组**中查找特定元素的效率极高的算法。它的核心思想是“折半查找”，通过不断缩小搜索范围来定位目标。

# 1. 基本原理

## 1.搜索原理

二分搜索每次都会查看搜索范围的正中间元素：

1. 如果中间元素正好是目标值，则搜索成功。
    
2. 如果目标值比中间元素**小**，则在**左半部分**继续查找。
    
3. 如果目标值比中间元素**大**，则在**右半部分**继续查找。
    
4. 重复以上步骤，直到找到目标或搜索范围为空。


## 2.算法复杂度

与线性搜索（按顺序一个一个找）相比，二分搜索在处理大数据集时优势巨大。

- **时间复杂度：** $O(\log n)$
    
    - 例如：在 100 万个数据中查找，线性搜索最多需要 100 万次，而二分搜索最多只需约 20 次。
        
- **空间复杂度：** * 迭代法：$O(1)$
    
    - 递归法：$O(\log n)$（受递归栈深度影响）

## 3. 使用前提与注意事项

- **是否有序：** 使用二分搜索大多情况数组得是有序的（升序或降序）。如果数组无序，需要根据题目条件考虑是否进行排序，而排序的成本通常是 $O(n \log n)$，有时不需要排序。总之，分析题目==单调性==才是使用二分搜索的依据，也是我们分析问题的重点。
    
- **查找范围：** 注意边界条件（如 `low <= high`）以及中间值的计算，防止在某些编程语言中出现整数溢出（例如使用 `low + (high - low) / 2`或者`low+((high-low)>>1)` 更安全）。
---

# 经典例题

## 1.序数组上的二分搜索

### 在有序数组中确定num存在还是不存在

[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)

> 这是二分搜索最经典的例题，也是二分最简单的应用。

**查找范围：** l<=r

**单调性分析：** 由于数组是有序的，所以对于数组上的任意一个数字，==它的左边的数字一定比它小，右边的数组一定比它大==。

**查找策略：** 
1. 每次查找边界（l-r)的中值`nums[m]`
	- 如果`nums[m]`等于target，找到了target，则==返回中值索引m==
	- 如果`nums[m]`大于target，说明target一定在`nums[m]`左边，==缩小右边界==`r=m-1`
	- 如果`nums[m]`小于target，说明target一定在`nums[m]`右边，==缩小左边界==`l=m+1`
2. 若是l>r，则说明找不到，返回==-1==


```cpp
class Solution {

public:

    int search(vector<int>& nums, int target) {

        for (int l = 0, r = nums.size() - 1, m; l <= r;) {

            m = l + (r - l) / 2;

            if (nums[m] == target) return m;

            else if (nums[m] > target)r = m - 1;

            else l = m + 1;

        }

        return -1;

    }

};
```

### 在有序数组中找>=num的最左位置

[35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/description/)

> 这是查找存在num是否存在的变形，在每次查找时，除了缩小边界范围，还增加了==记录答案==这一操作，这也是寻找答案的一个重要操作。

**查找范围：** l<=r

**单调性分析：** 由于数组是有序的，所以对于数组上的任意一个数字，==它的左边的数字一定比它小，右边的数组一定比它大==。

**查找策略：** 

1. 每次查找边界（l-r）的中值`nums[m]`
	- 如果`nums[m]`大于等于target，说明target一定在`nums[m]`左边，==缩小右边界==`r=m-1`
	- 如果`nums[m]`小于target，说明target一定在`nums[m]`右边，==缩小左边界==`l=m+1`
2. 若是l>r，则说明找不到，返回==-1==


```cpp
class Solution {

public:

    int searchInsert(vector<int>& nums, int target) {

        int ans =nums.size(), m=-1;

        for (int l = 0, r = nums.size() - 1; l <= r;) {

            m = l + (r - l) / 2;

            if (nums[m] >= target) {

                ans = m;

                r = m - 1;

            }

            else l = m + 1;

        }

        return ans;

    }

};
```

### 在有序数组中找<=num的最右位置

[34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

## 2.无序数组上的二分搜索

