> [!ABSTRACT]
> 二分搜索（Binary Search）是一种在**有序数组**中查找特定元素的效率极高的算法。它的核心思想是“折半查找”，通过不断缩小搜索范围来定位目标。

[TOC]
# 1. 基本原理

## 1.搜索原理

二分搜索每次都会查看搜索范围的正中间元素：

1. 如果中间元素正好是目标值，则搜索成功。
    
2. 如果目标值比中间元素==小==，则在==左半部分==继续查找。
    
3. 如果目标值比中间元素==大==，则在==右半部分==继续查找。
    
4. 重复以上步骤，直到找到目标或搜索范围为空。


## 2.算法复杂度

与线性搜索（按顺序一个一个找）相比，二分搜索在处理大数据集时优势巨大。

- **时间复杂度：** $O(\log n)$
    
    - 例如：在 100 万个数据中查找，线性搜索最多需要 100 万次，而二分搜索最多只需约 20 次。
        
- **空间复杂度：** * 迭代法：$O(1)$
    
    - 递归法：$O(\log n)$（受递归栈深度影响）
---

## 3. 使用前提与注意事项

- **是否有序：** 使用二分搜索大多情况数组得是有序的（升序或降序）。如果数组无序，需要根据题目条件考虑是否进行排序，而排序的成本通常是 $O(n \log n)$，有时不需要排序。总之，分析题目==单调性==才是使用二分搜索的依据，也是我们分析问题的重点。
    
- **查找范围：** 注意边界条件（如 `low <= high`）以及中间值的计算，防止在某些编程语言中出现整数溢出（例如使用 `low + (high - low) / 2`或者`low+((high-low)>>1)` 更安全）。
---

# 2.经典例题

## 1.序数组上的二分搜索

### 在有序数组中确定num存在还是不存在

[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)

> 这是二分搜索最经典的例题，也是二分最简单的应用。

**查找范围：** l<=r

**单调性分析：** 由于数组是有序的，所以对于数组上的任意一个数字，==它的左边的数字一定比它小，右边的数组一定比它大==。

**查找策略：** 
1. 每次查找边界（l-r)的中值`nums[m]`
	- 如果`nums[m]`等于target，找到了target，则==返回中值索引m==
	- 如果`nums[m]`大于target，说明target一定在`nums[m]`左边，==缩小右边界==`r=m-1`
	- 如果`nums[m]`小于target，说明target一定在`nums[m]`右边，==缩小左边界==`l=m+1`
2. 若是l>r，则说明找不到，返回==-1==


```cpp
class Solution {

public:

    int search(vector<int>& nums, int target) {

        for (int l = 0, r = nums.size() - 1, m; l <= r;) {

            m = l + (r - l) / 2;

            if (nums[m] == target) return m;

            else if (nums[m] > target)r = m - 1;

            else l = m + 1;

        }

        return -1;

    }

};
```

---
### 在有序数组中找>=num的最左位置

[35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/description/)

> 这是查找存在num是否存在的变形，在每次查找时，除了缩小边界范围，还增加了==记录答案==这一操作，这也是寻找答案的一个重要操作。这在算法中常被称为 **Lower Bound**（下界）。

**查找范围：** l<=r

**单调性分析：** 由于数组是有序的，所以对于数组上的任意一个数字，==它的左边的数字一定比它小，右边的数组一定比它大==。

**查找策略：** 
1. ==初始化答案`ans=nums.size()`==，当找不到>=target的最左位置时，说明数组所有数都比target小，返回插入的索引值`nums.size()`
 2. 每次查找边界（l-r）的中值`nums[m]`
	- 如果`nums[m]`大于等于target，说明target要么在`nums[m]`左边，要么等于`nums[m]`，==此时记录答案==`ans=m`，==缩小右边界==`r=m-1`
	- 如果`nums[m]`小于target，说明target一定在`nums[m]`右边，==缩小左边界==`l=m+1`


```
class Solution {

public:

    int searchInsert(vector<int>& nums, int target) {

        int ans =nums.size(), m=-1;

        for (int l = 0, r = nums.size() - 1; l <= r;) {

            m = l + (r - l) / 2;

            if (nums[m] >= target) {

                ans = m;

                r = m - 1;

            }

            else l = m + 1;

        }

        return ans;

    }

};
```

---
### 在有序数组中找<=num的最右位置

[34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

> 逻辑和寻找$\ge num$相似但条件==相反==，这是常用于寻找 **Upper Bound** 的变体。

 **查找范围：** `l <= r`

**单调性分析：** 

由于数组是非递减有序的，相同的数字会排列在一起。

- 寻找**最左位置**：当找到 `nums[m] == target` 时，左边可能还有相等的数，需向左收缩。
    
- 寻找**最右位置**：当找到 `nums[m] == target` 时，右边可能还有相等的数，需向右收缩。

**查找策略：**

 1. 寻找左边界 (First Position)

- **初始化答案：** `leftAns = -1`。
    
- **策略：**
    
    - 如果 `nums[m] >= target`：说明左边可能还有 `target` 或者当前就是第一个。
        
        > **记录答案** `leftAns = m`，**缩小右边界** `r = m - 1`。
        
    - 如果 `nums[m] < target`：说明 `target` 在右边。
        
        > **缩小左边界** `l = m + 1`。
        

 2. 寻找右边界 (Last Position)

- **初始化答案：** `rightAns = -1`。
    
- **策略：**
    
    - 如果 `nums[m] <= target`：说明右边可能还有 `target` 或者当前就是最后一个。
        
        > **记录答案** `rightAns = m`，**缩小左边界** `l = m + 1`。
        
    - 如果 `nums[m] > target`：说明 `target` 在左边。
        
        > **缩小右边界** `r = m - 1`。

```cpp
class Solution { 
public:
    int binarySearch(vector<int>& nums, int target, bool lower) {
        int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target || (lower && nums[mid] >= target)) {
                right = mid - 1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        int leftIdx = binarySearch(nums, target, true);
        int rightIdx = binarySearch(nums, target, false) - 1;
        if (leftIdx <= rightIdx && rightIdx < nums.size() && nums[leftIdx] == target && nums[rightIdx] == target) {
            return vector<int>{leftIdx, rightIdx};
        } 
        return vector<int>{-1, -1};
    }
};
```

## 2.无序数组上的二分搜索

### 1.局部爬坡优势

[162. 寻找峰值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-peak-element/description/)

> 虽然数组整体是**无序**的，但题目要求查找的是“峰值”（比左右邻居都大的元素）。通过比较相邻元素，我们可以发现局部区域存在**单调性趋势**，从而利用二分搜索在 $O(\log n)$ 时间内找到其中一个峰值。

 **查找范围：**`l <= r`

 **单调性分析：**

由于题目假设 $nums[-1] = nums[n] = -\infty$，且相邻元素不相等，数组在任意位置 `m` 只有两种趋势：

1. **处于“上坡”路段：** 如果 `nums[m] < nums[m + 1]`，说明右侧一定存在更高点，即==峰值在右边==。
    
2. **处于“下坡”路段：** 如果 `nums[m] > nums[m + 1]`，说明左侧一定存在更高点（或者当前 `m` 就是峰值），即==峰值在左边==。
    
> **核心逻辑：** 这种“局部单调性”引导我们向更高的方向走，最终一定会遇到一个峰值。


**查找策略：**

- **初始化答案：** `ans = 0`。
    
- **边界处理：** 如果数组长度为 1，直接返回 0。
    
    - 优先判断首尾是否为峰值（如 `nums[0] > nums[1]`）。
        
- **二分过程：**
    
    - 取中点 `m`，比较它与相邻元素的关系。
        
    - ==如果 `nums[m] < nums[m - 1]`：==
        
        > 说明左侧更高，处于下坡，==缩小右边界== `r = m - 1`。
        
    - ==否则如果 `nums[m] < nums[m + 1]`：==
        
        > 说明右侧更高，处于上坡，==缩小左边界== `l = m + 1`。
        
    - ==否则：==
        
        > `nums[m]` 既大于左边也大于右边，==记录答案== `ans = m` 并 `break`。
        

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size();
        // 特殊情况处理
        if (n == 1) return 0;
        if (nums[0] > nums[1]) return 0;
        if (nums[n - 1] > nums[n - 2]) return n - 1;

        int l = 1, r = n - 2, ans = 0;
        while (l <= r) {
            int m = l + (r - l) / 2;
            // 局部单调性判断
            if (nums[m] < nums[m - 1]) {
                r = m - 1; // 往高处走，向左找
            } else if (nums[m] < nums[m + 1]) {
                l = m + 1; // 往高处走，向右找
            } else {
                ans = m;   // 找到峰值
                break;
            }
        }
        return ans;
    }
};
```

---

### 2.分段有序

[33. 搜索旋转排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)

> 数组虽然被旋转了（例如 `[4,5,6,7,0,1,2]`），但它依然是由两个有序段组成的。在任何一个断点进行二分，**左右两边至少有一半是有序的**。我们可以利用这一半的有序性来缩小搜索范围。

**查找范围：**`l <= r`

**单调性分析：**

对于区间 `[l, r]` 和中点 `m`：

1. **左半段有序：** 如果 `nums[l] <= nums[m]`，说明 `[l, m]` 这一段是递增的。
    
    - 如果 `target` 落在 `[nums[l], nums[m])` 之间，则去左边找；否则去右边。
        
2. **右半段有序：** 如果 `nums[l] > nums[m]`，说明断点在左侧，那么右半段 `[m, r]` 必定是递增的。
    
    - 如果 `target` 落在 `(nums[m], nums[r]]` 之间，则去右边找；否则去左边。
        

> **核心逻辑：** 先确定哪一半是有序的，再根据有序段的范围判断 `target` 是否在其中，从而决定舍弃哪一半。

**查找策略：**

- **初始化答案：** `ans = -1`（未找到时的默认值）。
    
- **二分过程：**
    
    - 如果 `nums[m] == target`，直接记录 `ans = m` 并 `break`。
        
    - **判断左半部分是否有序 (`nums[l] <= nums[m]`)：**
        
        - 如果 `target` 在左半部分范围内，则收缩右边界 `r = m - 1`。
            
        - 否则，去右半部分找 `l = m + 1`。
            
    - **否则（右半部分必定有序）：**
        
        - 如果 `target` 在右半部分范围内，则收缩左边界 `l = m + 1`。
            
        - 否则，去左半部分找 `r = m - 1`。
            

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        
        while (l <= r) {
            int m = l + (r - l) / 2;
            if (nums[m] == target) return m;

            // 1. 判断左半部分是否有序
            if (nums[l] <= nums[m]) {
                // target 落在左侧有序区间内
                if (target >= nums[l] && target < nums[m]) {
                    r = m - 1;
                } else {
                    l = m + 1;
                }
            } 
            // 2. 否则右半部分必定有序
            else {
                // target 落在右侧有序区间内
                if (target > nums[m] && target <= nums[r]) {
                    l = m + 1;
                } else {
                    r = m - 1;
                }
            }
        }
        return -1;
    }
};
```


---

[81. 搜索旋转排序数组 II - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/)

>这是第 33 题的升级版，也是面试中常用来考察思维严谨性的题目。
>**挑战点：** 当 `nums[l] == nums[m] == nums[r]` 时，我们无法判断哪一半是有序的。例如 `[1, 0, 1, 1, 1]` 和 `[1, 1, 1, 0, 1]`，中点和两头相等，目标值 `0` 可能在左也可能在右。

**查找范围：**`l <= r`

**单调性分析：**

由于存在重复元素，原本通过 `nums[l] <= nums[m]` 判断左半部分有序的逻辑会因“相等”而失效。

- **特殊情况：** 如果 `nums[l] == nums[m]` 且 `nums[m] == nums[r]`。
    
    > **处理策略：** 此时无法排除任何一半，只能简单地让 `l++` 和 `r--`，缩小范围后再继续二分。
    
- **其余情况：** 依然遵循第 33 题的逻辑，通过比较确定哪一段是有序的。
    


**查找策略：**

- **初始化答案：** `false`（题目要求返回布尔值）。
    
- **二分过程：**
    
    1. 如果 `nums[m] == target`，返回 `true`。
        
    2. **去重缩距（核心）：** 如果 `nums[l] == nums[m] && nums[m] == nums[r]`：
        
        > 执行 `l++; r--;`。
        
    3. **判断左半部分是否有序：**
        
        - 如果 `nums[l] <= nums[m]`：
            
            - `target` 在 `[nums[l], nums[m])` 之间，则 `r = m - 1`。
                
            - 否则 `l = m + 1`。
                
    4. **判断右半部分是否有序：**
        
        - 否则（右半部分有序）：
            
            - `target` 在 `(nums[m], nums[r]]` 之间，则 `l = m + 1`。
                
            - 否则 `r = m - 1`。

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        
        while (l <= r) {
            int m = l + (r - l) / 2;
            if (nums[m] == target) return true;

            // 核心：处理无法判断有序性的特殊情况
            if (nums[l] == nums[m] && nums[m] == nums[r]) {
                l++;
                r--;
            }
            // 剩下的逻辑同第 33 题
            else if (nums[l] <= nums[m]) {                                                                                                                                                                                                                                                                  
                if (target >= nums[l] && target < nums[m]) r = m - 1;      
                else l = m + 1;      
            }       else {      
                if (target > nums[m] && target <= nums[r]) l = m + 1;      
                else r = m - 1;      
            }
        }
        return false;      
    }
};
```

---

### 3.搜索矩阵

[240. 搜索二维矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=problem-list-v2&envId=binary-search)

> 这道题有三种解法

#### 1.Z字形查找法

**单调性：** 矩阵上任何一点的==右边和下边的值都更大，左边和上边的值都更小==。搜索要根据单调性进行特定的搜索策略，所有我们可以选择一边大一边小的搜索策略进行搜索，er

**搜索起点：** ==矩阵的右上角==。

```cpp
class Solution {

public:

    bool searchMatrix(vector<vector<int>>& matrix, int target) {

        int m = matrix.size(), n = matrix[0].size();

        int row = 0, line = n - 1;

        while (row < m && line >= 0) {

            if (matrix[row][line] == target)return true;

            else if (matrix[row][line] > target)--line;

            else ++row;

        }

        return false;

    }

};
```

|**算法**|**时间复杂度**|**适用场景**|
|---|---|---|
|**Z字形查找**|$O(m + n)$|**最优解**，代码最简洁。|
|**逐行二分**|$O(m \log n)$|当列数 $n$ 远大于行数 $m$ 时效率尚可。|
|**分治二分**|$O(\log m \cdot \log n)$ 级别|理论上更接近高维二分，但递归开销较大。|



---


# 3.进阶应用-二分答案法

普通的二分搜索是在**数据**（数组）中找目标值，而二分答案是在**可能的解的范围**（答案空间）中找最优解。

## 1.什么是二分答案？

> 有些问题的目标不是找一个存在的数，而是求一个**满足条件的最小值**或**最大值**。如果随着“答案”的增加，问题满足条件的可能性具有**单调性**（例如：答案越小越容易满足，答案越大越难满足），那就可以二分这个“答案”。

## 2.二分策略及模板

### 二分策略

**核心点：** 分析单调性、建立f函数。

1. 估计==最终答案可能的范围==是什么(**由于二分时间复杂度为$logN$，二分次数较少，我们估计的范围可以不必太精细**)
2. 分析==问题的答案==和==给定条件==之间的==单调性==
3. 建立一个check函数，==当答案固定的情况下==，判断==给定的条件是否达标==
4. 在==最终答案可能的范围上不断二分搜索==，每次用check函数判断，直到二分结束，==找到最合适的答案==

### 二分模板

```cpp
// 寻找满足条件的“最小”值 (Lower Bound 思想)
long long l = min_possible_ans, r = max_possible_ans;
long long ans = r;
while (l <= r) {
    long long mid = l + (r - l) / 2;
    if (check(mid)) {    // 如果 mid 满足条件
        ans = mid;       // 记录当前可行解
        r = mid - 1;     // 尝试更小的解 (向左挤)
    } else {
        l = mid + 1;     // mid 不行，必须增大 (向右走)
    }
}
return ans;
```

## 3.题目轰炸训练

### 1.资源分配与效率优化（最小化最大值）

>[!ABSTRACT]
>这类题目通常要求我们在有限的时间或空间内，找到一个**最低限度的能力或速度**来完成任务。

[875. 爱吃香蕉的珂珂 - 力扣（LeetCode）](https://leetcode.cn/problems/koko-eating-bananas/submissions/687358078/?envType=problem-list-v2&envId=binary-search)

1. **答案空间（$k$ 的范围）：** 最小每小时吃 1 根，最大每小时吃掉最大一堆的数量。
    
2. **单调性分析：**
    
    - 如果每小时吃 $k$ 根能吃完，那么吃 $k+1$ 根一定也能吃完（==速度越快越容易吃完==）。
        
        >*我们要找的是满足条件的最小 $k$，这本质上就是找 “$\ge$ 满足条件的最左位置”。*
        
1. **`check(k)` 函数：** 遍历所有堆，计算以速度 $k$ 吃完总共需要多少小时，看是否 $\le h$。

```cpp
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        int l = 1, r = *max_element(piles.begin(), piles.end());
        int ans = r;

        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (check(piles, h, mid)) {
                ans = mid;    // mid 速度可行，记录下来
                r = mid - 1;  // 尝试更小的速度
            } else {
                l = mid + 1;  // mid 速度太慢，必须加速
            }
        }
        return ans;
    }

private:
    bool check(vector<int>& piles, int h, int k) {
        long hours = 0;
        for (int p : piles) {
            // 计算当前堆需要的小时数（向上取整）
            hours += (p + k - 1) / k;
        }
        return hours <= h;
    }
};
```

[410. 分割数组的最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/split-array-largest-sum/description/?envType=problem-list-v2&envId=binary-search)      

. **答案空间：** 当数组全为0时答案==最小为0==，当$k$为1时，答案==最大为数组元素之和==
    
2. **单调性分析：**
    
    - 如果在每个分割数组之和都不超过当前$sum$的情况下，分割数组的==最少数量==$\le k$，说明$\ge k$的情况都同样满足条件，那么==记录当前sum,并在$0~sum-1$的左边界范围内继续二分寻找最优解==，否则在==右边界二分==。
        
        >*我们要找的是满足条件的最小 $sum$，这本质上就是找 “$\ge$ 满足条件的最左位置”。*
        
2. **`check(k)` 函数：** 遍历所有数组进行数组分割，计算在分割数组的和==不超过==$sum$的情况下==最少==要分割成多少个数组，用$cnt$记录并返回

```cpp
class Solution {

public:

    int splitArray(vector<int>& nums, int k) {

        int ans = 0;

        long sum = 0;

        for (auto& i : nums)sum += i;

        for (long l = 0, r = sum, m; l <= r;) {

            m = l + (r - l) / 2;

            if (check(nums, m) <= k) {

                ans = m;

                r = m - 1;

            }

            else l = m + 1;

        }

        return ans;

    }

  

    int check(vector<int>nums, int sum) {

        int cnt = 1;

        for (int i = 0,add=0; i < nums.size(); i++) {

            if(nums[i]>sum)return INT_MAX;

            add += nums[i];

            if (add > sum) {

                ++cnt;

                add = nums[i];

            }

        }

        return cnt;

    }

};
```

---


[2187. 完成旅途的最少时间 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-time-to-complete-trips/description/)

> 当 $m$ 达到 $10^9$ 级别时，传统的堆模拟（$O(m \log n)$）会彻底失效，而二分答案法能将其复杂度控制在 $O(n \log(\text{max\_ans}))$。

 **答案空间：** `l <= r`

- **答案最小值：** `0`（如果此时已经有人空闲）。
    
- **答案最大值：** `min(arr) * m`（假设让效率最高的服务员一个人处理完前面所有 $m$ 个人）。
    

**单调性分析：**

由于等待时间越长，服务员能够处理的总人数就越多：

- 如果当前时间 `mid` 能够处理的人数 **$\ge m + 1$**，说明你在 `mid` 时间内一定能被接待到。
    
    > **在左边界继续二分**（寻找满足条件的最小时间）。
    
- 如果处理人数 **$< m + 1$**，说明 `mid` 时间不够，还没轮到你。
    
    > **在右边界继续二分**。
    

**查找策略：**

1. **初始化答案：** `ans = 0`。
    
2. **`check(mid)` 函数：**
    
    - 在给定的 `mid` 时间内，每个服务员 $i$ 能接待的人数为 $\lfloor mid / arr[i] \rfloor$。
        
    - 累加所有服务员接待的人数总和。
        
    - **注意点：** 题目问的是“你”作为新来的人需要等多久。这意味着当处理能力总和达到 **$m + 1$** 时，说明你已经开始被服务或服务结束。
        


```cpp
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

class Solution {
public:
    long long waitingTime(vector<int>& arr, int m) {
        // 1. 确定答案搜索范围
        long long l = 0;
        // 假设由最快的人处理所有人，确定上限
        long long min_val = *min_element(arr.begin(), arr.end());
        long long r = min_val * m; 
        long long ans = r;

        while (l <= r) {
            long long mid = l + (r - l) / 2;
            // 2. 检查在 mid 时间内能否处理完 m 个人
            if (check(arr, m, mid)) {
                ans = mid;    // mid 时间足够，记录并尝试更短时间
                r = mid - 1;
            } else {
                l = mid + 1;  // 时间太短，还没轮到你
            }
        }
        return ans;
    }

private:
    bool check(const vector<int>& arr, int m, long long time) {
        long long count = 0;
        for (int t : arr) {
            // 在给定 time 内，该服务员能接待的人数
            count += (time / t);
            // 提前退出，防止 long long 溢出
            if (count >= m + 1) return true; 
        }
        return count >= m + 1;
    }
};
```

---

[1011. 在 D 天内送达包裹的能力 - 力扣（LeetCode）](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/description/)

**答案空间：**`l <= r`

- **最小值 ($l$)：** `max(weights)`。
    
    > 船的最低运载能力必须至少能装下最重的那个包裹，否则那个包裹永远无法运送。
    
- **最大值 ($r$)：** `sum(weights)`。
    
    > 最坏的情况是一天之内运走所有包裹。
    



**单调性分析：**

船的运载能力越大，所需的天数就越少：

- 如果运载能力为 `mid` 时，能在 $D$ 天内运完，说明 `mid` 可能就是答案，或者是更优解的上限。
    
    > **在左边界继续二分**，寻找更小的达标能力。
    
- 如果运载能力为 `mid` 时，所需天数超过了 $D$ 天，说明 `mid` 太小了。
    
    > **在右边界继续二分**，必须增加载重。



**查找策略：**

1. **初始化答案：** `ans = r`。
    
2. **`check(mid)` 函数（贪心模拟）：**
    
    - 从第一个包裹开始装船，累加当前天的重量。
        
    - 如果加上下一个包裹会超过 `mid`，则必须开启新的一天，天数 `count++`。
        
    - 最后判断总天数是否 $\le D$。
        

```cpp
class Solution {
public:
    int shipWithinDays(vector<int>& weights, int days) {
        // 1. 确定答案搜索空间
        int l = 0, r = 0;
        for (int w : weights) {
            l = max(l, w); // 船至少要能装下最重的包裹
            r += w;        // 最大载重是所有包裹总和
        }

        int ans = r;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            // 2. 检查当前载重能力 mid 是否能在 days 内运完
            if (check(weights, days, mid)) {
                ans = mid;    // mid 可行，记录并尝试压缩载重
                r = mid - 1;
            } else {
                l = mid + 1;  // mid 太小，运不完
            }
        }
        return ans;
    }

private:
    bool check(const vector<int>& weights, int days, int capacity) {
        int count = 1;      // 当前正在运送的天数
        int currentSum = 0; // 当前天的已装载重量
        
        for (int w : weights) {
            if (currentSum + w > capacity) {
                count++;        // 开启新的一天
                currentSum = w; // 新的一天装入当前包裹
                if (count > days) return false;
            } else {
                currentSum += w;
            }
        }
        return true;
    }
};
```

---

### 2.资源博弈与生存模拟（寻找临界初始值）

> [!ABSTRACT]
> 这类题目通常涉及到一个随时间或回合变化的动态过程，需要找到一个**最小的起始值**以保证过程能够顺利结束。

[机器人跳跃问题_牛客题霸_牛客网](https://www.nowcoder.com/practice/7037a3d57bbd4336856b8e16a9cafd71)

 **答案空间：** 答案最小为0，最大为数组的最大值（当origin为最大值时机器人跳跃能量要么不变要么增长，不会减小，则一定可以跳完）
    
2. **单调性分析：**
    
    - 如果当前初始能量$origin$能够满足条件，则$origin~Max$的值一定也能满足条件，在==左边界继续二分==（在更苛刻的条件下寻找最优解），否则在==右边界二分==（在更宽松的条件下寻找最优解）
        
        >*我们要找的是满足条件的最小 $origin$，这本质上就是找 “$\ge$ 满足条件的最左位置”。*
        
3. **`check(k)` 函数：** 遍历数组（除了索引为$0$的位置），模拟每一次跳跃并更新$origin$，当$origin$小于$0$时表示不能继续跳跃，则返回0。当$origin$==大于数组最大值时则后续一定能完成所有跳跃，提前返回==$1$（若不提前返回，而是数组全部遍历，则可能$origin$**溢出**甚至$long long$，比如$nums$为${1，1...1,1,1}$）。

```cpp
#include <iostream>

#include<vector>

using namespace std;

  

int check(vector<int>& nums, int origin,int max) {

    for (int i = 1; i < nums.size();i++) {

        origin += origin - nums[i];

        if (origin >= max)return 1;

        else if (origin < 0)return 0;

    }

    return 1;

}

  

int main() {

    int n, ans = 0, Max = 0;

    cin >> n;

    vector<int>nums(n+1);

    for (int i = 1; i <= n; ++i) {

        cin >> nums[i];

        Max = max(Max, nums[i]);

    }

    for (int l = 0, r = Max, m; l <= r;) {

        m = l + (r - l) / 2;

        if (check(nums, m, Max)) {

            ans = m;

            r = m - 1;

        }

        else l = m + 1;

    }

    cout << ans << endl;

    return 0;

}
```

---

**刀砍毒杀怪兽问题**
<font color=greeen>怪兽的初始血量是一个整数`hp`，给出每一回合刀砍和毒杀的数值`cuts`和`poisons`
第i回合如果用刀砍，怪兽在这回合会直接损失`cuts[i]`的血，不再有后续效果
第i回合如果用毒杀，怪兽在这回合不会损失血量，但是之后每回合都损失`poison[i]`的血量
并且你选择的所有毒杀效果，在之后的回合都会叠加
两个数组`cuts`、`poisons`，长度都是`n`，代表你一共可以进行n回合
每一回合你只能选择刀砍或者毒杀中的一个动作
如果你在`n`个回合内没有直接杀死怪兽，意味着你已经无法有新的动作了
但是怪兽如果有中毒效果的话，那么怪兽依然会不停扣血，直到血量耗尽的那回合死掉
返回至少多少回合怪兽会死掉
数据范围：$1\le n\le 10^5;1\le hp\le 10^9;1\le cuts[i]、poisons[i]\le 10^9$</font>

 **答案空间：** `l <= r`

- **最小值：** `1`。
    
- **最大值：** `hp + n`（最坏情况，即使所有伤害都很低，也一定能在某个时间点磨死怪兽）。
    
    - _注意：_ 回合数可以超过数组长度 $n$。如果超过 $n$，你将无法进行新的动作，但怪兽会继续因之前的毒杀效果扣血。
        
 
**单调性分析：**

- 如果怪兽在第 $X$ 回合会死掉，那么在第 $X+1$ 回合它一定也是死掉的状态。
    
- 我们寻找的是满足怪兽死亡条件的**最小回合数**，即寻找“满足条件的左边界”。
    
 
**查找策略：**

1. **预处理：** 为了在每一回合做出最优选择，我们需要判断在第 $i$ 回合，是选 `cuts[i]` 划算，还是选 `poisons[i]` 划算。
    
2. **贪心选择逻辑：**
    
    - 假设我们要验证的总回合数为 `mid`。
        
    - 在第 $i$ 回合（$i < n$），如果使用毒杀，它产生的总伤害是 `poisons[i] * (mid - i - 1)`。
        
    - 我们比较 `cuts[i]` 和 `poisons[i] * (mid - i - 1)`，哪个大就选哪个。
        
3. **`check(mid)` 函数：**
    
    - 遍历前 $n$ 个回合（或前 `mid` 个回合，取较小值）。
        
    - 累加每一回合的最优伤害，判断总和是否 $\ge hp$。
        
 

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Solution {
public:
    long long minRounds(int n, int hp, vector<int>& cuts, vector<int>& poisons) {
        long long l = 1, r = 2e9; // 答案空间较大，用 long long
        long long ans = r;

        while (l <= r) {
            long long mid = l + (r - l) / 2;
            if (check(mid, n, hp, cuts, poisons)) {
                ans = mid;
                r = mid - 1; // 尝试更少的回合
            } else {
                l = mid + 1;
            }
        }
        return ans;
    }

private:
    bool check(long long mid, int n, int hp, vector<int>& cuts, vector<int>& poisons) {
        long long totalDamage = 0;
        int limit = min((long long)n, mid);
        
        for (int i = 0; i < limit; ++i) {
            // 当前回合选择：刀砍 vs 毒杀在剩余时间内产生的总伤害
            long long poisonPotential = (long long)poisons[i] * (mid - i - 1);
            totalDamage += max((long long)cuts[i], poisonPotential);
            
            if (totalDamage >= hp) return true; // 提前返回防止溢出
        }
        return totalDamage >= hp;
    }
};
```

---

### 3.硬件限制与电量调度（最大化最小值）

>[!ABSTRACT]
>与第一类相反，这类题目通常是在资源有限的情况下，尽可能延长“最短板”的寿命或距离。

[2141. 同时运行 N 台电脑的最长时间 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-running-time-of-n-computers/submissions/687648858/?envType=problem-list-v2&envId=binary-search)

> 直接模拟电池分配非常复杂，但如果我们换个思路：==“给定一个目标时间 $mid$，现有的电池总量是否能支撑 $n$ 台电脑同时运行 $mid$ 分钟？”== 这个问题具有明显的单调性，因此可以对“最长时间”进行二分。



**答案空间：**`l <= r`

- **最小值：** `0`（或者 `min(batteries)`）。
    
- **最大值：** `sum(batteries) / n`（理论上的绝对上限，即所有电量完全不浪费地平分给 $n$ 台电脑）。
    



**单调性分析：**

对于一个猜测的时间 `mid`：

- 如果电量能够支撑 $n$ 台电脑同时运行 `mid` 分钟，那么运行 `mid - 1` 分钟也一定可行。
    
    > **在右边界继续二分**（寻找满足条件的最大时间）。
    
- 如果电量无法支撑 `mid` 分钟，说明目标定高了。
    
    > **在左边界继续二分**。
    


**查找策略：**

1. **初始化答案：** `ans = 0`。
    
2. **`check(mid)` 函数（核心逻辑）：**
    
    - 对于每一块电池，它在 `mid` 分钟内最多只能贡献 `mid` 的电量（即使它的容量超过 `mid`，一台电脑在 `mid` 时间内也只能消耗这么多，多出来的部分无法同时给其他电脑用）。
        
    - **计算总贡献值：** 遍历所有电池，贡献值为 `min((long long)battery, mid)`。
        
    - **判断准则：** 如果所有电池的有效贡献总和 $\ge n \times mid$，说明==可以支撑 $n$ 台电脑运行== `mid` 分钟。
        

```cpp
class Solution {
public:
    long long maxRunTime(int n, vector<int>& batteries) {
        long long sum = 0;
        for (int b : batteries) sum += b;

        long long l = 0, r = sum / n;
        long long ans = 0;

        while (l <= r) {
            long long mid = l + (r - l) / 2;
            if (check(n, batteries, mid)) {
                ans = mid;    // mid 时间可行，尝试更长的时间
                l = mid + 1;
            } else {
                r = mid - 1;  // mid 太长了，电量不够，缩小范围
            }
        }
        return ans;
    }

private:
    // 判断在 mid 分钟内，电池总贡献是否能支撑 n 台电脑
    bool check(int n, vector<int>& batteries, long long mid) {
        long long total_contribution = 0;
        for (int b : batteries) {
            // 每块电池在 mid 时间内的最大贡献不能超过 mid 本身
            //单块电池电量再多，在固定的 `mid` 时间内也只能给一台电脑供电，因此超出 `mid` 的部分在那段时间内是“无效”的。
            total_contribution += min((long long)b, mid);
        }
        // 总贡献是否大于等于 n 台电脑在 mid 时间内的总需求
        return total_contribution >= (long long)n * mid;
    }
};
```

---


### 4.统计规律与第 K 个数值（寻找特定排名）

>[!ABSTRACT]
>这类题目不是直接进行物理模拟，而是在有序或可统计的空间内，寻找满足计数条件的边界值。


[719. 找出第 K 小的数对距离 - 力扣（LeetCode）](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/?envType=problem-list-v2&envId=binary-search)

**答案空间：**`l <= r`

- **最小值：** `0`（数组中存在相等元素时的最小距离）。
    
- **最大值：** `nums.back() - nums.front()`（排序后数组最大值与最小值的差）。
    

 **单调性分析：**

对于一个猜测的距离 `mid`：

- 如果距离小于等于 `mid` 的数对总数 **$\ge k$**，说明第 $k$ 小的距离可能就是 `mid` 或者比 `mid` 更小。
    
    > ==在左边界继续二分==（寻找满足条件的最小距离）。
    
- 如果总数 **$< k$**，说明 `mid` 定小了，第 $k$ 小的距离一定在右边。
    
    > ==在右边界继续二分==。

**查找策略：**

1. **初始化答案：** `ans = 0`。
    
2. **`check(mid)` 函数（双指针法）：**
    
    - 为了快速统计距离 $\le mid$ 的数对数量，先对原数组进行**升序排序**。
        
    - 使用右指针 `right` 遍历数组，对于每个 `right`，移动左指针 `left` 直到 `nums[right] - nums[left] <= mid`。
        
    - 此时，以 `right` 为右端点且满足条件的数对个数为 `right - left`。
        
    - 将所有位置的个数累加，看是否满足 $\ge k$。
        


```cpp
class Solution {
public:
    int smallestDistancePair(vector<int>& nums, int k) {
        // 二分前提：排序以支持双指针统计
        sort(nums.begin(), nums.end());
        
        int n = nums.size();
        int l = 0, r = nums.back() - nums.front();
        int ans = 0;

        while (l <= r) {
            int mid = l + (r - l) / 2;
            // 统计距离小于等于 mid 的数对个数
            if (countPairs(nums, mid) >= k) {
                ans = mid;    // mid 可能是答案，记录并尝试更小的距离
                r = mid - 1;
            } else {
                l = mid + 1;  // mid 太小了，需要增大距离
            }
        }
        return ans;
    }

private:
    // 使用双指针在 O(n) 时间内统计数量
    int countPairs(vector<int>& nums, int mid) {
        int count = 0;
        int left = 0;
        for (int right = 0; right < nums.size(); ++right) {
            while (nums[right] - nums[left] > mid) {
                left++;
            }
            count += (right - left);
        }
        return count;
    }
};
```

---

## 4.总结

### 1.核心思想：将“求值”转化为“判定”

二分答案的核心在于：当我们很难直接计算出最优解，但很容易**判断**一个给定的值是否满足条件时，我们可以利用答案的**单调性**，在可能的解空间内通过二分进行“搜索”。

---

### 2. 题型分类与建模逻辑

根据 `check` 函数的实现逻辑，二分答案主要分为以下三类：

#### A. 贪心模拟类（最常见）

这类题目通过模拟过程来验证答案。

- **代表题：** [1011. 包裹能力]、[875. 珂珂吃香蕉]、[410. 分割数组最大值]、[机器人跳跃问题]。
    
- **`check` 逻辑：** 按照猜测的 $mid$（如速度、能力、能量）从头开始模拟。
    
    - _例子（1011题）：_ 设定载重为 $mid$，如果当天装不下下一个包裹，天数就加 1。
        
- **决策方向：**
    
    - 最小化最大值：若 `check` 成功，说明 $mid$ 可能太大，向左找。
        
    - 最大化最小值：若 `check` 成功，说明 $mid$ 可能太小，向右找。
        

#### B. 资源共享与限制类

这类题目通常涉及多个资源对一个目标的贡献。

- **代表题：** [2141. 电脑运行时间]、[2187. 旅途最少时间]、[刀砍毒杀怪兽]。
    
- **`check` 逻辑：** 计算在给定时间 $mid$ 下，所有资源（电池、服务员、回合）能提供的总贡献。
    
    - _关键技巧：_ 往往需要用 `min(resource, mid)` 来限制单个资源的最大贡献。
        
- **决策方向：** 判断 `总贡献 >= 需求量`。
    

#### C. 计数统计类（高阶）

这类题目通常是在复杂的组合空间中寻找特定排名的数值。

- **代表题：** [719. 第 K 小的数对距离]。
    
- **`check` 逻辑：** 统计数值 $\le mid$ 的元素个数，看计数是否达到 $K$。
    
    - _常用手段：_ 配合**双指针**或**滑动窗口**来优化计数过程。
        

---


### 3. 三大关键要素

|**要素**|**说明**|**常见错误**|
|---|---|---|
|**单调性**|答案越大越容易满足（或反之）。|忽略了数据顺序（有些题需要先 `sort`）。|
|**答案范围**|必须确定 $l$ 和 $r$ 的绝对边界。|$r$ 定得太小（如忽略了 `long long` 溢出或总和）。|
|**check 函数**|实现 $O(n)$ 或 $O(n \log n)$ 的验证逻辑。|在 `check` 里写了过于复杂的算法导致整体超时。|

---

## 4. 经验总结与避坑指南

1. **数据类型：** 涉及累加（如 `sum` 或 `count`）时，务必使用 `long long`，防止在二分过程中溢出。
    
2. **贪心策略：** 在 `check` 函数中，贪心往往是二分答案的好伙伴。例如 [刀砍毒杀怪兽] 中每一轮都选当前价值最大的动作。
    
3. **特殊位置处理：**  如果寻找“最小的 $k$”，初始化 `ans` 为最大范围，往左收缩。
    
    - 如果寻找“最大的 $k$”，初始化 `ans` 为最小范围，往右收缩。
        
4. **提前返回：** 在 `check` 函数的循环中，如果累加值已经超过了目标值，应立即返回 `true`，避免无效计算。