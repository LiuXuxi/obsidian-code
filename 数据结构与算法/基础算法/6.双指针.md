> [!ABSTRACT]
> **双指针是一种核心的优化思路，用于将O(n^2)的暴力遍历优化为O(n)的线性时间复杂度。其题型可根据指针的==移动方向、步长和作用目标==划分为四个主要类别，覆盖了数组、字符串和链表三大核心数据结构**  

---
# 1.对撞双指针

**核心原理：** 两个指针分别从数组或字符串的两端（头和尾）开始，相向移动，知道相遇或交叉。

**驱动力：** 该方法几乎总是依赖于数据结构（尤其是数组）的==有序性==或问题的==对称性==（如回文串），并利用[[7.单调性]]进行高效剪枝。
## 常见应用场景

### 1.两数之和/多数之和

> 在有序数组中快速查找和为目标值的元素对（或多对）。

#### [两数之和||-输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

**核心问题：** 在一个==有序数组==中，找到相加之和等于目标值T的两个数。

**指针策略：** 设置左指针L\[0]和右指针R\[N-1]。

**单调性：** 利用A\[L]+A\[R]的和的单调性来指导移动：
- 若和>T，则==必须==R--（减小和）。
- 若和<T，则==必须==L++（增大和）。

```cpp
class Solution {
public:
    std::vector<int> twoSum(std::vector<int>& numbers, int target) {
        int L = 0; // 左指针
        int R = numbers.size() - 1; // 右指针
        while (L < R) { 
	        int currentSum = numbers[L] + numbers[R];
	        if (currentSum == target) { 
		        // 找到解。题目要求返回 1-based 索引 
		        return {L + 1, R + 1};
	        } else if (currentSum < target) { 
		        // 和太小，L 必须右移增大和 
		        L++;
	        } else { 
		        // currentSum > target // 和太大，R 必须左移减小和 
		        R--; 
	        } 
	    } // 题目保证有唯一解，实际不会到达这里 
	    return {}; 
	} 
};
```

#### [救生 艇](https://leetcode.cn/problems/boats-to-save-people/)

**核心逻辑：** 首先对体重数组进行排序。为了用最少的船，我们要尽可能让每条船都坐满 2 个人，且让“最重的”和“最轻的”尝试配对。

 **指针移动策略：**
   * 如果 people\[left] + people\[right] <= limit：说明这一重一轻可以同船，left++, right--。
   * 如果 people\[left] + people\[right] > limit：说明最重的那个人太沉了，任何人都没法和他拼船，他必须单独坐，right--。
    ==这种“一头一尾”的撮合逻辑正是典型的对撞指针应用。==

```cpp
```cpp
class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) {
        sort(people.begin(), people.end());
        int ans = 0;
        for (int l = 0, r = people.size() - 1; l <= r;) {
            int sum = l == r ? people[r] : people[l] + people[r];
            if (sum <= limit)l++;
            r--;
            ans++;
        }
        return ans;
    }
};
```

### 2.字符串反转/字符交换

> 对数组或字符串进行原地反转，如反转字符串中的元首字母。

#### [按奇偶排序数组||](https://leetcode.cn/problems/sort-array-by-parity-ii/)

**核心逻辑：**  题目要求 A\[i] 的奇偶性与索引 i 一致。我们可以用两个指针：i 处理偶数下标，j 处理奇数下标。
  
**指针移动策略：**
   * i 指针不断跳过已经在偶数位上的偶数（i += 2）。
   * j 指针不断跳过已经在奇数位上的奇数（j += 2）。
   * 当 i 发现了一个奇数，且 j 发现了一个偶数时，交换这两个元素。
     ==这虽然不是标准的从两端向中间“撞”，但它利用了两个指针在同一区间内根据条件“错位寻找”并“交换”的逻辑。==

### 3.回文串检测

> 验证字符串是否为回文字符串，可以处理空格、特殊字符或大小不敏感的情况。

#### [5. 最长回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-substring/submissions/685864282/?envType=problem-list-v2&envId=two-pointers)

**核心逻辑：** 中心扩展法
- 回文串的特性是中心对称的。我们可以遍历字符串的每一个位置，将其作为“中心”，向两边尝试扩展，直到不再满足回文条件为止。
- 由于回文串的长度可能是奇数或者偶数，我们需要考虑两种中心：
	- ==奇数长度：==中心是一个字符（aba，中心是b）
	- ==偶数长度：==中心是两个字符之间的间隙(abba,中心是bb)。

**指针移动策略：** 
1. ==指针移动与长度计算：==在expandArouondCenter函数中，当循环停止时，left和right已经指向了==不满足==回文条件的第一个字符。
	- ==左边界：==left+1
	- ==右边界：==right+1
	- ==长度公式：==$(right-1)-(left-1)+1=right=left-1$
2. ==起始位置start的推导：== 这是一个通用的数学小技巧，无论maxLen是奇数还是偶数都适用：
	- 假设中心索引为<font color=greeen>i</font>：
		- 奇数（长度3）：i=1,maxLen=3->start=1-(3-1)/2=0
		- 偶数（长度4）：i=1,maxLen=4->start=1-(4-1)/2=0
	- ==公式：== $start=i-(maxLen-1)/2$

```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {
        if (s.length() < 2) return s;

        int start = 0, maxLen = 0;

        for (int i = 0; i < s.length(); i++) {
            // 1. 奇数长度扩展 (如 "aba")
            int len1 = expandAroundCenter(s, i, i);
            // 2. 偶数长度扩展 (如 "abba")
            int len2 = expandAroundCenter(s, i, i + 1);

            int curMax = max(len1, len2);

            // 如果找到更长的回文，更新起始位置和最大长度
            if (curMax > maxLen) {
                maxLen = curMax;
                // 注意这里的起始点计算：
                // 如果长度为 3, 中心 i, start = i - (3-1)/2 = i - 1
                // 如果长度为 4, 中心 i 和 i+1, start = i - (4-1)/2 = i - 1
                start = i - (curMax - 1) / 2;
            }
        }

        return s.substr(start, maxLen);
    }

private:
    // 返回以 left, right 为中心向外扩展能达到的最长回文长度
    int expandAroundCenter(const string& s, int left, int right) {
        while (left >= 0 && right < s.length() && s[left] == s[right]) {
            left--;
            right++;
        }
        // 跳出循环时，s[left] != s[right]，所以有效长度是 (right - 1) - (left + 1) + 1
        return right - left - 1;
    }
};
```

### 4.定义区间边界

> 在有序数组或列表中，找到满足条件的最大/最小区间。

#### [接雨水](https://leetcode.cn/problems/trapping-rain-water/)
**核心逻辑：** 这是“盛最多水容器”的进阶版。每个位置能接多少水，取决于它左边最高的柱子和右边最高的柱子中的较小值。
   
**指针移动策略：** 维护两个变量 leftMax 和 rightMax。
   * 如果 leftMax < rightMax，说明左侧的瓶颈更低，当前左指针位置的蓄水量由 leftMax 决定，计算后 left++。
   * 反之，右侧瓶颈更低，由 rightMax 决定，计算后 right--。
     这本质上是利用对撞指针不断缩窄“确定区域”的边界。
```
```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size(), l = 0, r = 0, ans = 0;
        vector<int>lmax(n), rmax(n);
        for (int i = 0; i < n; i++) {
            lmax[i] = l > height[i] ? l : height[i];
            l = max(l, height[i]);
            rmax[n - 1 - i] = r > height[n - 1 - i] ? r : height[n - 1 - i];
            r = max(r, height[n-1-i]);
        }
        for (int i = 0; i < n; i++) {
            ans += max(0, min(lmax[i], rmax[i]) - height[i]);
        }
        return ans;
    }
};
```
#### 

#### [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

**核心逻辑：** 指针 left 指向开头，right 指向结尾。容器的容量由 min(height\[left], height\[right]) \times (right - left) 决定。

**指针移动策略：** 指针 left 指向开头，right 指向结尾。容器的容量由 min(height\[left], height\[right]) \times (right - left) 决定。

- 如果 height\[left] < height\[right]，则 left++。
- 反之，则 right--。

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int ans = 0;
        for (int l = 0, r = height.size() - 1; l <= r;) {
            ans = max(ans, min(height[l], height[r]) * (r - l));
            if (height[l] <= height[r])l++;
            else r--;
        }
        return ans;
    }
};
```

#### [供暖器](https://leetcode.cn/problems/heaters/)

**核心逻辑：** 为了让每个房屋都能被覆盖，我们需要找到每个房屋距离最近的供暖器的距离。总的最小半径就是所有这些“最近距离”中的最大值。
  
**指针移动策略：** 对房屋和供暖器都进行排序。遍历房屋，利用双指针寻找当前房屋左右两侧最近的供暖器。
   * 当下一个供暖器距离当前房屋更近时，移动供暖器指针 right++。
   * 不需要回溯，因为房屋也是有序的，之前的供暖器不会比当前的更近。
```cpp
class Solution {
public:
    int findRadius(vector<int>& houses, vector<int>& heaters) {
        int ans = 0;
        sort(houses.begin(), houses.end());
        sort(heaters.begin(), heaters.end());
        for (int l = 0, r = 0; l < houses.size(); l++) {
            while (r + 1 < heaters.size()&&!best(houses, heaters, l, r)) {
                r++;
            }
            ans = max(ans, (int)fabs(houses[l] - heaters[r]));
        }
        return ans;
    }

    int best(vector<int>& houses, vector<int>& heaters, int l, int r) {
        return fabs(houses[l] - heaters[r]) < fabs(houses[l] - heaters[r + 1]);
    }
};
```

[寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/description/)
# 2.快慢双指针


**核心原理：** 两个指针从同一位置（通常是链表头）出发，以不同的速度（快指针N步，慢指针一步）向前推进

**驱动力：** 该方法的核心优势在于==固定 步长差==，这使得他们在有环结构中必然相遇，或在无环结构中精确地测量出相互距离。


## 常见应用场景（以链表为主）

### 1.链表换检测

> 利用快慢指针的相对速度证明，在有环链表中它们必然相遇。

### 2.寻找环的入口/长度

> 在确定有环后，通过二次相遇定位环的起始节点。

### 3.寻找链表的中点

> 快指针走完时，慢指针恰好停留在中点。

### 4.寻找倒数第K个节点

> 先让快指针先行K步，再与慢指针同步移动，保持固定间隔。
# 3.同向双指针


**核心原理：** 两个指针<font color=greeen>i</font>和<font color=greeen>j</font>同向移动，但不用于定义一个动态区间（如滑动窗口）。它们常用于对数组进行原地修改、去重或在不同序列中进行同步比较。

**驱动力：** 通过一个指针负责==读==，另一个指针负责==写==或==标记==，实现单词遍历完成复杂操作。

#### [加油站](https://leetcode.cn/problems/gas-station/)

## 常见应用场景

### 1.数组去重/元素移动

> 使用快慢指针，快指针遍历所有元素，慢指针记录有效元素的位置，实现原地去重。

### 2.判断子序列

> 在两个字符串中同步移动指针，检查短串是否为子串的子序列。

### 3.合并有序数组/链表

> 使用两个指针分别指向两个有序结构，同步比较并合并，保证结果的有序性。

### 4.双指针从后向前遍历

> 从字符串或数组的末尾开始向前扫描，常用于处理退格符或寻找末尾单词
# 4.滑动窗口

**核心原理：** 这是同向双指针的最高级应用，使用两个指针<font color=greeen>L</font>（左边界）和<font color=greeen>R</font>（右边界）维护一个==动态变化的连续区间==（即“窗口”）。

**驱动力：** ==单调性==和==哈希表/字典==是其关键辅助工具。

- 当R扩张窗口时，窗口内状态被更新。
- 当窗口不满足条件时，单调性地收缩L，直到条件重新满足。L和R的移动永不后退，保证$O(N)$复杂度。

## 常见应用场景

### 1.最长/最短子数组/子串

> 寻找满足特定条件的、最长或最短的连续子数组或子串

### 2.子串覆盖问题

> 寻找包含目标字符串所有字符的最短子串（例如：最小覆盖子串）。

#### [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

### 3.定长窗口最值

> 在固定大小的窗口中，求窗口的最大值或最小值（常结合单调队列）。

### 4.字符频率/种类限制

> 寻找最多包含K个不同字符的最长子串等限制性问题。

#### [最小子数组](https://leetcode.cn/problems/2VG8Kg/)



#### [乘积小于K的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/description/)

#### [得到K个黑块的最少涂色次数](https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/)

#### [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)



#### [替换子串得到平衡字符串](https://leetcode.cn/problems/replace-the-substring-for-balanced-string/)

#### [K个不同整数的子数组](https://leetcode.cn/problems/subarrays-with-k-different-integers/)

#### [至少有k个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)

