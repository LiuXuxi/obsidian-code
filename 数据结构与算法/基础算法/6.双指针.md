> [!ABSTRACT]
> **双指针是一种核心的优化思路，用于将O(n^2)的暴力遍历优化为O(n)的线性时间复杂度。其题型可根据指针的==移动方向、步长和作用目标==划分为四个主要类别，覆盖了数组、字符串和链表三大核心数据结构**  

---
# 1.对撞双指针

**核心原理：** 两个指针分别从数组或字符串的两端（头和尾）开始，相向移动，知道相遇或交叉。

**驱动力：** 该方法几乎总是依赖于数据结构（尤其是数组）的==有序性==或问题的==对称性==（如回文串），并利用[[7.单调性]]进行高效剪枝。
## 常见应用场景

### 1.两数之和/多数之和

> 在有序数组中快速查找和为目标值的元素对（或多对）。

[两数之和||-输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

**核心问题：** 在一个==有序数组==中，找到相加之和等于目标值T的两个数。

**指针策略：** 设置左指针L\[0]和右指针R\[N-1]。

**单调性：** 利用A\[L]+A\[R]的和的单调性来指导移动：
- 若和>T，则==必须==R--（减小和）。
- 若和<T，则==必须==L++（增大和）。

```cpp
class Solution {
public:
    std::vector<int> twoSum(std::vector<int>& numbers, int target) {
        int L = 0; // 左指针
        int R = numbers.size() - 1; // 右指针
        while (L < R) { 
	        int currentSum = numbers[L] + numbers[R];
	        if (currentSum == target) { 
		        // 找到解。题目要求返回 1-based 索引 
		        return {L + 1, R + 1};
	        } else if (currentSum < target) { 
		        // 和太小，L 必须右移增大和 
		        L++;
	        } else { 
		        // currentSum > target // 和太大，R 必须左移减小和 
		        R--; 
	        } 
	    } // 题目保证有唯一解，实际不会到达这里 
	    return {}; 
	} 
};
```
### 2.字符串反转/字符交换

> 对数组或字符串进行原地反转，如反转字符串中的元首字母。

### 3.回文串检测

> 验证字符串是否为回文字符串，可以处理空格、特殊字符或大小不敏感的情况。

### 4.定义区间边界

> 在有序数组或列表中，找到满足条件的最大/最小区间。
# 2.快慢双指针


**核心原理：** 两个指针从同一位置（通常是链表头）出发，以不同的速度（快指针N步，慢指针一步）向前推进

**驱动力：** 该方法的核心优势在于==固定 步长差==，这使得他们在有环结构中必然相遇，或在无环结构中精确地测量出相互距离。

## 常见应用场景（以链表为主）

### 1.链表换检测

> 利用快慢指针的相对速度证明，在有环链表中它们必然相遇。

### 2.寻找环的入口/长度

> 在确定有环后，通过二次相遇定位环的起始节点。

### 3.寻找链表的中点

> 快指针走完时，慢指针恰好停留在中点。

### 4.寻找倒数第K个节点

> 先让快指针先行K步，再与慢指针同步移动，保持固定间隔。
# 3.同向双指针


**核心原理：** 两个指针<font color=greeen>i</font>和<font color=greeen>j</font>同向移动，但不用于定义一个动态区间（如滑动窗口）。它们常用于对数组进行原地修改、去重或在不同序列中进行同步比较。

**驱动力：** 通过一个指针负责==读==，另一个指针负责==写==或==标记==，实现单词遍历完成复杂操作。

## 常见应用场景

### 1.数组去重/元素移动

> 使用快慢指针，快指针遍历所有元素，慢指针记录有效元素的位置，实现原地去重。

### 2.判断子序列

> 在两个字符串中同步移动指针，检查短串是否为子串的子序列。

### 3.合并有序数组/链表

> 使用两个指针分别指向两个有序结构，同步比较并合并，保证结果的有序性。

### 4.双指针从后向前遍历

> 从字符串或数组的末尾开始向前扫描，常用于处理退格符或寻找末尾单词
# 4.滑动窗口

**核心原理：** 这是同向双指针的最高级应用，使用两个指针<font color=greeen>L</font>（左边界）和<font color=greeen>R</font>（右边界）维护一个==动态变化的连续区间==（即“窗口”）。

**驱动力：** ==单调性==和==哈希表/字典==是其关键辅助工具。

- 当R扩张窗口时，窗口内状态被更新。
- 当窗口不满足条件时，单调性地收缩L，直到条件重新满足。L和R的移动永不后退，保证$O(N)$复杂度。

## 常见应用场景

### 1.最长/最短子数组/子串

> 寻找满足特定条件的、最长或最短的连续子数组或子串

### 2.子串覆盖问题

> 寻找包含目标字符串所有字符的最短子串（例如：最小覆盖子串）。

### 3.定长窗口最值

> 在固定大小的窗口中，求窗口的最大值或最小值（常结合单调队列）。

### 4.字符频率/种类限制

> 寻找最多包含K个不同字符的最长子串等限制性问题。

[最小子数组](https://leetcode.cn/problems/2VG8Kg/)

[乘积小于K的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/description/)

[得到K个黑块的最少涂色次数](https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/)

[无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

[最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

[加油站](https://leetcode.cn/problems/gas-station/)

[替换子串得到平衡字符串](https://leetcode.cn/problems/replace-the-substring-for-balanced-string/)

[K个不同整数的子数组](https://leetcode.cn/problems/subarrays-with-k-different-integers/)

[至少有k个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)

