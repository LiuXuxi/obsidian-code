> [!ABSTRACT]
> **双指针（Two Pointers）是算法面试中出镜率最高、性价比最强的优化手段。它能精准地将 $O(n^2)$ 的暴力遍历优化为 $O(n)$ 的线性时间复杂度。本文将深度解析双指针的四大核心模型：对撞、快慢、同向及滑动窗口，并附带万能模板与数学证明。**  

[TOC]

---
# 1.对撞双指针

**核心原理：** 两个指针分别从数组或字符串的两端（头和尾）开始，相向移动，直到相遇或交叉。

**驱动力：** 该方法几乎总是依赖于数据结构（尤其是数组）的==有序性==或问题的==对称性==（如回文串），并利用[[7.单调性]]进行高效剪枝。
## 常见应用场景

### 1.两数之和/多数之和

> 在有序数组中快速查找和为目标值的元素对（或多对）。

#### 1.两数之和
##### [两数之和||-输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

**核心问题：** 在一个==有序数组==中，找到相加之和等于目标值T的两个数。

**指针策略：** 设置左指针L\[0]和右指针R\[N-1]。

**单调性：** 利用A\[L]+A\[R]的和的单调性来指导移动：
- 若和>T，则==必须==R--（减小和）。
- 若和<T，则==必须==L++（增大和）。

```cpp
class Solution {
public:
    std::vector<int> twoSum(std::vector<int>& numbers, int target) {
        int L = 0; // 左指针
        int R = numbers.size() - 1; // 右指针
        while (L < R) { 
	        int currentSum = numbers[L] + numbers[R];
	        if (currentSum == target) { 
		        // 找到解。题目要求返回 1-based 索引 
		        return {L + 1, R + 1};
	        } else if (currentSum < target) { 
		        // 和太小，L 必须右移增大和 
		        L++;
	        } else { 
		        // currentSum > target // 和太大，R 必须左移减小和 
		        R--; 
	        } 
	    } // 题目保证有唯一解，实际不会到达这里 
	    return {}; 
	} 
};
```

##### [救生 艇](https://leetcode.cn/problems/boats-to-save-people/)

**核心逻辑：** 首先对体重数组进行排序。为了用最少的船，我们要尽可能让每条船都坐满 2 个人，且让“最重的”和“最轻的”尝试配对。

 **指针移动策略：**
   * 如果 people\[left] + people\[right] <= limit：说明这一重一轻可以同船，left++, right--。
   * 如果 people\[left] + people\[right] > limit：说明最重的那个人太沉了，任何人都没法和他拼船，他必须单独坐，right--。
    ==这种“一头一尾”的撮合逻辑正是典型的对撞指针应用。==

```cpp
```cpp
class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) {
        sort(people.begin(), people.end());
        int ans = 0;
        for (int l = 0, r = people.size() - 1; l <= r;) {
            int sum = l == r ? people[r] : people[l] + people[r];
            if (sum <= limit)l++;
            r--;
            ans++;
        }
        return ans;
    }
};
```

#### 2.多数之和

##### [ 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/submissions/686012962/?envType=problem-list-v2&envId=two-pointers)


> 核心算法流程：分而治之

**第一步：数组排序**：排序是所有后续优化的基石
	1. 是==单调性==生效，从而可以使用双指针剪枝。
	2. 使重复元素相邻，简化去重逻辑。

**第二步：固定左端点：** 通过一个外层循环固定第一个数A\[i]。此时，问题转化为：在$A[i+1...N-1]$范围内寻找两个数，使其和等于-A\[i]。
	==优化：== 如果$A[i]>0$，由于数组升序，三数之和大于0，对于i~N-1也一定不满足条件，直接终止外层循环。


**第三步：双指针扫描：** 使用对撞双指针$L=i+1$和$R=N-1$
- 若$sum<0$:L++;
- 若$sum>0$:R--;
- 若$sum==0$:找到一组解，记录并同时移动L，R，继续寻找。

> 难点攻克：如何完美去重？

题目要求解集不能包含重复的三元组。利用排序后的特性，我们在三个位置进行去重：
1. **外层去重：** `if(i>0&&A[i]==A[i-1])continue;`跳过相同的第一个数
2. **内层去重（L）：** 找到解后，若`A[L]==A[L+1]`，则`L++;`继续跳过
3. **内层去重（R）：** 找到解后，若`A[R]==A[R-1]`，则`R--;`继续跳过

**关键逻辑：** 去重应当在==找到第一个解之后==进行，或者在==移动指针之前==检查前一个元素，以确保不会漏掉合法的组合（如{0,0,0}）。

```cpp
class Solution {

public:

    vector<vector<int>> threeSum(vector<int>& nums) {

        int n = nums.size();

        sort(nums.begin(), nums.end());

        vector<vector<int>> res; for (int i = 0; i < n - 2; ++i) {

            if (nums[i] > 0) break;

            // 优化：最小数大于0则无解

            if (i > 0 && nums[i] == nums[i - 1]) continue;

            // 外层去重

            int L = i + 1, R = n - 1;

            while (L < R) {

                int sum = nums[i] + nums[L] + nums[R];

                if (sum == 0) {

                    res.push_back({nums[i], nums[L], nums[R]});

                    // 找到解后，在移动前进行内层去重

                    while (L < R && nums[L] == nums[L + 1]) L++;

                    while (L < R && nums[R] == nums[R - 1]) R--; L++; R--;

                }

                else if (sum < 0) L++;

                else R--;

            }

        }

        return res;

    }

};
```

##### [最接近的三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum-closest/submissions/686034563/?envType=problem-list-v2&envId=two-pointers)

>[!ABSTRACT]
>这道题是三数之和的核心变体。与寻找==等于零==的精确解不同，它要求寻找与target距离（绝对差值）最小的组合。算法结构保持$O(N^2)$，但更新逻辑从==相等判断==转向了==动态维护最小差值==。

>算法三部曲：排序、扫描与维护


**核心基石：** 预排序

==排序$(O(NlogN))$是应用双指针的前提：==
- 单调性引导：只有数组有序，我们才能通过sum与target的大小关系，确定是移动L++还是R--。
- 避免无效搜索：有序性让我们能够系统地排除掉那些只会让和变得更大（或更小）的无效组合。
**关键步骤：** 动态更新Closest
==在双指针移动的每一步，都要执行：==
1. 计算当前和：$currSum=A[i]+A[L]+A[R]$。
2. 比较差值：若$abs(currSum-target)<abs(ans-target)，则更新ans=curr$。
3. 确定方向：利用单调性，判断$currSum<target$并相应移动指针。
**高级优化：** 剪枝与提前返回
*虽然本题不要求去重，但以下优化能显著提升性能：*
- 提前退出：若$currSum==target$，差值为0，可立即返回结果。
- 跳过重复i：虽然结果不要求唯一，但跳过相同的$A[i]$能减少重复计算。

> 深度思考：为什么移动方向不变？

在本题中，移动指针的依据仍然是==单调性==，但目标是==逼近==而非==锁定==：
1. 若==Sum<target:== 
	- 当前的和比目标要小。为了减小差距，我们需要一个==更大==的数。
	- 由于数组已排序，向右移动左指针(L++)是唯一的增加和的方式。
2. 若==Sum>target:== 
	- 当前的和比目标要大。为了减小差距，我们需要一个==更小==的数。
	- 由于数组已排序，向左移动右指针(R--)是唯一的减小和的方式。
**证明：** 这种策略保证了我们不会错过任何可能更接近target的组合。如果在某一步$Sum<target$时我们选择移动R--，和只会更小，差距只会更大。

```cpp
class Solution {

public:

    int threeSumClosest(vector<int>& nums, int target) {

        int n = nums.size();

        sort(nums.begin(), nums.end());

        // 初始化为一个合理的三数之和

        int ans = nums[0] + nums[1] + nums[2];

        for (int i = 0; i < n - 2; ++i) {

            // 可选：跳过重复的 i 以优化性能

            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int L = i + 1, R = n - 1;

            while (L < R) {

                int currSum = nums[i] + nums[L] + nums[R];

                // 如果找到精确值，直接返回，这是最强的剪枝

                if (currSum == target) return target;

                // 更新当前最接近的和

                if (abs(currSum - target) < abs(ans - target))  ans = currSum;

                // 利用单调性确定移动方向

                if (currSum < target)  L++;  

                else  R--;

            }

        }

        return ans;  

    }

};
```

##### [ 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/?envType=problem-list-v2&envId=two-pointers)

> [!ABSTRACT]
> 四数之和是双指针算法的进一步延伸。其核心思想是==降维打击：== 通过两层嵌套循环固定前两个数，将4Sum转换为3Sum，再进一步转换为经典的2Sum（双指针）问题。将时间复杂度从暴力枚举的$O(N^4)$优化至==$O(N^3)$==。

> 降维策略：从4到2

**第一步：** 排序与双重固定

1. ==排序：== 同3Sum，排序是去重和单调性剪枝的前提。
2. ==固定i：== 外层循环遍历第一个数。
3. ==固定j：== 第二层循环从<font color=red>i+1</font>开始遍历第二个数。此时，目标值变为$target-nums[i]-nums[j]$。

**第二步：** 三数之和逻辑

在固定的i和j之后，剩余的区间\[j+1,n-1]实际上就是一个标准的3Sum后半部分。我们在这个区间内寻找两个数L和R，使得四数总和等于target。

**第三步：双指针扫描：** 使用对撞双指针$L=i+1$和$R=n-1$
- 若$sum<target$:L++;
- 若$sum>target$:R--;
- 若$sum==target$:找到一组解，记录并同时移动L，R，继续寻找。

> 高级剪枝优化

在$O(N^3)$的基础上，，我们可以利用排序特性进行进一步优化，显著提升实际运行速度：
1. **最小和判定：** 如果当前固定的数加上该区间后面最小的几个数仍==大于== target，则后续循环必无解，直接break;
	- 例：`nums[i]+nums[i+3]+nums[i+2]+nums[i+1]>target`。
2. **最大和判定：** 如果当前固定的数加上数组末尾最大的几个数仍然==小于== target，则当前索引i无解，直接continue进入下一个索引。
	- 例：`nums[i]+nums[n-3]+nums[n-2]+nums[n-1]>target`。
3. **溢出保护：** 此题的target范围较大，计数四数之和时务必用long long以防溢出。

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;               // 存储所有满足条件的四元组
        int n = nums.size();                   // 数组长度
        if (n < 4) return res;                 // 如果元素少于4个，直接返回空结果（不可能组成四元组）
        
        sort(nums.begin(), nums.end());        // 先排序，这是整个算法的基础
                                               // 排序后才能方便地使用双指针、去重和剪枝
        
        // 第一层循环：固定第一个数 nums[i]
        for (int i = 0; i < n - 3; ++i) {
            // 第一层去重：如果当前数和前一个数相同，跳过，避免重复四元组
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            
            // 剪枝优化1：当前 i 以及后面三个最小元素之和已经大于 target
            // 由于数组已排序，后面的元素只会更大，后续不可能找到更小的和，直接 break
            if ((long long)nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) break;
            
            // 剪枝优化2：当前 i 以及后面三个最大元素之和还小于 target
            // 说明以 nums[i] 开头的四元组最大都达不到 target，直接跳到下一个 i
            if ((long long)nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target) continue;
            
            // 第二层循环：固定第二个数 nums[j]
            for (int j = i + 1; j < n - 2; ++j) {
                // 第二层去重：如果当前 j 和前一个 j（同一个 i 下）相同，跳过
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;
                
                // 剪枝优化3：当前 i、j 以及后面两个最小元素之和已经大于 target
                // 后续双指针只会使和更大，直接 break 当前 j 循环
                if ((long long)nums[i] + nums[j] + nums[j+1] + nums[j+2] > target) break;
                
                // 剪枝优化4：当前 i、j 以及后面两个最大元素之和还小于 target
                // 说明以 nums[i], nums[j] 开头的四元组最大都达不到 target，直接跳到下一个 j
                if ((long long)nums[i] + nums[j] + nums[n-2] + nums[n-1] < target) continue;
                
                // 双指针寻找剩余的两个数
                int L = j + 1;      // 左指针，从 j 的右边开始
                int R = n - 1;      // 右指针，从数组末尾开始
                
                while (L < R) {
                    // 使用 long long 防止整数溢出（尤其是 target 为 INT_MIN 或 nums 中有大数时）
                    long long sum = (long long)nums[i] + nums[j] + nums[L] + nums[R];
                    
                    if (sum == target) {
                        // 找到一组合法四元组，加入结果
                        res.push_back({nums[i], nums[j], nums[L], nums[R]});
                        
                        // 第三层去重：跳过所有与当前 nums[L] 相同的元素
                        while (L < R && nums[L] == nums[L + 1]) L++;
                        // 第四层去重：跳过所有与当前 nums[R] 相同的元素
                        while (L < R && nums[R] == nums[R - 1]) R--;
                        
                        // 移动指针，继续寻找下一个可能的组合
                        L++;
                        R--;
                    }
                    else if (sum < target) {
                        // 和太小，需要增大，左指针右移
                        L++;
                    }
                    else {
                        // 和太大，需要减小，右指针左移
                        R--;
                    }
                }
            }
        }
        return res;
    }
};
```
### 2.字符串反转/字符交换

> 对数组或字符串进行原地反转，如反转字符串中的元首字母。

#### [按奇偶排序数组||](https://leetcode.cn/problems/sort-array-by-parity-ii/)

**核心逻辑：**  题目要求 A\[i] 的奇偶性与索引 i 一致。我们可以用两个指针：i 处理偶数下标，j 处理奇数下标。
  
**指针移动策略：**
   * i 指针不断跳过已经在偶数位上的偶数（i += 2）。
   * j 指针不断跳过已经在奇数位上的奇数（j += 2）。
   * 当 i 发现了一个奇数，且 j 发现了一个偶数时，交换这两个元素。
     ==这虽然不是标准的从两端向中间“撞”，但它利用了两个指针在同一区间内根据条件“错位寻找”并“交换”的逻辑。==

### 3.回文串检测

> 验证字符串是否为回文字符串，可以处理空格、特殊字符或大小不敏感的情况。

#### [ 最长回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-substring/submissions/685864282/?envType=problem-list-v2&envId=two-pointers)


**核心逻辑：** 中心扩展法
- 回文串的特性是中心对称的。我们可以遍历字符串的每一个位置，将其作为“中心”，向两边尝试扩展，直到不再满足回文条件为止。
- 由于回文串的长度可能是奇数或者偶数，我们需要考虑两种中心：
	- ==奇数长度：==中心是一个字符（aba，中心是b）
	- ==偶数长度：==中心是两个字符之间的间隙(abba,中心是bb)。

**指针移动策略：** 
1. ==指针移动与长度计算：==在expandArouondCenter函数中，当循环停止时，left和right已经指向了==不满足==回文条件的第一个字符。
	- ==左边界：==left+1
	- ==右边界：==right+1
	- ==长度公式：==$(right-1)-(left-1)+1=right=left-1$
2. ==起始位置start的推导：== 这是一个通用的数学小技巧，无论maxLen是奇数还是偶数都适用：
	- 假设中心索引为<font color=greeen>i</font>：
		- 奇数（长度3）：i=1,maxLen=3->start=1-(3-1)/2=0
		- 偶数（长度4）：i=1,maxLen=4->start=1-(4-1)/2=0
	- ==公式：== $start=i-(maxLen-1)/2$

```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {
        if (s.length() < 2) return s;

        int start = 0, maxLen = 0;

        for (int i = 0; i < s.length(); i++) {
            // 1. 奇数长度扩展 (如 "aba")
            int len1 = expandAroundCenter(s, i, i);
            // 2. 偶数长度扩展 (如 "abba")
            int len2 = expandAroundCenter(s, i, i + 1);

            int curMax = max(len1, len2);

            // 如果找到更长的回文，更新起始位置和最大长度
            if (curMax > maxLen) {
                maxLen = curMax;
                // 注意这里的起始点计算：
                // 如果长度为 3, 中心 i, start = i - (3-1)/2 = i - 1
                // 如果长度为 4, 中心 i 和 i+1, start = i - (4-1)/2 = i - 1
                start = i - (curMax - 1) / 2;
            }
        }

        return s.substr(start, maxLen);
    }

private:
    // 返回以 left, right 为中心向外扩展能达到的最长回文长度
    int expandAroundCenter(const string& s, int left, int right) {
        while (left >= 0 && right < s.length() && s[left] == s[right]) {
            left--;
            right++;
        }
        // 跳出循环时，s[left] != s[right]，所以有效长度是 (right - 1) - (left + 1) + 1
        return right - left - 1;
    }
};
```

### 4.定义区间边界

> 在有序数组或列表中，找到满足条件的最大/最小区间。

#### [接雨水](https://leetcode.cn/problems/trapping-rain-water/)
**核心逻辑：** 这是“盛最多水容器”的进阶版。每个位置能接多少水，取决于它左边最高的柱子和右边最高的柱子中的较小值。
   
**指针移动策略：** 维护两个变量 leftMax 和 rightMax。
   * 如果 leftMax < rightMax，说明左侧的瓶颈更低，当前左指针位置的蓄水量由 leftMax 决定，计算后 left++。
   * 反之，右侧瓶颈更低，由 rightMax 决定，计算后 right--。
     这本质上是利用对撞指针不断缩窄“确定区域”的边界。
```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size(), l = 0, r = 0, ans = 0;
        vector<int>lmax(n), rmax(n);
        for (int i = 0; i < n; i++) {
            lmax[i] = l > height[i] ? l : height[i];
            l = max(l, height[i]);
            rmax[n - 1 - i] = r > height[n - 1 - i] ? r : height[n - 1 - i];
            r = max(r, height[n-1-i]);
        }
        for (int i = 0; i < n; i++) {
            ans += max(0, min(lmax[i], rmax[i]) - height[i]);
        }
        return ans;
    }
};
```

#### [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

**核心逻辑：** 指针 left 指向开头，right 指向结尾。容器的容量由 min(height\[left], height\[right]) \times (right - left) 决定。

**指针移动策略：** 指针 left 指向开头，right 指向结尾。容器的容量由 min(height\[left], height\[right]) \times (right - left) 决定。

- 如果 height\[left] < height\[right]，则 left++。
- 反之，则 right--。

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int ans = 0;
        for (int l = 0, r = height.size() - 1; l <= r;) {
            ans = max(ans, min(height[l], height[r]) * (r - l));
            if (height[l] <= height[r])l++;
            else r--;
        }
        return ans;
    }
};
```

#### [供暖器](https://leetcode.cn/problems/heaters/)

**核心逻辑：** 为了让每个房屋都能被覆盖，我们需要找到每个房屋距离最近的供暖器的距离。总的最小半径就是所有这些“最近距离”中的最大值。
  
**指针移动策略：** 对房屋和供暖器都进行排序。遍历房屋，利用双指针寻找当前房屋左右两侧最近的供暖器。
   * 当下一个供暖器距离当前房屋更近时，移动供暖器指针 right++。
   * 不需要回溯，因为房屋也是有序的，之前的供暖器不会比当前的更近。
```cpp
class Solution {
public:
    int findRadius(vector<int>& houses, vector<int>& heaters) {
        int ans = 0;
        sort(houses.begin(), houses.end());
        sort(heaters.begin(), heaters.end());
        for (int l = 0, r = 0; l < houses.size(); l++) {
            while (r + 1 < heaters.size()&&!best(houses, heaters, l, r)) {
                r++;
            }
            ans = max(ans, (int)fabs(houses[l] - heaters[r]));
        }
        return ans;
    }

    int best(vector<int>& houses, vector<int>& heaters, int l, int r) {
        return fabs(houses[l] - heaters[r]) < fabs(houses[l] - heaters[r + 1]);
    }
};
```


---

# 2.快慢双指针


**核心原理：** 两个指针从同一位置（通常是链表头）出发，以不同的速度（快指针N步，慢指针一步）向前推进

**驱动力：** 该方法的核心优势在于==固定 步长差==，这使得他们在有环结构中必然相遇，或在无环结构中精确地测量出相互距离。

## 环入口逻辑的数学证明-（Floyd 判圈算法）

很多同学能记住代码，但容易忘记为什么==相遇后再走一遍== 就能找到入口。

**证明如下** ：
$$
1. 假设从链表头到环入口的距离为<font color=greeen>a</font>。
2. 假设从环入口到相遇点的距离为<font color=greeen>b</font>。
3. 假设环的剩余长度为<font color=greeen>c</font>（即==环的总长为b+c==)
4. ==相遇时：==
	- 慢指针走过的距离：$S=a+b$
	- 快指针走过的距离：$F=a+b+n(b+c)$（<font color=greeen>n</font>为快指针绕环的圈数)
5. 因为快指针速度是慢指针的两倍，所以$F=2S$：
	$a+b+n(b+c)=2(a+b)$
	化简得到：
	$a=n(b+c)-b=(n-1)(b+c)+c$
6. ==结论：== $a=(n-1)*环长+c$。这意味着，如果你从链表头走a步，等同于从相遇点出发绕环n-1圈后再走c步。两者最终都会在环入口处重合。
$$$
## 常见应用场景（以链表为主）

### 1.环检测

#### 1.链表中找环

> 利用快慢指针的相对速度证明，在有环中它们必然相遇。

##### [141. 环形链表 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle/description/)

**核心逻辑：** 利用快慢指针的速度差。如果链表有环，==快指针最终一定会从后方追上慢指针==；若无环，==快指针会先指向空==。

**指针移动策略：** 
- slow 每次移动 <font color=greeen>1</font> 步，fast 每次移动 <font color=greeen>2</font> 步。
- 若 fast == slow，判定为有环。
- ==不需要考虑越界回溯==，因为 fast 永远领先，只需判断 ==fast== 和==fast->next ==是否为空。

```cpp
class Solution {

public:

    bool hasCycle(ListNode* head) {

        ListNode*slow=head;        

        ListNode*fast=head;  

        while(fast&&fast->next){  

            slow=slow->next;  

            fast=fast->next->next;  

            if(fast==slow)return true;  

        }

        return false;                                                                                                                                  

    }

};
```

#### 2.根据映射找环

##### [快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/)

**核心逻辑：** *映射找环*。将数值的==平方和操作==抽象为==链表的next指针==。如果数值==陷入循环且不为1==，则不是快乐数。

**指针移动策略：** 
- slow算一次平方和，fast算两次平方和。
- 利用快慢指针判断是否进入==非1==的循环。

```cpp
 class Solution {    
public:    
    // 核心驱动：相当于链表的 next 指针
    int getNext(int n) {    
        int totalSum = 0;    
        while (n > 0) {    
            int d = n % 10;    
            n /= 10;    
            totalSum += d * d;    
        }
        return totalSum;    
    }

    bool isHappy(int n) {    
        int slow = n;        
        int fast = getNext(n); // 快指针先行一步
        
        // 当快指针没达到 1 且 两人没相遇时继续
        while (fast != 1 && slow != fast) {    
            slow = getNext(slow);         // 走 1 步    
            fast = getNext(getNext(fast)); // 走 2 步                                            
        }
        
        // 最终判断是因为变成 1 停下的，还是因为撞上(有环)停下的
        return fast == 1;  
    }
};
```

### 2.寻找环的入口/长度

> 在确定有环后，通过二次相遇定位环的起始节点。

#### 1.链表中找环入口

##### [ 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

**核心逻辑：** 在确定优化后，利用$a=(n-1)*环长+c$，通过==二次相遇==精确定位入口。

**指针移动策略：** 
- 第一阶段：快慢指针找相遇点。
- 第二阶段：将==slow重置到head==，fast留到相遇点。
- 同步移动：双指针同时每次走<font color=greeen>1</font>，再次相遇处即为环入口。

```cpp
class Solution {

public:

    ListNode* detectCycle(ListNode* head) {

        ListNode* fast = head;

        ListNode* slow = head;

        while (fast && fast->next) {

            slow = slow->next;

            fast = fast->next->next;

            if (fast == slow) {

                slow = head;

                while (slow != fast) {

                    slow = slow->next;

                    fast = fast->next;

                }

                return slow;

            }

        }

        return nullptr;

    }

};
```

#### 2.数组中找环入口

#### [寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/description/)

**核心逻辑：** *数组建模为链表*。将索引<font color=greeen>i</font>看作节点，==$nums[i]$看作$next$指针==。由于存在重复数字，必然会出现多个节点指向同一个位置，从而形成环。

**指针移动策略：** 
- 由于数组必然存在环且入口就是重复数，直接套用==寻找环入口==的策略。
- `slow=nums[slow],fast=nums[nums[fast]]`
- 相遇后，==重置一个指针==到起点0，同步移动寻找入口。


```cpp
class Solution {

public:

    int findDuplicate(vector<int>& nums) {

        int slow = nums[0];

        int fast = nums[nums[0]];

  

        // 1. 寻找相遇点

        while (slow != fast) {

            slow = nums[slow];

            fast = nums[nums[fast]];

        }

  

        // 2. 寻找环入口（重复数）

        int pre1 = 0;

        int pre2 = slow;

        while (pre1 != pre2) {

            pre1 = nums[pre1];

            pre2 = nums[pre2];

        }

        return pre1;

    }

};
```

### 3.寻找链表的中点

> 快指针走完时，慢指针恰好停留在中点。

#### [链表的中间结点 - 力扣（LeetCode）](https://leetcode.cn/problems/middle-of-the-linked-list/)

**核心逻辑：** *速度倍数法*。当快指针到达终点（2倍距离）时，慢指针恰好停留在路程达到一半位置。

**指针移动策略：**
- slow走一步，fast走2步数。
- ==fast为空==（偶数长度）或==fast->next==为空（奇数长度）时停止。
- 此时slow指向的即为中点。

```cpp
class Solution {

public:

    ListNode* middleNode(ListNode* head) {

        ListNode* fast = head;

        ListNode* slow = head;

        while (fast && fast->next) {

            fast = fast->next->next;

            slow = slow->next;

        }

        return slow;

    }

};
```
### 4.寻找倒数第K个节点

> 先让快指针先行K步，再与慢指针同步移动，保持固定间隔。

#### [删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

**核心逻辑：** *固定间隔法*。通过让快指针先行<font color=greeen>n</font>步，建立一个长度为<font color=greeen>n</font>的窗口，随后窗口整体平移。

**指针移动策略：** 
- fast先行n步（若要删除节点，通常用==dummy节点并先行n+1步==以便定位前驱）。
- slow和fast随后以==相同速度==（1步）移动。
- 当fast指向末尾nullptr时，slow恰好在目标位置。


```cpp
class Solution {

public:

    ListNode* removeNthFromEnd(ListNode* head, int n) {

        ListNode dummy(0, head);

        ListNode* slow = &dummy, * fast = &dummy;

        while (n--)fast = fast->next;

        while (fast && fast->next) {

            fast = fast->next;

            slow = slow->next;

        }

        slow->next = slow->next->next;

        return dummy.next;

    }

};
```

---

# 3.同向双指针


**核心原理：** 两个指针<font color=greeen>i</font>和<font color=greeen>j</font>同向移动，但不用于定义一个动态区间（如滑动窗口）。它们常用于对数组进行原地修改、去重或在不同序列中进行同步比较。

**驱动力：** 通过一个指针负责==读==，另一个指针负责==写==或==标记==，实现单词遍历完成复杂操作。

#### [加油站](https://leetcode.cn/problems/gas-station/)

## 常见应用场景

### 1.单序列异速处理

> 使用快慢指针，快指针遍历所有元素，慢指针记录有效元素的位置，实现原地去重。

### 2.多序列并行处理

> 在两个独立的字符串/序列中移动指针，寻找一种映射关系

##### 1.同步模式
**特征：** 指针i和j的移动是==强关联==的，不管谁的大，为了完成任务，通常都要一起推进。。
**典型场景：** 向量点积、字符串相加、求交集

###### [两数相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-two-numbers/description/?envType=problem-list-v2&envId=linked-list)

**核心逻辑：** 模拟算术加法，每一位都要同时考虑两个加数和进位。

**指针移动逻辑：** 同步移动，l1和l2在每轮循环通常都后移。

**驱动逻辑：** 算术加法和进位机制。

**边界处理：** 处理l1或l2先到达末尾的情况（补0）。

**结果生成：** 每次循环创建一个新节点存和的个位。

```cpp
class Solution {

public:

    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        ListNode dummy;

        ListNode* cur = &dummy;

        int carry = 0;

        for (int val = 0,sum=0;

            l1 || l2;

            l1 = l1 == nullptr ? nullptr : l1->next,

            l2 = l2 == nullptr ? nullptr : l2->next) {

            sum = (l1 == nullptr ? 0 : l1->val) + (l2 == nullptr ? 0 : l2->val) + carry;

            val = sum % 10;

            carry = sum / 10;

            ListNode* node = new ListNode(val);

            cur->next = node;

            cur = cur->next;

        }

        if (carry > 0) {

            ListNode* node = new ListNode(carry);

            cur->next = node;

        }

        return dummy.next;

    }

};
```

##### 2.选择模式

**特征：** 指针i和j的移动是==竞争==关系。只有胜出（满足较小或较大条件）的指针才会前进。
**典型场景：** 合并排序、归并排序、判断子序列（其中一个指针仅在匹配时移动）

###### [ 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/?envType=problem-list-v2&envId=linked-list)

**核心逻辑：** 排序，即在两个当前的候选节点中做出==二选一==的决定。

**指针移动策略：** 非同步移动，仅移动值较小的那个指针。

**驱动逻辑：** 大小比较。

**边界处理：** 当一个链表耗尽，直接连接另一个链表的剩余部分。

**结果生成：** 通常复用原链表节点进行拼接。

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode dummy;
    dummy.next=NULL;
    struct ListNode* res;
    res=&dummy;
    while(list1&&list2){
        if(list1->val<list2->val){
            res->next=list1;
            list1=list1->next;
        }
        else{
            res->next=list2;
            list2=list2->next;
        }
        res=res->next;
    }
    if(list1){
        res->next=list1;
    }
    else{
        res->next=list2;
    }
    return dummy.next;
}
```
### 3.双指针从后向前遍历

> 从字符串或数组的末尾开始向前扫描，常用于处理退格符或寻找末尾单词


#### [ 合并两个有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-sorted-array/description/)
- **核心逻辑：** 利用 `nums1` 后部的空闲空间。如果我们从前向后合并，必须移动 `nums1` 的元素来腾位置，导致 $O(n^2)$ 复杂度；从后向前合并，则可以直接将较大的元素填入末尾。
- **指针策略：**
    
    - `p1`：指向 `nums1` 有效元素的末尾 (`m-1`)。
        
    - `p2`：指向 `nums2` 的末尾 (`n-1`)。
        
    - `p`：指向 `nums1` 容器的最后位置 (`m+n-1`)。


```cpp
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int p1 = m - 1, p2 = n - 1, p = m + n - 1;
    while (p2 >= 0) { // 只要 nums2 没写完就继续
        if (p1 >= 0 && nums1[p1] > nums2[p2]) {
            nums1[p--] = nums1[p1--];
        } else {
            nums1[p--] = nums2[p2--];
        }
    }
}
```

---

#### [ 比较含退格的字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/backspace-string-compare/)

- **核心逻辑：** 退格符 `#` 只影响它**左边**的字符。如果从后向前遍历，我们可以提前知道当前字符是否会被删除。
    
- **指针策略：**
    
    - 从 `S` 和 `T` 的末尾开始。
        
    - 使用 `skip` 变量记录遇到的 `#` 数量。
        
    - 如果遇到 `#`，`skip++`；如果遇到普通字符且 `skip > 0`，则跳过该字符并 `skip--`。
```cpp
bool backspaceCompare(string s, string t) {
    int i = s.length() - 1, j = t.length() - 1;
    int skipS = 0, skipT = 0;
    while (i >= 0 || j >= 0) {
        while (i >= 0) { // 找到 s 中下一个有效字符
            if (s[i] == '#') { skipS++; i--; }
            else if (skipS > 0) { skipS--; i--; }
            else break;
        }
        while (j >= 0) { // 找到 t 中下一个有效字符
            if (t[j] == '#') { skipT++; j--; }
            else if (skipT > 0) { skipT--; j--; }
            else break;
        }
        if (i >= 0 && j >= 0) {
            if (s[i] != t[j]) return false;
        } else if (i >= 0 || j >= 0) return false; // 一个结束了一个没结束
        i--; j--;
    }
    return true;
}
```

---

#### [ 最后一个单词的长度 - 力扣（LeetCode）](https://leetcode.cn/problems/length-of-last-word/)

- **核心逻辑：** 既然只需要“最后一个”单词，从尾部开始扫描可以最快跳过末尾的空格并锁定目标单词，无需关心前面的内容。
    
- **指针策略：**
    
    - 从末尾开始，第一个 `while` 循环跳过所有空格。
        
    - 第二个 `while` 循环统计连续字母的数量，直到再次遇到空格或字符串开头。
 
```cpp
int lengthOfLastWord(string s) {
    int i = s.length() - 1;
    while (i >= 0 && s[i] == ' ') i--; // 跳过尾部空格
    int end = i;
    while (i >= 0 && s[i] != ' ') i--; // 计算单词长度
    return end - i;
}
```

---

#### [ 路径加密 - 力扣（LeetCode）](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

- **核心逻辑：** 每一个空格替换为三个字符（`%20`），会导致字符串变长。从后向前替换可以避免在替换前面空格时，频繁向后搬移后续所有字符。
    
- **指针策略：**
    
    - 先遍历一遍计算空格数，扩充原字符串长度。
        
    - `i`：指向原字符串末尾。
        
    - `j`：指向扩容后的新末尾。
        
    - 从后向前移动，遇到普通字符直接填入；遇到空格填入 `0`, `2`, `%`。

```cpp
string pathEncryption(string s) {
    int count = 0, oldSize = s.size();
    for (char c : s) if (c == ' ') count++;
    s.resize(oldSize + count * 2); // 扩容
    for (int i = oldSize - 1, j = s.size() - 1; i < j; i--, j--) {
        if (s[i] == ' ') {
            s[j] = '0'; s[j - 1] = '2'; s[j - 2] = '%';
            j -= 2;
        } else {
            s[j] = s[i];
        }
    }
    return s;
}
```


---

# 4.滑动窗口

**核心原理：** 这是同向双指针的最高级应用，使用两个指针<font color=greeen>L</font>（左边界）和<font color=greeen>R</font>（右边界）维护一个==动态变化的连续区间==。

**驱动力：** ==单调性==和==哈希表/字典==是其关键辅助工具。

## 滑动窗口通用模板（详解）

> 绝大多数滑动窗口问题都可以套用以下四步法。

```cpp
/* 滑动窗口通用模板 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> window; // 记录窗口内状态（频数、总和等）
    
    int left = 0, right = 0;
    int valid = 0; // 满足条件的计数器（可选）
    
    while (right < s.size()) {
        // 【1. 进窗】：a 是将移入窗口的字符
        char a = s[right];
        right++; // 右移窗口边界
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        // printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 【2. 收缩】：判断左侧窗口是否要收缩
        // 求最长时：通常是 if (窗口不合法) 
        // 求最短时：通常是 while (窗口合法)
        while (window needs shrink) {
            // 【3. 出窗】：d 是将移出窗口的字符
            char d = s[left];
            left++; // 左移窗口边界
            // 进行窗口内数据的一系列更新
            ...
        }
        
        // 【4. 更新结果】：在这里更新最终答案
        // 求最长：在 while 循环外更新（此时窗口必定合法）
        // 求最短：在 while 循环内更新（此时窗口刚好合法）
    }
}
```

### 核心模板差异对比：

- **求最长（如：无重复最长子串）**：$L$ 的收缩是为了**恢复**合法性。只有当窗口不合法（如出现重复）时才收缩 $L$。结果在 $L$ 停止移动后（`while` 循环外）更新。
    
- **求最短（如：长度最小子数组）**：$L$ 的收缩是为了**挑战**合法性。只要窗口目前是合法的，$L$ 就不断右移尝试寻找更短的可能。结果在 $L$ 移动过程中（`while` 循环内）更新。
    

## 常见应用场景及分类

### 1. 定长滑动窗口


> **题型摘要**：窗口大小 $K$ 恒定。题目通常要求在所有长度为 $K$ 的连续子数组中找到某种最优解。
>  **通用解法**：进一个 $nums[R]$，出一个 $nums[R-K]$。无需 `while`，用 `if` 处理边界。

#### [子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/ "null")

- **核心逻辑**：将连续子数组求和转化为增量计算。在一个固定长度为 $k$ 的窗口移动时，新窗口的和等于旧窗口的和加上新进入的元素并减去移出的元素，从而实现 $O(1)$ 的状态转移。
    
- **指针移动策略**：
    
    1. **初始化**：$R$ 指针先从 $0$ 移动到 $k-1$，计算出第一个窗口的总和。
        
    2. **滑动阶段**：$R$ 继续向右移动，每走一步，$L$ 指针也同步向右移动一步（即 $L = R - k + 1$）。
        
    3. **状态更新**：每次滑动，从总和中减去 `nums[R-k]`，加上 `nums[R]`。
        

```cpp
double findMaxAverage(vector<int>& nums, int k) {
    double sum = 0;
    // 1. 初始化第一个窗口
    for (int i = 0; i < k; i++) sum += nums[i];
    double maxSum = sum;
    // 2. R从k开始滑动
    for (int i = k; i < nums.size(); i++) {
        // 3. 核心逻辑：加新进的nums[i], 减去刚离开窗口的nums[i-k]
        sum += nums[i] - nums[i - k];
        maxSum = max(maxSum, sum); // 更新最大全局和
    }
    return maxSum / k;
}
```

#### [定长子串中元音字母的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/ "null")

- **核心逻辑**：维护一个计数器记录窗口内元音字符的数量。通过布尔函数实时判断边界变化对计数器的影响。
    
- **指针移动策略**：
    
    1. **进**：$R$ 指针右移。如果是元音，计数器 `cnt++`。
        
    2. **满**：当窗口长度超过 $k$（即索引 $i \ge k$）时，判断离开窗口的元素（索引为 $i-k$）。
        
    3. **出**：如果离开的元素是元音，计数器 `cnt--`。
        

```cpp
int maxVowels(string s, int k) {
    auto isVowel = [](char c) { return c=='a'||c=='e'||c=='i'||c=='o'||c=='u'; };
    int cnt = 0, res = 0;
    for (int i = 0; i < s.size(); i++) {
        // 右边界新进入元素判断
        if (isVowel(s[i])) cnt++; 
        // 窗口左边界同步移出判断（当索引达到k及以上时）
        if (i >= k && isVowel(s[i - k])) cnt--; 
        res = max(res, cnt); // 记录窗口滑动过程中的最大值
    }
    return res;
}
```

#### [爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/ "null")

- **核心逻辑**：将问题拆分为“固定收益”和“额外挽回收益”。使用滑动窗口寻找在 $minutes$ 长度内，老板生气（`grumpy[i]==1`）时对应的顾客数总和的最大值。
    
- **指针移动策略**：
    
    1. **基础统计**：遍历数组，若 `grumpy[i]==0`，直接加入总分。
        
    2. **增量滑动**：$R$ 指针移动，若当前分钟老板生气，累加 `customers[R]` 到 `extra`。
        
    3. **窗口平移**：一旦 $R \ge minutes$，检查刚离开窗口的 `R-minutes` 分钟。如果那天老板生气，则从 `extra` 中扣除那天的顾客数。
        

```cpp
int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
    int base = 0, extra = 0, maxExtra = 0;
    for (int i = 0; i < customers.size(); i++) {
        // 1. 基础收益：老板本身不生气时能得到的顾客
        if (!grumpy[i]) base += customers[i]; 
        // 2. 窗口进：如果老板生气，这部分是可以通过“秘密技巧”挽回的潜在收益
        if (grumpy[i]) extra += customers[i];
        // 3. 窗口出：维持窗口长度为minutes，移出过期分钟的挽回收益
        if (i >= minutes && grumpy[i - minutes]) {
            extra -= customers[i - minutes];
        }
        maxExtra = max(maxExtra, extra); // 寻找挽回收益的最大可能
    }
    return base + maxExtra;
}
```

### 2. 变长滑动窗口：求最长

>**题型摘要**：找到满足约束（如无重复）的**最长**连续区间。
> **通用解法**：$R$ 无脑扩张，$L$ 在**不合法**时收缩恢复合法性，在 `while` 外更新结果。

#### [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/ "null")

- **核心逻辑**：利用哈希思想确保窗口内不存在重复。当新加入字符产生冲突时，通过收缩左边界来消除冲突，从而维持窗口的合法性。
    
- **指针移动策略**：
    
    1. **右移扩张**：$R$ 移动并增加当前字符的出现频次。
        
    2. **冲突判断**：如果当前字符的频次 $> 1$，说明重复了。
        
    3. **左移收缩**：$L$ 不断右移，每移出一个字符就减少其频次，直到 $R$ 所指字符的频次降回 $1$。
        

```cpp                        
int lengthOfLongestSubstring(string s) {                                                                                                                                                                                                                                                              
    int cnt[128] = {0}, L = 0, res = 0;  
    for (int R = 0; R < s.size(); R++) {  
        cnt[s[R]]++; // 1. R右移：记录当前字符
        // 2. 核心：如果当前字符重复了，开始移动L
        while (cnt[s[R]] > 1) {  
            cnt[s[L++]]--; // 3. L右移：直到移出那个重复的字符
        }
        res = max(res, R - L + 1); // 4. 更新无重复区间的最大长度
    }
    return res;  
}
```

#### [每个字符最多出现两次的最长子数组](https://leetcode.cn/problems/maximum-length-of-a-concatenated-string-with-unique-characters/ "null")

- **核心逻辑**：逻辑同“无重复子串”，只是将重复的判定标准从 $1$ 次改为 $2$ 次。窗口内通过哈希统计频率，确保所有字符频率 $\le 2$。
    
- **指针移动策略**：
    
    1. **累加**：$R$ 移动并对 `nums[R]` 计数。
        
    2. **收缩**：若 `count[nums[R]]` 达到 $3$，$L$ 必须右移并递减经过元素的计数。
        
    3. **停止**：直到 `count[nums[R]]` 恢复为 $2$。
        

```cpp
int maxSubarrayLength(vector<int>& nums, int k) {  
    unordered_map<int, int> cnt;  
    int L = 0, res = 0;  
    for (int R = 0; R < nums.size(); R++) {  
        cnt[nums[R]]++; // 1. R进窗口并记录频率
        // 2. 核心逻辑：若某数字出现超过2次，开始收缩L
        while (cnt[nums[R]] > 2) {  
            cnt[nums[L++]]--; // 3. L移动并减少频率
        }
        res = max(res, R - L + 1); // 4. 统计满足条件的区间长度
    }
    return res;  
}
```

#### [最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/ "null")

- **核心逻辑**：将“翻转 $k$ 个 $0$”转化为“窗口内最多允许包含 $k$ 个 $0$”。寻找满足该条件的最长窗口。
    
- **指针移动策略**：
    
    1. **探测**：$R$ 移动，如果遇到 $0$，则消耗一个翻转额度（`zeroCnt++`）。
        
    2. **越界收缩**：如果 `zeroCnt > k`，说明 $0$ 太多了，额度不足。
        
    3. **额度回收**：$L$ 右移。如果 $L$ 移出的是 $0$，则回收一个额度（`zeroCnt--`）。
        

```cpp
int longestOnes(vector<int>& nums, int k) {
    int L = 0, zeroCnt = 0, res = 0;
    for (int R = 0; R < nums.size(); R++) {
        // 1. 遇到0，增加计数
        if (nums[R] == 0) zeroCnt++;
        // 2. 核心逻辑：若0的个数超过了k，必须收缩L
        while (zeroCnt > k) {
            if (nums[L++] == 0) zeroCnt--; // 3. 移出0时，计数减1
        }
        res = max(res, R - L + 1); // 4. 更新窗口最大宽度
    }
    return res;
}
```

#### [替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/ "null")

- **核心逻辑**：窗口内“除了出现次数最多的字母外，其余字母的总数”不能超过 $k$。使用 `maxFreq` 记录历史上窗口中出现频次最高的字符数。
    
- **指针移动策略**：
    
    1. **统计**：$R$ 移动并更新当前字母频率及 `maxFreq`。
        
    2. **判定**：计算 `(R - L + 1) - maxFreq`。这代表当前窗口内非主流字母的数量。
        
    3. **平移**：如果该值 $> k$，说明无法通过 $k$ 次替换达到平衡，则 $L$ 右移一步（通过平移而非全量收缩来维持寻找“最大”的潜力）。
        

```cpp
int characterReplacement(string s, int k) {
    int cnt[26] = {0}, maxFreq = 0, L = 0, res = 0;
    for (int R = 0; R < s.size(); R++) {
        // 1. 记录当前字母频数并更新窗口内的最高频次
        maxFreq = max(maxFreq, ++cnt[s[R] - 'A']);
        // 2. 核心逻辑：(窗口总长 - 最高频字母数) 即为必须被替换的字符数
        if (R - L + 1 - maxFreq > k) {
            cnt[s[L++] - 'A']--; // 3. 替换名额不足，L右移缩小窗口
        }
        // 4. 注意：此处不需循环收缩，因为我们求的是“最长”，maxFreq不减小结果就不会更优
        res = max(res, R - L + 1);
    }
    return res;
}
```

### 3. 变长滑动窗口：求最短

>**题型摘要**：找到满足约束（如和 $\ge S$）的**最短**连续区间。
> **通用解法**：$R$ 扩张直到**满足条件**，随后 $L$ 进入 `while` 尝试**收缩到极致**，在 `while` 内更新结果。

#### [长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/ "null")

- **核心逻辑**：只要窗口和达到目标，就不断尝试从左边剔除元素，看是否依然能满足条件，从而锁定最短长度。
    
- **指针移动策略**：
    
    1. **求和**：$R$ 向右移动累加。
        
    2. **寻找边界**：当 `sum >= target` 时，开始内层循环。
        
    3. **收缩**：记录当前长度 `R-L+1`，然后 $L$ 右移并减去 `nums[L]`，直到和重新变小。
        

```cpp
int minSubArrayLen(int target, vector<int>& nums) {
    int L = 0, sum = 0, res = INT_MAX;
    for (int R = 0; R < nums.size(); R++) {
        sum += nums[R]; // 1. 累加R指向的值
        // 2. 核心逻辑：满足条件时，尝试收缩L以寻找最短长度
        while (sum >= target) {
            res = min(res, R - L + 1); // 更新最小长度
            sum -= nums[L++];          // 3. L右移并减小和
        }
    }
    return res == INT_MAX ? 0 : res;
}
```

#### [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/ "null")

- **核心逻辑**：双哈希映射平衡法。通过 `valid` 变量记录已满足 $T$ 中字符要求的字符种类数。只有当 `valid` 等于 $T$ 的不同字符种数时，才代表窗口包含 $T$。
    
- **指针移动策略**：
    
    1. **寻找可行解**：$R$ 右移，将字符存入 `window`，若某字符频数达标，`valid++`。
        
    2. **寻找最优解**：当 `valid` 达标，开始收缩 $L$。
        
    3. **打破状态**：记录结果后，$L$ 右移，若移出的字符导致频数不再达标，`valid--`。
        

```cpp
string minWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++; // 初始化目标频率
    int L = 0, R = 0, valid = 0, start = 0, len = INT_MAX;
    while (R < s.size()) {
        char c = s[R++]; // 1. R右移
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c]) valid++; // 某种字符数量达标
        }
        // 2. 核心逻辑：当所有种类都达标，进入收缩阶段
        while (valid == need.size()) {
            if (R - L < len) { start = L; len = R - L; } // 更新最小子串
            char d = s[L++]; // 3. L尝试右移精简窗口
            if (need.count(d)) {
                if (window[d] == need[d]) valid--; // 导致不达标，跳出内层循环
                window[d]--;
            }
        }
    }
    return len == INT_MAX ? "" : s.substr(start, len);
}
```

### 4. 变长滑动窗口：求个数/计数

>**题型摘要**：统计满足条件的连续子数组**总数**。 
>**通用解法**：基于组合数学。若 $[L, R]$ 合法，则以 $R$ 为右边界的合法子数组共有 `R - L + 1` 个。

#### [乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/ "null")

- **核心逻辑**：基于组合计数思想。在一个窗口 $[L, R]$ 满足乘积要求时，以 $R$ 为右边界的所有连续子数组（如 $[R], [R-1, R]...[L, R]$）必然也满足要求。
    
- **指针移动策略**：
    
    1. **累乘**：$R$ 右移并将 `nums[R]` 乘入乘积。
        
    2. **排除**：如果乘积 $\ge k$，$L$ 右移并除以 `nums[L]`。
        
    3. **累加**：合格窗口内子数组个数等于窗口长度 `R - L + 1`。
        

```cpp
int numSubarrayProductLessThanK(vector<int>& nums, int k) {
    if (k <= 1) return 0; // 边界情况
    int L = 0, prod = 1, ans = 0;
    for (int R = 0; R < nums.size(); R++) {
        prod *= nums[R]; // 1. R乘入
        // 2. 核心逻辑：乘积过大则L收缩
        while (prod >= k) prod /= nums[L++];
        // 3. 关键计数：以当前R为终点的符合条件的子数组总数
        ans += R - L + 1; 
    }
    return ans;
}
```

#### [最多有 K 个不同整数的子数组](https://www.google.com/search?q=https://leetcode.cn/problems/subarrays-with-at-most-k-different-integers/ "null")

- **核心逻辑**：差分技巧。求“恰好 $k$ 个”通常很难，但求“最多 $k$ 个”很容易。公式为：`Exactly(K) = atMost(K) - atMost(K-1)`。
    
- **指针移动策略**（针对 `atMost` 函数）：
    
    1. **记录**：$R$ 移动。如果是新数字，`maxK--`。
        
    2. **排除**：若不同数字太多（`maxK < 0`），$L$ 右移。当移出的数字频数归零，说明腾出了一个名额，`maxK++`。
        
    3. **统计**：每次移动 $R$ 后累加窗口长度。
        

```cpp
int subarraysWithKDistinct(vector<int>& nums, int k) {
    // 定义辅助函数：求不同整数个数 <= maxK 的子数组总数
    auto atMost = [&](int maxK) {
        unordered_map<int, int> cnt;
        int L = 0, res = 0;
        for (int R = 0; R < nums.size(); R++) {
            if (cnt[nums[R]]++ == 0) maxK--; // 遇到新数字，名额减1
            // 核心逻辑：当种类超过限制，收缩L
            while (maxK < 0) {
                if (--cnt[nums[L++]] == 0) maxK++; // 某种数字绝迹，名额加1
            }
            res += R - L + 1; // 满足“最多包含maxK个”的以R结尾的数量
        }
        return res;
    };
    // 恰好k = (最多k) - (最多k-1)
    return atMost(k) - atMost(k - 1);
}
```

### 5. 子串排列/异位词

>**题型摘要**：寻找字符种类和频数完全一致的区间。 
>**通用解法**：定长滑窗的进阶应用，使用频率数组作为判定依据。

#### [字符串的排列](https://leetcode.cn/problems/permutation-in-string/ "null")

- **核心逻辑**：全排列等价于两个字符串的字符频率数组完全相同。利用定长滑动窗口维护 $S2$ 的局部频率。
    
- **指针移动策略**：
    
    1. **预处理**：先将 $S1$ 全部字符及 $S2$ 的前 `s1.size()` 个字符计入两个数组。
        
    2. **比对**：判断两个频率数组是否相等。
        
    3. **滑动**：$R$ 从 `s1.size()` 开始。$R$ 增加计数值，离开窗口的元素减少计数值。
        

```cpp
bool checkInclusion(string s1, string s2) {
    if (s1.size() > s2.size()) return false;
    vector<int> c1(26), c2(26);
    // 1. 初始化频率比对表
    for (int i = 0; i < s1.size(); i++) {
        c1[s1[i] - 'a']++;
        c2[s2[i] - 'a']++;
    }
    // 2. 核心逻辑：检查初始窗口
    if (c1 == c2) return true;
    // 3. 指针策略：定长R滑动，同步计算出入差
    for (int i = s1.size(); i < s2.size(); i++) {
        c2[s2[i] - 'a']++;            // 进R
        c2[s2[i - s1.size()] - 'a']--; // 出L
        if (c1 == c2) return true;    // 逻辑：频率完全一致则是排列
    }
    return false;
}
```

#### [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/ "null")

- **核心逻辑**：原理同上，即寻找所有字符频率数组与目标 $P$ 一致的窗口起始点。
    
- **指针移动策略**：维护定长窗口，每滑动一步，进行一次频率数组相等性检查。若满足，记录窗口最左端索引。
    

```cpp
vector<int> findAnagrams(string s, string p) {
    int ns = s.size(), np = p.size();
    if (ns < np) return {};
    vector<int> sc(26), pc(26), res;
    // 1. 初始填充频率表
    for (int i = 0; i < np; i++) {
        pc[p[i] - 'a']++;
        sc[s[i] - 'a']++;
    }
    // 2. 核心逻辑：对比第一个窗口
    if (sc == pc) res.push_back(0);
    // 3. 指针策略：定长滑动
    for (int i = np; i < ns; i++) {
        sc[s[i] - 'a']++;        // 进
        sc[s[i - np] - 'a']--;   // 出
        if (sc == pc) res.push_back(i - np + 1); // 4. 匹配成功记录起点
    }
    return res;
}
```

## 总结：双指针解题策略表

|类型|指针移动方向|适用场景|核心技巧|
|---|---|---|---|
|**对撞指针**|两端向中间|有序数组、对称问题|利用单调性缩减空间|
|**快慢指针**|同向、步长不同|链表、循环检测|构造路程差/时间差|
|**同向指针**|同向、步长相同|数组去重、原地修改|读写指针分离|
|**滑动窗口**|同向、维护区间|子串、子数组问题|窗口更新规则|

**码字不易，如果这篇笔记对你有帮助，欢迎「点赞 + 收藏 + 关注」，你的支持是我持续创作的动力！**