> [!ABSTRACT]
> **双指针是一种核心的优化思路，用于将O(n^2)的暴力遍历优化为O(n)的线性时间复杂度。其题型可根据指针的==移动方向、步长和作用目标==划分为四个主要类别，覆盖了数组、字符串和链表三大核心数据结构**  

---
# 1.对撞双指针

**核心原理：** 两个指针分别从数组或字符串的两端（头和尾）开始，相向移动，知道相遇或交叉。

**驱动力：** 该方法几乎总是依赖于数据结构（尤其是数组）的==有序性==或问题的==对称性==（如回文串），并利用[[7.单调性]]进行高效剪枝。
## 常见应用场景

### 1.两数之和/多数之和

> 在有序数组中快速查找和为目标值的元素对（或多对）。

#### 1.两数之和
##### [两数之和||-输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

**核心问题：** 在一个==有序数组==中，找到相加之和等于目标值T的两个数。

**指针策略：** 设置左指针L\[0]和右指针R\[N-1]。

**单调性：** 利用A\[L]+A\[R]的和的单调性来指导移动：
- 若和>T，则==必须==R--（减小和）。
- 若和<T，则==必须==L++（增大和）。

```cpp
class Solution {
public:
    std::vector<int> twoSum(std::vector<int>& numbers, int target) {
        int L = 0; // 左指针
        int R = numbers.size() - 1; // 右指针
        while (L < R) { 
	        int currentSum = numbers[L] + numbers[R];
	        if (currentSum == target) { 
		        // 找到解。题目要求返回 1-based 索引 
		        return {L + 1, R + 1};
	        } else if (currentSum < target) { 
		        // 和太小，L 必须右移增大和 
		        L++;
	        } else { 
		        // currentSum > target // 和太大，R 必须左移减小和 
		        R--; 
	        } 
	    } // 题目保证有唯一解，实际不会到达这里 
	    return {}; 
	} 
};
```

##### [救生 艇](https://leetcode.cn/problems/boats-to-save-people/)

**核心逻辑：** 首先对体重数组进行排序。为了用最少的船，我们要尽可能让每条船都坐满 2 个人，且让“最重的”和“最轻的”尝试配对。

 **指针移动策略：**
   * 如果 people\[left] + people\[right] <= limit：说明这一重一轻可以同船，left++, right--。
   * 如果 people\[left] + people\[right] > limit：说明最重的那个人太沉了，任何人都没法和他拼船，他必须单独坐，right--。
    ==这种“一头一尾”的撮合逻辑正是典型的对撞指针应用。==

```cpp
```cpp
class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) {
        sort(people.begin(), people.end());
        int ans = 0;
        for (int l = 0, r = people.size() - 1; l <= r;) {
            int sum = l == r ? people[r] : people[l] + people[r];
            if (sum <= limit)l++;
            r--;
            ans++;
        }
        return ans;
    }
};
```

#### 2.多数之和

##### [ 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/submissions/686012962/?envType=problem-list-v2&envId=two-pointers)
====

> 核心算法流程：分而治之

**第一步：数组排序**：排序是所有后续优化的基石
	1. 是==单调性==生效，从而可以使用双指针剪枝。
	2. 使重复元素相邻，简化去重逻辑。

**第二步：固定左端点：** 通过一个外层循环固定第一个数A\[i]。此时，问题转化为：在$A[i+1...N-1]$范围内寻找两个数，使其和等于-A\[i]。
	==优化：== 如果$A[i]>0$，由于数组升序，三数之和大于0，对于i~N-1也一定不满足条件，直接终止外层循环。


**第三步：双指针扫面：** 使用对撞双指针$L=i+1$和$R=N-1$
- 若$sum<0$:L++;
- 若$sum>0$:R--;
- 若$sum==0$:找到一组解，记录并同时移动L，R，继续寻找。

> 难点攻克：如何完美去重？

题目要求解集不能包含重复的三元组。利用排序后的特性，我们在三个位置进行去重：
1. **外层去重：** `if(i>0&&A[i]==A[i-1])continue;`跳过相同的第一个数
2. **内层去重（L）：** 找到解后，若`A[L]==A[L+1]`，则`L++;`继续跳过
3. **内层去重（R）：** 找到解后，若`A[R]==A[R-1]`，则`R--;`继续跳过

**关键逻辑：** 去重应当在==找到第一个解之后==进行，或者在==移动指针之前==检查前一个元素，以确保不会漏掉合法的组合（如{0,0,0}）。

```cpp
class Solution {

public:

    vector<vector<int>> threeSum(vector<int>& nums) {

        int n = nums.size();

        sort(nums.begin(), nums.end());

        vector<vector<int>> res; for (int i = 0; i < n - 2; ++i) {

            if (nums[i] > 0) break;

            // 优化：最小数大于0则无解

            if (i > 0 && nums[i] == nums[i - 1]) continue;

            // 外层去重

            int L = i + 1, R = n - 1;

            while (L < R) {

                int sum = nums[i] + nums[L] + nums[R];

                if (sum == 0) {

                    res.push_back({nums[i], nums[L], nums[R]});

                    // 找到解后，在移动前进行内层去重

                    while (L < R && nums[L] == nums[L + 1]) L++;

                    while (L < R && nums[R] == nums[R - 1]) R--; L++; R--;

                }

                else if (sum < 0) L++;

                else R--;

            }

        }

        return res;

    }

};
```

##### [最接近的三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum-closest/submissions/686034563/?envType=problem-list-v2&envId=two-pointers)

>[!ABSTRACT]
>这道题是三数之和的核心变体。与寻找==等于零==的精确解不同，它要求寻找与target距离（绝对差值）最小的组合。算法结构保持$O(N^2)$，但更新逻辑从==相等判断==转向了==动态维护最小差值==。

>算法三部曲：排序、扫描与维护

**核心基石：** 预排序
=========================
### 2.字符串反转/字符交换

> 对数组或字符串进行原地反转，如反转字符串中的元首字母。

#### [按奇偶排序数组||](https://leetcode.cn/problems/sort-array-by-parity-ii/)

**核心逻辑：**  题目要求 A\[i] 的奇偶性与索引 i 一致。我们可以用两个指针：i 处理偶数下标，j 处理奇数下标。
  
**指针移动策略：**
   * i 指针不断跳过已经在偶数位上的偶数（i += 2）。
   * j 指针不断跳过已经在奇数位上的奇数（j += 2）。
   * 当 i 发现了一个奇数，且 j 发现了一个偶数时，交换这两个元素。
     ==这虽然不是标准的从两端向中间“撞”，但它利用了两个指针在同一区间内根据条件“错位寻找”并“交换”的逻辑。==

### 3.回文串检测

> 验证字符串是否为回文字符串，可以处理空格、特殊字符或大小不敏感的情况。

#### [ 最长回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-substring/submissions/685864282/?envType=problem-list-v2&envId=two-pointers)



**核心逻辑：** 中心扩展法
- 回文串的特性是中心对称的。我们可以遍历字符串的每一个位置，将其作为“中心”，向两边尝试扩展，直到不再满足回文条件为止。
- 由于回文串的长度可能是奇数或者偶数，我们需要考虑两种中心：
	- ==奇数长度：==中心是一个字符（aba，中心是b）
	- ==偶数长度：==中心是两个字符之间的间隙(abba,中心是bb)。

**指针移动策略：** 
1. ==指针移动与长度计算：==在expandArouondCenter函数中，当循环停止时，left和right已经指向了==不满足==回文条件的第一个字符。
	- ==左边界：==left+1
	- ==右边界：==right+1
	- ==长度公式：==$(right-1)-(left-1)+1=right=left-1$
2. ==起始位置start的推导：== 这是一个通用的数学小技巧，无论maxLen是奇数还是偶数都适用：
	- 假设中心索引为<font color=greeen>i</font>：
		- 奇数（长度3）：i=1,maxLen=3->start=1-(3-1)/2=0
		- 偶数（长度4）：i=1,maxLen=4->start=1-(4-1)/2=0
	- ==公式：== $start=i-(maxLen-1)/2$

```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {
        if (s.length() < 2) return s;

        int start = 0, maxLen = 0;

        for (int i = 0; i < s.length(); i++) {
            // 1. 奇数长度扩展 (如 "aba")
            int len1 = expandAroundCenter(s, i, i);
            // 2. 偶数长度扩展 (如 "abba")
            int len2 = expandAroundCenter(s, i, i + 1);

            int curMax = max(len1, len2);

            // 如果找到更长的回文，更新起始位置和最大长度
            if (curMax > maxLen) {
                maxLen = curMax;
                // 注意这里的起始点计算：
                // 如果长度为 3, 中心 i, start = i - (3-1)/2 = i - 1
                // 如果长度为 4, 中心 i 和 i+1, start = i - (4-1)/2 = i - 1
                start = i - (curMax - 1) / 2;
            }
        }

        return s.substr(start, maxLen);
    }

private:
    // 返回以 left, right 为中心向外扩展能达到的最长回文长度
    int expandAroundCenter(const string& s, int left, int right) {
        while (left >= 0 && right < s.length() && s[left] == s[right]) {
            left--;
            right++;
        }
        // 跳出循环时，s[left] != s[right]，所以有效长度是 (right - 1) - (left + 1) + 1
        return right - left - 1;
    }
};
```

### 4.定义区间边界

> 在有序数组或列表中，找到满足条件的最大/最小区间。

#### [接雨水](https://leetcode.cn/problems/trapping-rain-water/)
**核心逻辑：** 这是“盛最多水容器”的进阶版。每个位置能接多少水，取决于它左边最高的柱子和右边最高的柱子中的较小值。
   
**指针移动策略：** 维护两个变量 leftMax 和 rightMax。
   * 如果 leftMax < rightMax，说明左侧的瓶颈更低，当前左指针位置的蓄水量由 leftMax 决定，计算后 left++。
   * 反之，右侧瓶颈更低，由 rightMax 决定，计算后 right--。
     这本质上是利用对撞指针不断缩窄“确定区域”的边界。
```
```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size(), l = 0, r = 0, ans = 0;
        vector<int>lmax(n), rmax(n);
        for (int i = 0; i < n; i++) {
            lmax[i] = l > height[i] ? l : height[i];
            l = max(l, height[i]);
            rmax[n - 1 - i] = r > height[n - 1 - i] ? r : height[n - 1 - i];
            r = max(r, height[n-1-i]);
        }
        for (int i = 0; i < n; i++) {
            ans += max(0, min(lmax[i], rmax[i]) - height[i]);
        }
        return ans;
    }
};
```
#### 

#### [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

**核心逻辑：** 指针 left 指向开头，right 指向结尾。容器的容量由 min(height\[left], height\[right]) \times (right - left) 决定。

**指针移动策略：** 指针 left 指向开头，right 指向结尾。容器的容量由 min(height\[left], height\[right]) \times (right - left) 决定。

- 如果 height\[left] < height\[right]，则 left++。
- 反之，则 right--。

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int ans = 0;
        for (int l = 0, r = height.size() - 1; l <= r;) {
            ans = max(ans, min(height[l], height[r]) * (r - l));
            if (height[l] <= height[r])l++;
            else r--;
        }
        return ans;
    }
};
```

#### [供暖器](https://leetcode.cn/problems/heaters/)

**核心逻辑：** 为了让每个房屋都能被覆盖，我们需要找到每个房屋距离最近的供暖器的距离。总的最小半径就是所有这些“最近距离”中的最大值。
  
**指针移动策略：** 对房屋和供暖器都进行排序。遍历房屋，利用双指针寻找当前房屋左右两侧最近的供暖器。
   * 当下一个供暖器距离当前房屋更近时，移动供暖器指针 right++。
   * 不需要回溯，因为房屋也是有序的，之前的供暖器不会比当前的更近。
```cpp
class Solution {
public:
    int findRadius(vector<int>& houses, vector<int>& heaters) {
        int ans = 0;
        sort(houses.begin(), houses.end());
        sort(heaters.begin(), heaters.end());
        for (int l = 0, r = 0; l < houses.size(); l++) {
            while (r + 1 < heaters.size()&&!best(houses, heaters, l, r)) {
                r++;
            }
            ans = max(ans, (int)fabs(houses[l] - heaters[r]));
        }
        return ans;
    }

    int best(vector<int>& houses, vector<int>& heaters, int l, int r) {
        return fabs(houses[l] - heaters[r]) < fabs(houses[l] - heaters[r + 1]);
    }
};
```

[寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/description/)

---

# 2.快慢双指针


**核心原理：** 两个指针从同一位置（通常是链表头）出发，以不同的速度（快指针N步，慢指针一步）向前推进

**驱动力：** 该方法的核心优势在于==固定 步长差==，这使得他们在有环结构中必然相遇，或在无环结构中精确地测量出相互距离。


## 常见应用场景（以链表为主）

### 1.链表换检测

> 利用快慢指针的相对速度证明，在有环链表中它们必然相遇。

### 2.寻找环的入口/长度

> 在确定有环后，通过二次相遇定位环的起始节点。

### 3.寻找链表的中点

> 快指针走完时，慢指针恰好停留在中点。

### 4.寻找倒数第K个节点

> 先让快指针先行K步，再与慢指针同步移动，保持固定间隔。

---

# 3.同向双指针


**核心原理：** 两个指针<font color=greeen>i</font>和<font color=greeen>j</font>同向移动，但不用于定义一个动态区间（如滑动窗口）。它们常用于对数组进行原地修改、去重或在不同序列中进行同步比较。

**驱动力：** 通过一个指针负责==读==，另一个指针负责==写==或==标记==，实现单词遍历完成复杂操作。

#### [加油站](https://leetcode.cn/problems/gas-station/)

## 常见应用场景

### 1.单序列异速处理

> 使用快慢指针，快指针遍历所有元素，慢指针记录有效元素的位置，实现原地去重。

### 2.多序列并行处理

> 在两个独立的字符串/序列中移动指针，寻找一种映射关系

##### 1.同步模式
**特征：** 指针i和j的移动是==强关联==的，不管谁的大，为了完成任务，通常都要一起推进。。
**典型场景：** 向量点积、字符串相加、求交集

[两数相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-two-numbers/description/?envType=problem-list-v2&envId=linked-list)

**核心逻辑：** 模拟算术加法，每一位都要同时考虑两个加数和进位。

**指针移动逻辑：** 同步移动，l1和l2在每轮循环通常都后移。

**驱动逻辑：** 算术加法和进位机制。

**边界处理：** 处理l1或l2先到达末尾的情况（补0）。

**结果生成：** 每次循环创建一个新节点存和的个位。

```cpp
class Solution {

public:

    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        ListNode dummy;

        ListNode* cur = &dummy;

        int carry = 0;

        for (int val = 0,sum=0;

            l1 || l2;

            l1 = l1 == nullptr ? nullptr : l1->next,

            l2 = l2 == nullptr ? nullptr : l2->next) {

            sum = (l1 == nullptr ? 0 : l1->val) + (l2 == nullptr ? 0 : l2->val) + carry;

            val = sum % 10;

            carry = sum / 10;

            ListNode* node = new ListNode(val);

            cur->next = node;

            cur = cur->next;

        }

        if (carry > 0) {

            ListNode* node = new ListNode(carry);

            cur->next = node;

        }

        return dummy.next;

    }

};
```

##### 2.选择模式

**特征：** 指针i和j的移动是==竞争==关系。只有胜出（满足较小或较大条件）的指针才会前进。
**典型场景：** 合并排序、归并排序、判断子序列（其中一个指针仅在匹配时移动）

[ 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/?envType=problem-list-v2&envId=linked-list)

**核心逻辑：** 排序，即在两个当前的候选节点中做出==二选一==的决定。

**指针移动策略：** 非同步移动，仅移动值较小的那个指针。

**驱动逻辑：** 大小比较。

**边界处理：** 当一个链表耗尽，直接连接另一个链表的剩余部分。

**结果生成：** 通常复用原链表节点进行拼接。

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode dummy;
    dummy.next=NULL;
    struct ListNode* res;
    res=&dummy;
    while(list1&&list2){
        if(list1->val<list2->val){
            res->next=list1;
            list1=list1->next;
        }
        else{
            res->next=list2;
            list2=list2->next;
        }
        res=res->next;
    }
    if(list1){
        res->next=list1;
    }
    else{
        res->next=list2;
    }
    return dummy.next;
}
```
### 3.双指针从后向前遍历

> 从字符串或数组的末尾开始向前扫描，常用于处理退格符或寻找末尾单词

---

# 4.滑动窗口

**核心原理：** 这是同向双指针的最高级应用，使用两个指针<font color=greeen>L</font>（左边界）和<font color=greeen>R</font>（右边界）维护一个==动态变化的连续区间==（即“窗口”）。

**驱动力：** ==单调性==和==哈希表/字典==是其关键辅助工具。

- 当R扩张窗口时，窗口内状态被更新。
- 当窗口不满足条件时，单调性地收缩L，直到条件重新满足。L和R的移动永不后退，保证$O(N)$复杂度。

## 常见应用场景

### 1.最长/最短子数组/子串

> 寻找满足特定条件的、最长或最短的连续子数组或子串

### 2.子串覆盖问题

> 寻找包含目标字符串所有字符的最短子串（例如：最小覆盖子串）。

#### [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

### 3.定长窗口最值

> 在固定大小的窗口中，求窗口的最大值或最小值（常结合单调队列）。

### 4.字符频率/种类限制

> 寻找最多包含K个不同字符的最长子串等限制性问题。

#### [最小子数组](https://leetcode.cn/problems/2VG8Kg/)



#### [乘积小于K的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/description/)

#### [得到K个黑块的最少涂色次数](https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/)

#### [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)



#### [替换子串得到平衡字符串](https://leetcode.cn/problems/replace-the-substring-for-balanced-string/)

#### [K个不同整数的子数组](https://leetcode.cn/problems/subarrays-with-k-different-integers/)

#### [至少有k个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)

