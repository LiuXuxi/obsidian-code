> [!ABSTRACT]
> **双指针是一种核心的优化思路，用于将O(n^2)的暴力遍历优化为O(n)的线性时间复杂度。其题型可根据指针的==移动方向、步长和作用目标==划分为四个主要类别，覆盖了数组、字符串和链表三大核心数据结构**  

---
# 1.对撞双指针

**核心原理：** 两个指针分别从数组或字符串的两端（头和尾）开始，相向移动，知道相遇或交叉。

**驱动力：** 该方法几乎总是依赖于数据结构（尤其是数组）的==有序性==或问题的==对称性==（如回文串），并利用[[7.单调性]]进行高效剪枝。
## 常见应用场景

### 1.两数之和/多数之和

> 在有序数组中快速查找和为目标值的元素对（或多对）。

#### 1.两数之和
##### [两数之和||-输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

**核心问题：** 在一个==有序数组==中，找到相加之和等于目标值T的两个数。

**指针策略：** 设置左指针L\[0]和右指针R\[N-1]。

**单调性：** 利用A\[L]+A\[R]的和的单调性来指导移动：
- 若和>T，则==必须==R--（减小和）。
- 若和<T，则==必须==L++（增大和）。

```cpp
class Solution {
public:
    std::vector<int> twoSum(std::vector<int>& numbers, int target) {
        int L = 0; // 左指针
        int R = numbers.size() - 1; // 右指针
        while (L < R) { 
	        int currentSum = numbers[L] + numbers[R];
	        if (currentSum == target) { 
		        // 找到解。题目要求返回 1-based 索引 
		        return {L + 1, R + 1};
	        } else if (currentSum < target) { 
		        // 和太小，L 必须右移增大和 
		        L++;
	        } else { 
		        // currentSum > target // 和太大，R 必须左移减小和 
		        R--; 
	        } 
	    } // 题目保证有唯一解，实际不会到达这里 
	    return {}; 
	} 
};
```

##### [救生 艇](https://leetcode.cn/problems/boats-to-save-people/)

**核心逻辑：** 首先对体重数组进行排序。为了用最少的船，我们要尽可能让每条船都坐满 2 个人，且让“最重的”和“最轻的”尝试配对。

 **指针移动策略：**
   * 如果 people\[left] + people\[right] <= limit：说明这一重一轻可以同船，left++, right--。
   * 如果 people\[left] + people\[right] > limit：说明最重的那个人太沉了，任何人都没法和他拼船，他必须单独坐，right--。
    ==这种“一头一尾”的撮合逻辑正是典型的对撞指针应用。==

```cpp
```cpp
class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) {
        sort(people.begin(), people.end());
        int ans = 0;
        for (int l = 0, r = people.size() - 1; l <= r;) {
            int sum = l == r ? people[r] : people[l] + people[r];
            if (sum <= limit)l++;
            r--;
            ans++;
        }
        return ans;
    }
};
```

#### 2.多数之和

##### [ 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/submissions/686012962/?envType=problem-list-v2&envId=two-pointers)


> 核心算法流程：分而治之

**第一步：数组排序**：排序是所有后续优化的基石
	1. 是==单调性==生效，从而可以使用双指针剪枝。
	2. 使重复元素相邻，简化去重逻辑。

**第二步：固定左端点：** 通过一个外层循环固定第一个数A\[i]。此时，问题转化为：在$A[i+1...N-1]$范围内寻找两个数，使其和等于-A\[i]。
	==优化：== 如果$A[i]>0$，由于数组升序，三数之和大于0，对于i~N-1也一定不满足条件，直接终止外层循环。


**第三步：双指针扫描：** 使用对撞双指针$L=i+1$和$R=N-1$
- 若$sum<0$:L++;
- 若$sum>0$:R--;
- 若$sum==0$:找到一组解，记录并同时移动L，R，继续寻找。

> 难点攻克：如何完美去重？

题目要求解集不能包含重复的三元组。利用排序后的特性，我们在三个位置进行去重：
1. **外层去重：** `if(i>0&&A[i]==A[i-1])continue;`跳过相同的第一个数
2. **内层去重（L）：** 找到解后，若`A[L]==A[L+1]`，则`L++;`继续跳过
3. **内层去重（R）：** 找到解后，若`A[R]==A[R-1]`，则`R--;`继续跳过

**关键逻辑：** 去重应当在==找到第一个解之后==进行，或者在==移动指针之前==检查前一个元素，以确保不会漏掉合法的组合（如{0,0,0}）。

```cpp
class Solution {

public:

    vector<vector<int>> threeSum(vector<int>& nums) {

        int n = nums.size();

        sort(nums.begin(), nums.end());

        vector<vector<int>> res; for (int i = 0; i < n - 2; ++i) {

            if (nums[i] > 0) break;

            // 优化：最小数大于0则无解

            if (i > 0 && nums[i] == nums[i - 1]) continue;

            // 外层去重

            int L = i + 1, R = n - 1;

            while (L < R) {

                int sum = nums[i] + nums[L] + nums[R];

                if (sum == 0) {

                    res.push_back({nums[i], nums[L], nums[R]});

                    // 找到解后，在移动前进行内层去重

                    while (L < R && nums[L] == nums[L + 1]) L++;

                    while (L < R && nums[R] == nums[R - 1]) R--; L++; R--;

                }

                else if (sum < 0) L++;

                else R--;

            }

        }

        return res;

    }

};
```

##### [最接近的三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum-closest/submissions/686034563/?envType=problem-list-v2&envId=two-pointers)

>[!ABSTRACT]
>这道题是三数之和的核心变体。与寻找==等于零==的精确解不同，它要求寻找与target距离（绝对差值）最小的组合。算法结构保持$O(N^2)$，但更新逻辑从==相等判断==转向了==动态维护最小差值==。

>算法三部曲：排序、扫描与维护


**核心基石：** 预排序

==排序$(O(NlogN))$是应用双指针的前提：==
- 单调性引导：只有数组有序，我们才能通过sum与target的大小关系，确定是移动L++还是R--。
- 避免无效搜索：有序性让我们能够系统地排除掉那些只会让和变得更大（或更小）的无效组合。
**关键步骤：** 动态更新Closest
==在双指针移动的每一步，都要执行：==
1. 计算当前和：$currSum=A[i]+A[L]+A[R]$。
2. 比较差值：若$abs(currSum-target)<abs(ans-target)，则更新ans=curr$。
3. 确定方向：利用单调性，判断$currSum<target$并相应移动指针。
**高级优化：** 剪枝与提前返回
*虽然本题不要求去重，但以下优化能显著提升性能：*
- 提前退出：若$currSum==target$，差值为0，可立即返回结果。
- 跳过重复i：虽然结果不要求唯一，但跳过相同的$A[i]$能减少重复计算。

> 深度思考：为什么移动方向不变？

在本题中，移动指针的依据仍然是==单调性==，但目标是==逼近==而非==锁定==：
1. 若==Sum<target:== 
	- 当前的和比目标要小。为了减小差距，我们需要一个==更大==的数。
	- 由于数组已排序，向右移动左指针(L++)是唯一的增加和的方式。
2. 若==Sum>target:== 
	- 当前的和比目标要大。为了减小差距，我们需要一个==更小==的数。
	- 由于数组已排序，向左移动右指针(R--)是唯一的减小和的方式。
**证明：** 这种策略保证了我们不会错过任何可能更接近target的组合。如果在某一步$Sum<target$时我们选择移动R--，和只会更小，差距只会更大。

```cpp
class Solution {

public:

    int threeSumClosest(vector<int>& nums, int target) {

        int n = nums.size();

        sort(nums.begin(), nums.end());

        // 初始化为一个合理的三数之和

        int ans = nums[0] + nums[1] + nums[2];

        for (int i = 0; i < n - 2; ++i) {

            // 可选：跳过重复的 i 以优化性能

            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int L = i + 1, R = n - 1;

            while (L < R) {

                int currSum = nums[i] + nums[L] + nums[R];

                // 如果找到精确值，直接返回，这是最强的剪枝

                if (currSum == target) return target;

                // 更新当前最接近的和

                if (abs(currSum - target) < abs(ans - target))  ans = currSum;

                // 利用单调性确定移动方向

                if (currSum < target)  L++;  

                else  R--;

            }

        }

        return ans;  

    }

};
```

##### [ 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/?envType=problem-list-v2&envId=two-pointers)

> [!ABSTRACT]
> 四数之和是双指针算法的进一步延伸。其核心思想是==降维打击：== 通过两层嵌套循环固定前两个数，将4Sum转换为3Sum，再进一步转换为经典的2Sum（双指针）问题。将时间复杂度从暴力枚举的$O(N^4)$优化至==$O(N^3)$==。

> 降维策略：从4到2

**第一步：** 排序与双重固定

1. ==排序：== 同3Sum，排序是去重和单调性剪枝的前提。
2. ==固定i：== 外层循环遍历第一个数。
3. ==固定j：== 第二层循环从<font color=red>i+1</font>开始遍历第二个数。此时，目标值变为$target-nums[i]-nums[j]$。

**第二步：** 三数之和逻辑

在固定的i和j之后，剩余的区间\[j+1,n-1]实际上就是一个标准的3Sum后半部分。我们在这个区间内寻找两个数L和R，使得四数总和等于target。

**第三步：双指针扫描：** 使用对撞双指针$L=i+1$和$R=n-1$
- 若$sum<target$:L++;
- 若$sum>target$:R--;
- 若$sum==target$:找到一组解，记录并同时移动L，R，继续寻找。

> 高级剪枝优化

在$O(N^3)$的基础上，，我们可以利用排序特性进行进一步优化，显著提升实际运行速度：
1. **最小和判定：** 如果当前固定的数加上该区间后面最小的几个数仍==大于== target，则后续循环必无解，直接break;
	- 例：`nums[i]+nums[i+3]+nums[i+2]+nums[i+1]>target`。
2. **最大和判定：** 如果当前固定的数加上数组末尾最大的几个数仍然==小于== target，则当前索引i无解，直接continue进入下一个索引。
	- 例：`nums[i]+nums[n-3]+nums[n-2]+nums[n-1]>target`。
3. **溢出保护：** 此题的target范围较大，计数四数之和时务必用long long以防溢出。

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;               // 存储所有满足条件的四元组
        int n = nums.size();                   // 数组长度
        if (n < 4) return res;                 // 如果元素少于4个，直接返回空结果（不可能组成四元组）
        
        sort(nums.begin(), nums.end());        // 先排序，这是整个算法的基础
                                               // 排序后才能方便地使用双指针、去重和剪枝
        
        // 第一层循环：固定第一个数 nums[i]
        for (int i = 0; i < n - 3; ++i) {
            // 第一层去重：如果当前数和前一个数相同，跳过，避免重复四元组
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            
            // 剪枝优化1：当前 i 以及后面三个最小元素之和已经大于 target
            // 由于数组已排序，后面的元素只会更大，后续不可能找到更小的和，直接 break
            if ((long long)nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) break;
            
            // 剪枝优化2：当前 i 以及后面三个最大元素之和还小于 target
            // 说明以 nums[i] 开头的四元组最大都达不到 target，直接跳到下一个 i
            if ((long long)nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target) continue;
            
            // 第二层循环：固定第二个数 nums[j]
            for (int j = i + 1; j < n - 2; ++j) {
                // 第二层去重：如果当前 j 和前一个 j（同一个 i 下）相同，跳过
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;
                
                // 剪枝优化3：当前 i、j 以及后面两个最小元素之和已经大于 target
                // 后续双指针只会使和更大，直接 break 当前 j 循环
                if ((long long)nums[i] + nums[j] + nums[j+1] + nums[j+2] > target) break;
                
                // 剪枝优化4：当前 i、j 以及后面两个最大元素之和还小于 target
                // 说明以 nums[i], nums[j] 开头的四元组最大都达不到 target，直接跳到下一个 j
                if ((long long)nums[i] + nums[j] + nums[n-2] + nums[n-1] < target) continue;
                
                // 双指针寻找剩余的两个数
                int L = j + 1;      // 左指针，从 j 的右边开始
                int R = n - 1;      // 右指针，从数组末尾开始
                
                while (L < R) {
                    // 使用 long long 防止整数溢出（尤其是 target 为 INT_MIN 或 nums 中有大数时）
                    long long sum = (long long)nums[i] + nums[j] + nums[L] + nums[R];
                    
                    if (sum == target) {
                        // 找到一组合法四元组，加入结果
                        res.push_back({nums[i], nums[j], nums[L], nums[R]});
                        
                        // 第三层去重：跳过所有与当前 nums[L] 相同的元素
                        while (L < R && nums[L] == nums[L + 1]) L++;
                        // 第四层去重：跳过所有与当前 nums[R] 相同的元素
                        while (L < R && nums[R] == nums[R - 1]) R--;
                        
                        // 移动指针，继续寻找下一个可能的组合
                        L++;
                        R--;
                    }
                    else if (sum < target) {
                        // 和太小，需要增大，左指针右移
                        L++;
                    }
                    else {
                        // 和太大，需要减小，右指针左移
                        R--;
                    }
                }
            }
        }
        return res;
    }
};
```
### 2.字符串反转/字符交换

> 对数组或字符串进行原地反转，如反转字符串中的元首字母。

#### [按奇偶排序数组||](https://leetcode.cn/problems/sort-array-by-parity-ii/)

**核心逻辑：**  题目要求 A\[i] 的奇偶性与索引 i 一致。我们可以用两个指针：i 处理偶数下标，j 处理奇数下标。
  
**指针移动策略：**
   * i 指针不断跳过已经在偶数位上的偶数（i += 2）。
   * j 指针不断跳过已经在奇数位上的奇数（j += 2）。
   * 当 i 发现了一个奇数，且 j 发现了一个偶数时，交换这两个元素。
     ==这虽然不是标准的从两端向中间“撞”，但它利用了两个指针在同一区间内根据条件“错位寻找”并“交换”的逻辑。==

### 3.回文串检测

> 验证字符串是否为回文字符串，可以处理空格、特殊字符或大小不敏感的情况。

#### [ 最长回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-substring/submissions/685864282/?envType=problem-list-v2&envId=two-pointers)


**核心逻辑：** 中心扩展法
- 回文串的特性是中心对称的。我们可以遍历字符串的每一个位置，将其作为“中心”，向两边尝试扩展，直到不再满足回文条件为止。
- 由于回文串的长度可能是奇数或者偶数，我们需要考虑两种中心：
	- ==奇数长度：==中心是一个字符（aba，中心是b）
	- ==偶数长度：==中心是两个字符之间的间隙(abba,中心是bb)。

**指针移动策略：** 
1. ==指针移动与长度计算：==在expandArouondCenter函数中，当循环停止时，left和right已经指向了==不满足==回文条件的第一个字符。
	- ==左边界：==left+1
	- ==右边界：==right+1
	- ==长度公式：==$(right-1)-(left-1)+1=right=left-1$
2. ==起始位置start的推导：== 这是一个通用的数学小技巧，无论maxLen是奇数还是偶数都适用：
	- 假设中心索引为<font color=greeen>i</font>：
		- 奇数（长度3）：i=1,maxLen=3->start=1-(3-1)/2=0
		- 偶数（长度4）：i=1,maxLen=4->start=1-(4-1)/2=0
	- ==公式：== $start=i-(maxLen-1)/2$

```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {
        if (s.length() < 2) return s;

        int start = 0, maxLen = 0;

        for (int i = 0; i < s.length(); i++) {
            // 1. 奇数长度扩展 (如 "aba")
            int len1 = expandAroundCenter(s, i, i);
            // 2. 偶数长度扩展 (如 "abba")
            int len2 = expandAroundCenter(s, i, i + 1);

            int curMax = max(len1, len2);

            // 如果找到更长的回文，更新起始位置和最大长度
            if (curMax > maxLen) {
                maxLen = curMax;
                // 注意这里的起始点计算：
                // 如果长度为 3, 中心 i, start = i - (3-1)/2 = i - 1
                // 如果长度为 4, 中心 i 和 i+1, start = i - (4-1)/2 = i - 1
                start = i - (curMax - 1) / 2;
            }
        }

        return s.substr(start, maxLen);
    }

private:
    // 返回以 left, right 为中心向外扩展能达到的最长回文长度
    int expandAroundCenter(const string& s, int left, int right) {
        while (left >= 0 && right < s.length() && s[left] == s[right]) {
            left--;
            right++;
        }
        // 跳出循环时，s[left] != s[right]，所以有效长度是 (right - 1) - (left + 1) + 1
        return right - left - 1;
    }
};
```

### 4.定义区间边界

> 在有序数组或列表中，找到满足条件的最大/最小区间。

#### [接雨水](https://leetcode.cn/problems/trapping-rain-water/)
**核心逻辑：** 这是“盛最多水容器”的进阶版。每个位置能接多少水，取决于它左边最高的柱子和右边最高的柱子中的较小值。
   
**指针移动策略：** 维护两个变量 leftMax 和 rightMax。
   * 如果 leftMax < rightMax，说明左侧的瓶颈更低，当前左指针位置的蓄水量由 leftMax 决定，计算后 left++。
   * 反之，右侧瓶颈更低，由 rightMax 决定，计算后 right--。
     这本质上是利用对撞指针不断缩窄“确定区域”的边界。
```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size(), l = 0, r = 0, ans = 0;
        vector<int>lmax(n), rmax(n);
        for (int i = 0; i < n; i++) {
            lmax[i] = l > height[i] ? l : height[i];
            l = max(l, height[i]);
            rmax[n - 1 - i] = r > height[n - 1 - i] ? r : height[n - 1 - i];
            r = max(r, height[n-1-i]);
        }
        for (int i = 0; i < n; i++) {
            ans += max(0, min(lmax[i], rmax[i]) - height[i]);
        }
        return ans;
    }
};
```

#### [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

**核心逻辑：** 指针 left 指向开头，right 指向结尾。容器的容量由 min(height\[left], height\[right]) \times (right - left) 决定。

**指针移动策略：** 指针 left 指向开头，right 指向结尾。容器的容量由 min(height\[left], height\[right]) \times (right - left) 决定。

- 如果 height\[left] < height\[right]，则 left++。
- 反之，则 right--。

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int ans = 0;
        for (int l = 0, r = height.size() - 1; l <= r;) {
            ans = max(ans, min(height[l], height[r]) * (r - l));
            if (height[l] <= height[r])l++;
            else r--;
        }
        return ans;
    }
};
```

#### [供暖器](https://leetcode.cn/problems/heaters/)

**核心逻辑：** 为了让每个房屋都能被覆盖，我们需要找到每个房屋距离最近的供暖器的距离。总的最小半径就是所有这些“最近距离”中的最大值。
  
**指针移动策略：** 对房屋和供暖器都进行排序。遍历房屋，利用双指针寻找当前房屋左右两侧最近的供暖器。
   * 当下一个供暖器距离当前房屋更近时，移动供暖器指针 right++。
   * 不需要回溯，因为房屋也是有序的，之前的供暖器不会比当前的更近。
```cpp
class Solution {
public:
    int findRadius(vector<int>& houses, vector<int>& heaters) {
        int ans = 0;
        sort(houses.begin(), houses.end());
        sort(heaters.begin(), heaters.end());
        for (int l = 0, r = 0; l < houses.size(); l++) {
            while (r + 1 < heaters.size()&&!best(houses, heaters, l, r)) {
                r++;
            }
            ans = max(ans, (int)fabs(houses[l] - heaters[r]));
        }
        return ans;
    }

    int best(vector<int>& houses, vector<int>& heaters, int l, int r) {
        return fabs(houses[l] - heaters[r]) < fabs(houses[l] - heaters[r + 1]);
    }
};
```

#### [寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/description/)

---

# 2.快慢双指针


**核心原理：** 两个指针从同一位置（通常是链表头）出发，以不同的速度（快指针N步，慢指针一步）向前推进

**驱动力：** 该方法的核心优势在于==固定 步长差==，这使得他们在有环结构中必然相遇，或在无环结构中精确地测量出相互距离。

## 环入口逻辑的数学证明（fast走两步，slow走一步）

很多同学能记住代码，但容易忘记为什么==相遇后再走一遍== 就能找到入口。

**证明如下** ：
1. 假设从链表头到环入口的距离为<font color=greeen>a</font>。
2. 假设从环入口到相遇点的距离为<font color=greeen>b</font>。
3. 假设环的剩余长度为<font color=greeen>c</font>（即==环的总长为b+c==)
4. ==相遇时：==
	- 慢指针走过的距离：$S=a+b$
	- 快指针走过的距离：$F=a+b+n(b+c)$（<font color=greeen>n</font>为快指针绕环的圈数)
5. 因为快指针速度是慢指针的两倍，所以$F=2S$：
	$a+b+n(b+c)=2(a+b)$
	化简得到：
	$a=n(b+c)-b=(n-1)(b+c)+c$
6. ==结论：== $a=(n-1)*环长+c$。这意味着，如果你从链表头走a步，等同于从相遇点出发绕环n-1圈后再走c步。两者最终都会在环入口处重合。
## 常见应用场景（以链表为主）

### 1.链表环检测

> 利用快慢指针的相对速度证明，在有环链表中它们必然相遇。

####[141. 环形链表 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle/description/)



### 2.寻找环的入口/长度

> 在确定有环后，通过二次相遇定位环的起始节点。

### 3.寻找链表的中点

> 快指针走完时，慢指针恰好停留在中点。

### 4.寻找倒数第K个节点

> 先让快指针先行K步，再与慢指针同步移动，保持固定间隔。

---

# 3.同向双指针


**核心原理：** 两个指针<font color=greeen>i</font>和<font color=greeen>j</font>同向移动，但不用于定义一个动态区间（如滑动窗口）。它们常用于对数组进行原地修改、去重或在不同序列中进行同步比较。

**驱动力：** 通过一个指针负责==读==，另一个指针负责==写==或==标记==，实现单词遍历完成复杂操作。

#### [加油站](https://leetcode.cn/problems/gas-station/)

## 常见应用场景

### 1.单序列异速处理

> 使用快慢指针，快指针遍历所有元素，慢指针记录有效元素的位置，实现原地去重。

### 2.多序列并行处理

> 在两个独立的字符串/序列中移动指针，寻找一种映射关系

##### 1.同步模式
**特征：** 指针i和j的移动是==强关联==的，不管谁的大，为了完成任务，通常都要一起推进。。
**典型场景：** 向量点积、字符串相加、求交集

[两数相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-two-numbers/description/?envType=problem-list-v2&envId=linked-list)

**核心逻辑：** 模拟算术加法，每一位都要同时考虑两个加数和进位。

**指针移动逻辑：** 同步移动，l1和l2在每轮循环通常都后移。

**驱动逻辑：** 算术加法和进位机制。

**边界处理：** 处理l1或l2先到达末尾的情况（补0）。

**结果生成：** 每次循环创建一个新节点存和的个位。

```cpp
class Solution {

public:

    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        ListNode dummy;

        ListNode* cur = &dummy;

        int carry = 0;

        for (int val = 0,sum=0;

            l1 || l2;

            l1 = l1 == nullptr ? nullptr : l1->next,

            l2 = l2 == nullptr ? nullptr : l2->next) {

            sum = (l1 == nullptr ? 0 : l1->val) + (l2 == nullptr ? 0 : l2->val) + carry;

            val = sum % 10;

            carry = sum / 10;

            ListNode* node = new ListNode(val);

            cur->next = node;

            cur = cur->next;

        }

        if (carry > 0) {

            ListNode* node = new ListNode(carry);

            cur->next = node;

        }

        return dummy.next;

    }

};
```

##### 2.选择模式

**特征：** 指针i和j的移动是==竞争==关系。只有胜出（满足较小或较大条件）的指针才会前进。
**典型场景：** 合并排序、归并排序、判断子序列（其中一个指针仅在匹配时移动）

[ 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/?envType=problem-list-v2&envId=linked-list)

**核心逻辑：** 排序，即在两个当前的候选节点中做出==二选一==的决定。

**指针移动策略：** 非同步移动，仅移动值较小的那个指针。

**驱动逻辑：** 大小比较。

**边界处理：** 当一个链表耗尽，直接连接另一个链表的剩余部分。

**结果生成：** 通常复用原链表节点进行拼接。

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode dummy;
    dummy.next=NULL;
    struct ListNode* res;
    res=&dummy;
    while(list1&&list2){
        if(list1->val<list2->val){
            res->next=list1;
            list1=list1->next;
        }
        else{
            res->next=list2;
            list2=list2->next;
        }
        res=res->next;
    }
    if(list1){
        res->next=list1;
    }
    else{
        res->next=list2;
    }
    return dummy.next;
}
```
### 3.双指针从后向前遍历

> 从字符串或数组的末尾开始向前扫描，常用于处理退格符或寻找末尾单词

---

# 4.滑动窗口

**核心原理：** 这是同向双指针的最高级应用，使用两个指针<font color=greeen>L</font>（左边界）和<font color=greeen>R</font>（右边界）维护一个==动态变化的连续区间==（即“窗口”）。

**驱动力：** ==单调性==和==哈希表/字典==是其关键辅助工具。

- 当R扩张窗口时，窗口内状态被更新。
- 当窗口不满足条件时，单调性地收缩L，直到条件重新满足。L和R的移动永不后退，保证$O(N)$复杂度。

## 常见应用场景

### 1.最长/最短子数组/子串

> 寻找满足特定条件的、最长或最短的连续子数组或子串

### 2.子串覆盖问题

> 寻找包含目标字符串所有字符的最短子串（例如：最小覆盖子串）。

#### [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

### 3.定长窗口最值

> 在固定大小的窗口中，求窗口的最大值或最小值（常结合单调队列）。

### 4.字符频率/种类限制

> 寻找最多包含K个不同字符的最长子串等限制性问题。

#### [最小子数组](https://leetcode.cn/problems/2VG8Kg/)



#### [乘积小于K的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/description/)

#### [得到K个黑块的最少涂色次数](https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/)

#### [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)



#### [替换子串得到平衡字符串](https://leetcode.cn/problems/replace-the-substring-for-balanced-string/)

#### [K个不同整数的子数组](https://leetcode.cn/problems/subarrays-with-k-different-integers/)

#### [至少有k个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)

