# 原理

- **为什么叫“链式”？** `head[u]` 就像是链表的头指针，而 `next[i]` 就像是 `next` 指针。每次添加新边时，我们都采用**头插法**：新边指向旧的头，然后更新头指向新边。
    
- **空间效率** 这种方式只需要三个基本的数组（如果带权值则多一个 `weight` 数组），内存布局是连续的，对 CPU 缓存非常友好。
    
- **初始化注意**
    
    - `head` 必须初始化为 `-1`（或者任何不会作为数组索引的负数），这代表链表的结尾。
        
    - 如果是**无向图**，记得在构造函数里把 `next` 和 `to` 的大小设为 `2 * m`，并对每条边调用两次 `add_edge(u, v)` 和 `add_edge(v, u)`。

# code

```cpp
#include <vector>
using namespace std;

class graph {
private:
    vector<int> head; // head[u] 存储节点 u 的第一条边的索引
    vector<int> next; // next[i] 存储编号为 i 的边的下一条边的索引
    vector<int> to;   // to[i] 存储编号为 i 的边的终点
    int edge_cnt;     // 记录当前边的编号（计数器）

public:
    // n 为节点数，edges 为输入边集 {u, v}
    graph(int n, vector<vector<int>>& edges) {
        // 初始化：节点编号通常从 1 或 0 开始，这里假设从 1 到 n
        // head 初始化为 -1，表示目前没有任何边
        head.resize(n + 1, -1);
        
        // 预分配空间：如果是无向图，空间需要开 2 * edges.size()
        int m = edges.size();
        next.resize(m); 
        to.resize(m);
        edge_cnt = 0;

        for (auto& edge : edges) {
            int u = edge[0];
            int v = edge[1];
            add_edge(u, v);
        }
    }

    // 核心添加边函数
    void add_edge(int u, int v) {
        to[edge_cnt] = v;          // 记录终点
        next[edge_cnt] = head[u];  // 新边的 next 指向原本 head[u] 存的那条边
        head[u] = edge_cnt;        // 更新 head[u]，让它指向最新的这条边
        edge_cnt++;                // 移动到下一个存储位置
    }

    // 遍历演示：从 u 出发的所有边
    /*
    void traverse(int u) {
        for (int i = head[u]; i != -1; i = next[i]) {
            int v = to[i];
            // 处理边 (u, v)
        }
    }
    */
};
```