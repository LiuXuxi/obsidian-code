 

![[Pasted image 20260222145550.png]]

[179. 最大数 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-number/)

排序传递性：
a+b<=b+a
b+c<=c+b
=>a+c<=c+a
![[Pasted image 20260223200711.png]]
[1029. 两地调度 - 力扣（LeetCode）](https://leetcode.cn/problems/two-city-scheduling/description/)
```cpp
class Solution {

public:

    int twoCitySchedCost(vector<vector<int>>& costs) {

        vector<int>diff;

        int ans=0;

        for(auto&cost:costs){

            diff.push_back(cost[1]-cost[0]);

            ans+=cost[0];

        }

        sort(diff.begin(),diff.end(),[](const int a,const int b){return a<b;});

        for(int i=0;i<costs.size()/2;i++)ans+=diff[i];

        return ans;

    }

};
```
[1553. 吃掉 N 个橘子的最少天数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/submissions/700039195/)
```cpp
class Solution {

public:

    unordered_map<int,int>dp;

  

    int minDays(int n) {

        if(n<=1)return 1;

        auto it=dp.find(n);

        if(it!=dp.end())return dp[n];

        int ans=min(n%2+1+minDays(n/2),n%3+1+minDays(n/3));

        dp.insert({n,ans});

        return ans;

    }

};
```

[线段重合_牛客题霸_牛客网](https://www.nowcoder.com/practice/1ae8d0b6bb4e4bcdbf64ec491f63fc37)
```cpp
#include<iostream>

#include<vector>

#include<queue>

#include<algorithm>

using namespace std;

  

int n,s,e;

vector<vector<int>>lines;

  

int solve(){

    sort(lines.begin(),lines.end(),[](const vector<int>&a,const vector<int>&b){return a[0]<b[0];});

    priority_queue<int,vector<int>,greater<>>heap;

    int ans=0;

    for(int i=0;i<n;i++){

        while(!heap.empty()&&heap.top()<=lines[i][0])heap.pop();

        heap.push(lines[i][1]);

        ans=max(ans,(int)heap.size());

    }

    return ans;

}

  

int main(){

    cin>>n;

    for(int i=0;i<n;i++){

        cin>>s>>e;

        lines.push_back({s,e});

    }

    cout<<solve();

    return 0;

}
```
[630. 课程表 III - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-iii/submissions/700056032/)
```cpp
class Solution {

public:

    int scheduleCourse(vector<vector<int>>& courses) {

        sort(courses.begin(),courses.end(),[](const vector<int>&a,const vector<int>&b){return a[1]<b[1];});

        priority_queue<int>heap;

        int ans=0;

        for(auto&course:courses){

            if(course[0]+ans<=course[1]){

                heap.push(course[0]);

                ans+=course[0];

            }

            else{

                if(!heap.empty()&&heap.top()>course[0]){

                    ans-=heap.top()-course[0];

                    heap.pop();

                    heap.push(course[0]);

                }

            }

        }

        return heap.size();

    }

};
```
[记录详情 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/record/263692179)
```cpp
#include<iostream>

#include<queue>

using namespace std;

  

int n,w,wa,wb;

priority_queue<int,vector<int>,greater<>>heap;

  

int solve(){

    int ans=0;

    while(heap.size()>=2){

        wa=heap.top(),heap.pop();

        wb=heap.top(),heap.pop();

        ans+=wa+wb;

        heap.push(wa+wb);

    }

    return ans;

}

  

int main(){

    cin>>n;

    for(int i=0;i<n;i++){

        cin>>w;

        heap.push(w);

    }

    cout<<solve();

    return 0;

}
```


---

## 乘法快速幂

[LCR 132. 砍竹子 II - 力扣（LeetCode）](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/) 

```cpp
class Solution {

public:

    const int mod=(int)(1e9+7);

    long long power(long long x,int n,int mod){

        long long ans=1;

        while(n){

            if(n&1)ans=(ans*x)%mod;

            x=(x*x)%mod;

            n>>=1;

        }

        return ans;

    }

  

    int cuttingBamboo(int bamboo_len) {

        if(bamboo_len<=3)return bamboo_len-1;

        int tail=bamboo_len%3==0?1:(bamboo_len%3==1?4:2);

        int pow=(tail==1?bamboo_len:(bamboo_len-tail))/3;

        return power(3,pow,mod)*tail%mod;

    }

};
```

![[Pasted image 20260224185924.png]]
```cpp
#include<iostream>

#include<algorithm>

#include<ctime>

#include<random>

using namespace std;

  

int f(vector<vector<int>>&meetings,int i){

    int ans=0;

    if(i==meetings.size()){

        int cur=-1;

        for(auto&meeting:meetings){

            if(cur<=meeting[0]){

                ++ans;

                cur=meeting[1];

            }

        }

    }else{

        for(int j=i;j<meetings.size();j++){

            swap(meetings[i],meetings[j]);

            ans=max(ans,f(meetings,i+1));

            swap(meetings[i],meetings[j]);

        }

    }

    return ans;

}

  

int maxMeetings1(vector<vector<int>>&meetings){

    return f(meetings,0);

}

  

int maxMeetings2(vector<vector<int>>&meetings){

    sort(meetings.begin(),meetings.end(),[](const vector<int>&a,const vector<int>&b){

        return a[1]<b[1];

    });

    int ans=0,cur=-1;

    for(auto&meeting:meetings){

        if(cur<=meeting[0]){

            ++ans;

            cur=meeting[1];

        }

    }

    return ans;

}

  

vector<vector<int>> randomMeetings(int n,int m){

    vector<vector<int>>meetings(n,vector<int>(2,0));

    for(auto&meeting:meetings){

        int a=rand()%(m+2),b=rand()%(m+2);

        if(a==b)b=a+1;

        meeting[0]=min(a,b);

        meeting[1]=max(a,b);

    }

    return meetings;

}

  

void test(int testTimes,int maxN,int maxM){

    srand(time(nullptr));

    for(int i=0;i<testTimes;i++){

        vector<vector<int>>meetings=randomMeetings(maxN,maxM);

        int res1=maxMeetings1(meetings);

        int res2=maxMeetings2(meetings);

        if(res1!=res2){

            cout<<"测试失败，测试样例为："<<endl;

            for(auto&meeting:meetings){

                cout<<meeting[0]<<" "<<meeting[1]<<endl;

            }

            return;

        }

    }

    cout<<"测试成功"<<endl;

}

  

int main(){

    test(100,5,40);

    return 0;

}
```

[1353. 最多可以参加的会议数目 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/submissions/700245557/)
```cpp
class Solution {

public:

    int maxEvents(vector<vector<int>>& events) {

        sort(events.begin(),events.end(),[](const vector<int>&a,const vector<int>&b){

            return a[0]==b[0]?a[1]<b[1]:a[0]<b[0];

        });

        int n=events.size(),ans=0,ddl=0;

        for(auto&event:events)ddl=max(ddl,event[1]);

        priority_queue<int,vector<int>,greater<>>heap;

        for(int day=events[0][0],i=0;day<=ddl;day++){

            while(i<n&&day==events[i][0])heap.push(events[i++][1]);

            while(!heap.empty()&&day>heap.top())heap.pop();

            if(!heap.empty()){

                ++ans;

                heap.pop();

            }

        }

        return ans;

    }

};
```

[502. IPO - 力扣（LeetCode）](https://leetcode.cn/problems/ipo/)
```cpp
class Solution {

public:

    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {

        auto cmp1=[](const pair<int,int>&a,const pair<int,int>&b){return a.second>b.second;};

        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(cmp1)>lock(cmp1);

        priority_queue<pair<int,int>>unlock;

        int n=profits.size();

        for(int i=0;i<n;i++)lock.push({profits[i],capital[i]});

        while(k){

            while(!lock.empty()&&w>=lock.top().second){

                unlock.push(lock.top());

                lock.pop();

            }

            if(unlock.empty())break;

            --k;

            w+=unlock.top().first;

            unlock.pop();

        }

        return w;

    }

};
```

---
[581. 最短无序连续子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/submissions/700261891/)
```cpp
class Solution {

public:

    int findUnsortedSubarray(vector<int>& nums) {

        int r=-1,n=nums.size();

        for(int i=0,maxV=INT_MIN;i<n;i++){

            if(maxV>nums[i])r=i;

            maxV=max(maxV,nums[i]);

        }

        int l=n;

        for(int i=n-1,minV=INT_MAX;i>=0;i--){

            if(minV<nums[i])l=i;

            minV=min(minV,nums[i]);

        }

        return max(0,r-l+1);

    }

};
```


[632. 最小区间 - 力扣（LeetCode）](https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/submissions/700272525/)
```cpp
class Solution {

public:

    vector<int> smallestRange(vector<vector<int>>& nums) {

        auto cmp=[](const vector<int>&a,const vector<int>&b){

            return a[0]==b[0]?a[1]<b[1]:a[0]<b[0];

        };

        set<vector<int>,decltype(cmp)>range(cmp);

        int n=nums.size();

        vector<int>ans{INT_MAX,0,0};

        for(int i=0;i<n;i++)range.insert({nums[i][0],i,0});

        while(range.size()==n){

            vector<int>maxV=*range.rbegin(),minV=*range.begin();

            range.erase(minV);

            if(maxV[0]-minV[0]<ans[0]){

                ans[0]=maxV[0]-minV[0];

                ans[1]=minV[0];

                ans[2]=maxV[0];

            }

            if(minV[2]+1<nums[minV[1]].size())range.insert({nums[minV[1]][minV[2]+1],minV[1],minV[2]+1});

        }

        return {ans[1],ans[2]};

    }

};
```

[1665. 完成所有任务的最少初始能量 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/submissions/700283564/)
```cpp
class Solution {

public:

    int minimumEffort(vector<vector<int>>& tasks) {

        sort(tasks.begin(),tasks.end(),[](const vector<int>&a,const vector<int>&b){return a[0]-a[1]>b[0]-b[1];});

        int ans=0,cur=0;

        for(auto&task:tasks)ans=max(ans+task[0],task[1]);

        return ans;

    }

};
```

![[Pasted image 20260224220744.png]][P12331 [蓝桥杯 2023 省 Java B] 最大开支 - 洛谷](https://www.luogu.com.cn/problem/P12331)
![[Pasted image 20260224222119.png]]

---
[1675. 数组的最小偏移量 - 力扣（LeetCode）](https://leetcode.cn/problems/minimize-deviation-in-array/submissions/700436627/)
```cpp
class Solution {

public:

    int minimumDeviation(vector<int>& nums) {

        set<int>wait;

        for(auto&num:nums)wait.insert(num%2==0?num:num*2);

        int ans=*wait.rbegin()-*wait.begin();

        while(ans>0&&*wait.rbegin()%2==0){

            int cur=*wait.rbegin();

            wait.erase(cur);

            wait.insert(cur/2);

            ans=min(ans,*wait.rbegin()-*wait.begin());

        }

        return ans;

    }

};
```

[781. 森林中的兔子 - 力扣（LeetCode）](https://leetcode.cn/problems/rabbits-in-forest/submissions/700448524/)
```cpp
class Solution {

public:

    int numRabbits(vector<int>& answers) {

        unordered_map<int,int>cnt;

        for(auto&answer:answers)cnt[answer]++;

        int ans=0;

        for(auto&[key,val]:cnt){

            ans+=(key+1)*((val+key)/(key+1));

        }

        return ans;

    }

};
```

[2449. 使数组相似的最少操作次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/submissions/700458596/)
```cpp
class Solution {

public:

    long long makeSimilar(vector<int>& nums, vector<int>& target) {

        int oddSize=divide(nums);

        divide(target);

        sort(nums.begin(),nums.begin()+oddSize);

        sort(nums.begin()+oddSize,nums.end());

        sort(target.begin(),target.begin()+oddSize);

        sort(target.begin()+oddSize,target.end());

        long long sum=0;

        for(int i=0;i<nums.size();i++){

            sum+=(int)fabs(nums[i]-target[i]);

        }

        return sum/4;

    }

  

    int divide(vector<int>&nums){

        int oddSize=0;

        for(int i=0;i<nums.size();i++){

            if((nums[i]&1)!=0)swap(nums[i],nums[oddSize++]);

        }

        return oddSize;

    }

};
```

[知识竞赛_牛客题霸_牛客网](https://www.nowcoder.com/practice/2a9089ea7e5b474fa8f688eae76bc050)
```cpp
#include <iostream>

#include <vector>

#include <algorithm>

#include <cmath>

  

using namespace std;

  

const int MAXN = 200001;

vector<vector<int>> nums(MAXN, vector<int>(2));

  

int n;

  

int compute() {

    sort(nums.begin(), nums.begin() + n, [](const vector<int>& a, const vector<int>& b) {

        return abs(a[0] - a[1]) < abs(b[0] - b[1]);

    });

    int maxA = nums[0][0];

    int maxB = nums[0][1];

    int ans = 0;

    for (int i = 1; i < n; i++) {

        if (nums[i][0] <= nums[i][1]) {

            ans = max(ans, maxA + nums[i][0]);

        } else {

            ans = max(ans, maxB + nums[i][1]);

        }

        maxA = max(maxA, nums[i][0]);

        maxB = max(maxB, nums[i][1]);

    }

    return ans;

}

  

int main() {

    while (cin >> n) {

        for (int i = 0; i < n; i++) {

            cin >> nums[i][0] >> nums[i][1];

        }

        cout << (double)compute() / 2 << endl;

    }

    return 0;

}
```


[871. 最低加油次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-refueling-stops/submissions/700477935/)
```cpp
class Solution {

public:

    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {

        if(startFuel>=target)return 0;

        priority_queue<int>fuels;

        int ans=0,to=startFuel;

        for(auto&station:stations){

            int pos=station[0],fuel=station[1];

            while(!fuels.empty()&&to<pos){

                to+=fuels.top();

                fuels.pop();

                ++ans;

                if(to>=target)return ans;

            }

            if(to<pos)return -1;

            fuels.push(fuel);

        }

        while(!fuels.empty()){

            to+=fuels.top();

            fuels.pop();

            ++ans;

            if(to>=target)return ans;

        }

        return -1;

    }

};
```


---
[45. 跳跃游戏 II - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game-ii/submissions/700521142/)
```cpp
class Solution {

public:

    int jump(vector<int>& nums) {

        int ans=0,cur=0,next=0;

        for(int i=0;i<nums.size();i++){

            if(cur<i){

                ++ans;

                cur=next;

            }

            next=max(next,i+nums[i]);

        }

        return ans;

    }

};
```
[1326. 灌溉花园的最少水龙头数目 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/submissions/700531728/)
```cpp
class Solution {

public:

    int minTaps(int n, vector<int>& ranges) {

        vector<int>rights(n+1);

        for(int i=0,start=0;i<=n;i++){

            start=max(0,i-ranges[i]);

            rights[start]=max(rights[start],i+ranges[i]);

        }

        int ans=0,cur=0,next=0;

        for(int i=0;i<n;i++){

            next=max(next,rights[i]);

            if(i==cur){

                if(next>i){

                    ++ans;

                    cur=next;

                }else return -1;

            }

        }

        return ans;

    }

};
```