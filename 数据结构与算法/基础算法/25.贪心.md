 

![[Pasted image 20260222145550.png]]

[179. 最大数 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-number/)

排序传递性：
a+b<=b+a
b+c<=c+b
=>a+c<=c+a
![[Pasted image 20260223200711.png]]
[1029. 两地调度 - 力扣（LeetCode）](https://leetcode.cn/problems/two-city-scheduling/description/)
```cpp
class Solution {

public:

    int twoCitySchedCost(vector<vector<int>>& costs) {

        vector<int>diff;

        int ans=0;

        for(auto&cost:costs){

            diff.push_back(cost[1]-cost[0]);

            ans+=cost[0];

        }

        sort(diff.begin(),diff.end(),[](const int a,const int b){return a<b;});

        for(int i=0;i<costs.size()/2;i++)ans+=diff[i];

        return ans;

    }

};
```
[1553. 吃掉 N 个橘子的最少天数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/submissions/700039195/)
```cpp
class Solution {

public:

    unordered_map<int,int>dp;

  

    int minDays(int n) {

        if(n<=1)return 1;

        auto it=dp.find(n);

        if(it!=dp.end())return dp[n];

        int ans=min(n%2+1+minDays(n/2),n%3+1+minDays(n/3));

        dp.insert({n,ans});

        return ans;

    }

};
```

[线段重合_牛客题霸_牛客网](https://www.nowcoder.com/practice/1ae8d0b6bb4e4bcdbf64ec491f63fc37)
```cpp
#include<iostream>

#include<vector>

#include<queue>

#include<algorithm>

using namespace std;

  

int n,s,e;

vector<vector<int>>lines;

  

int solve(){

    sort(lines.begin(),lines.end(),[](const vector<int>&a,const vector<int>&b){return a[0]<b[0];});

    priority_queue<int,vector<int>,greater<>>heap;

    int ans=0;

    for(int i=0;i<n;i++){

        while(!heap.empty()&&heap.top()<=lines[i][0])heap.pop();

        heap.push(lines[i][1]);

        ans=max(ans,(int)heap.size());

    }

    return ans;

}

  

int main(){

    cin>>n;

    for(int i=0;i<n;i++){

        cin>>s>>e;

        lines.push_back({s,e});

    }

    cout<<solve();

    return 0;

}
```
[630. 课程表 III - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-iii/submissions/700056032/)
```cpp
class Solution {

public:

    int scheduleCourse(vector<vector<int>>& courses) {

        sort(courses.begin(),courses.end(),[](const vector<int>&a,const vector<int>&b){return a[1]<b[1];});

        priority_queue<int>heap;

        int ans=0;

        for(auto&course:courses){

            if(course[0]+ans<=course[1]){

                heap.push(course[0]);

                ans+=course[0];

            }

            else{

                if(!heap.empty()&&heap.top()>course[0]){

                    ans-=heap.top()-course[0];

                    heap.pop();

                    heap.push(course[0]);

                }

            }

        }

        return heap.size();

    }

};
```