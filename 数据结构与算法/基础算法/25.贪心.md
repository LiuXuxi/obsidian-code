 

![[Pasted image 20260222145550.png]]

[179. 最大数 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-number/)

排序传递性：
a+b<=b+a
b+c<=c+b
=>a+c<=c+a
![[Pasted image 20260223200711.png]]
[1029. 两地调度 - 力扣（LeetCode）](https://leetcode.cn/problems/two-city-scheduling/description/)
```cpp
class Solution {

public:

    int twoCitySchedCost(vector<vector<int>>& costs) {

        vector<int>diff;

        int ans=0;

        for(auto&cost:costs){

            diff.push_back(cost[1]-cost[0]);

            ans+=cost[0];

        }

        sort(diff.begin(),diff.end(),[](const int a,const int b){return a<b;});

        for(int i=0;i<costs.size()/2;i++)ans+=diff[i];

        return ans;

    }

};
```
[1553. 吃掉 N 个橘子的最少天数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/submissions/700039195/)
```cpp
class Solution {

public:

    unordered_map<int,int>dp;

  

    int minDays(int n) {

        if(n<=1)return 1;

        auto it=dp.find(n);

        if(it!=dp.end())return dp[n];

        int ans=min(n%2+1+minDays(n/2),n%3+1+minDays(n/3));

        dp.insert({n,ans});

        return ans;

    }

};
```

[线段重合_牛客题霸_牛客网](https://www.nowcoder.com/practice/1ae8d0b6bb4e4bcdbf64ec491f63fc37)
```cpp
#include<iostream>

#include<vector>

#include<queue>

#include<algorithm>

using namespace std;

  

int n,s,e;

vector<vector<int>>lines;

  

int solve(){

    sort(lines.begin(),lines.end(),[](const vector<int>&a,const vector<int>&b){return a[0]<b[0];});

    priority_queue<int,vector<int>,greater<>>heap;

    int ans=0;

    for(int i=0;i<n;i++){

        while(!heap.empty()&&heap.top()<=lines[i][0])heap.pop();

        heap.push(lines[i][1]);

        ans=max(ans,(int)heap.size());

    }

    return ans;

}

  

int main(){

    cin>>n;

    for(int i=0;i<n;i++){

        cin>>s>>e;

        lines.push_back({s,e});

    }

    cout<<solve();

    return 0;

}
```
[630. 课程表 III - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-iii/submissions/700056032/)
```cpp
class Solution {

public:

    int scheduleCourse(vector<vector<int>>& courses) {

        sort(courses.begin(),courses.end(),[](const vector<int>&a,const vector<int>&b){return a[1]<b[1];});

        priority_queue<int>heap;

        int ans=0;

        for(auto&course:courses){

            if(course[0]+ans<=course[1]){

                heap.push(course[0]);

                ans+=course[0];

            }

            else{

                if(!heap.empty()&&heap.top()>course[0]){

                    ans-=heap.top()-course[0];

                    heap.pop();

                    heap.push(course[0]);

                }

            }

        }

        return heap.size();

    }

};
```
[记录详情 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/record/263692179)
```cpp
#include<iostream>

#include<queue>

using namespace std;

  

int n,w,wa,wb;

priority_queue<int,vector<int>,greater<>>heap;

  

int solve(){

    int ans=0;

    while(heap.size()>=2){

        wa=heap.top(),heap.pop();

        wb=heap.top(),heap.pop();

        ans+=wa+wb;

        heap.push(wa+wb);

    }

    return ans;

}

  

int main(){

    cin>>n;

    for(int i=0;i<n;i++){

        cin>>w;

        heap.push(w);

    }

    cout<<solve();

    return 0;

}
```


---

## 乘法快速幂

[LCR 132. 砍竹子 II - 力扣（LeetCode）](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/) 

```cpp
class Solution {

public:

    const int mod=(int)(1e9+7);

    long long power(long long x,int n,int mod){

        long long ans=1;

        while(n){

            if(n&1)ans=(ans*x)%mod;

            x=(x*x)%mod;

            n>>=1;

        }

        return ans;

    }

  

    int cuttingBamboo(int bamboo_len) {

        if(bamboo_len<=3)return bamboo_len-1;

        int tail=bamboo_len%3==0?1:(bamboo_len%3==1?4:2);

        int pow=(tail==1?bamboo_len:(bamboo_len-tail))/3;

        return power(3,pow,mod)*tail%mod;

    }

};
```

![[Pasted image 20260224185924.png]]
```cpp
#include<iostream>

#include<algorithm>

#include<ctime>

#include<random>

using namespace std;

  

int f(vector<vector<int>>&meetings,int i){

    int ans=0;

    if(i==meetings.size()){

        int cur=-1;

        for(auto&meeting:meetings){

            if(cur<=meeting[0]){

                ++ans;

                cur=meeting[1];

            }

        }

    }else{

        for(int j=i;j<meetings.size();j++){

            swap(meetings[i],meetings[j]);

            ans=max(ans,f(meetings,i+1));

            swap(meetings[i],meetings[j]);

        }

    }

    return ans;

}

  

int maxMeetings1(vector<vector<int>>&meetings){

    return f(meetings,0);

}

  

int maxMeetings2(vector<vector<int>>&meetings){

    sort(meetings.begin(),meetings.end(),[](const vector<int>&a,const vector<int>&b){

        return a[1]<b[1];

    });

    int ans=0,cur=-1;

    for(auto&meeting:meetings){

        if(cur<=meeting[0]){

            ++ans;

            cur=meeting[1];

        }

    }

    return ans;

}

  

vector<vector<int>> randomMeetings(int n,int m){

    vector<vector<int>>meetings(n,vector<int>(2,0));

    for(auto&meeting:meetings){

        int a=rand()%(m+2),b=rand()%(m+2);

        if(a==b)b=a+1;

        meeting[0]=min(a,b);

        meeting[1]=max(a,b);

    }

    return meetings;

}

  

void test(int testTimes,int maxN,int maxM){

    srand(time(nullptr));

    for(int i=0;i<testTimes;i++){

        vector<vector<int>>meetings=randomMeetings(maxN,maxM);

        int res1=maxMeetings1(meetings);

        int res2=maxMeetings2(meetings);

        if(res1!=res2){

            cout<<"测试失败，测试样例为："<<endl;

            for(auto&meeting:meetings){

                cout<<meeting[0]<<" "<<meeting[1]<<endl;

            }

            return;

        }

    }

    cout<<"测试成功"<<endl;

}

  

int main(){

    test(100,5,40);

    return 0;

}
```

[1353. 最多可以参加的会议数目 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/submissions/700245557/)
```cpp
class Solution {

public:

    int maxEvents(vector<vector<int>>& events) {

        sort(events.begin(),events.end(),[](const vector<int>&a,const vector<int>&b){

            return a[0]==b[0]?a[1]<b[1]:a[0]<b[0];

        });

        int n=events.size(),ans=0,ddl=0;

        for(auto&event:events)ddl=max(ddl,event[1]);

        priority_queue<int,vector<int>,greater<>>heap;

        for(int day=events[0][0],i=0;day<=ddl;day++){

            while(i<n&&day==events[i][0])heap.push(events[i++][1]);

            while(!heap.empty()&&day>heap.top())heap.pop();

            if(!heap.empty()){

                ++ans;

                heap.pop();

            }

        }

        return ans;

    }

};
```