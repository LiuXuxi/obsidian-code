<font color=red>先操作再查询，不支持边操作边查询</font>
## 1.差分概念
-  差分是一种和前缀相对的策略，可以当作是求和的逆运算
- ![[Pasted image 20251117154301.png]]
- 差分数组 可以维护 多次 对序列的一个区间加上一个数，并在最后询问某一位置的数或是多次徐文某一位置的数。注意修改操作一定要在查询操作之前
- 差分多用于区间修改和单点查询问题
- 有原数组a\[]
- 差分数组b\[]：初始时由a\[]通过差分计算得出，在b\[]上进行修改操作，最后对b\[]求前缀和可得到修改后的a\[]
- 差分标记数组：初始时b\[]的值全部为0，在b\[]上进行修改操作，然后对b\[]求前缀和，得到sum\[]，sum\[i]是a\[i]的修改量，在原a\[]上再加上sum\[]，才可得到修改后的a\[]

## 2.一维差分
### 1.<font color=greeen>问题描述</font>
	有一个长度为n的一维数组（下标从1开始），现在对数组进行m次操作[l,r,q]，每一次操作表示数组[l]~[r]位置增加q。
		  例如，全为0的数组a[9]（**也就是差分标记数组**）进行三次操作，分别是[2,5,3],[1,6,-2],[4,7,5]，操作后的结果为a\[9]={0,-2,1,1,6,6,3,5,0}
### 2. <font color=green>解决方式</font>
在差分数组上对每次操作进行a\[l]+q,a\[r+1]+q，再进行前缀和更新数组a。
	  例如：由于数组a本身全为0，可以做差分数组或是差分标记数组，所以可以直接在a上进行操作（<font color=red>若数组有一定元素，则必须先求出它的差分数组或者差分标记数组再操作，此外，求出的差分数组长度最好为n+2，补充下标0位置以及防止r+1操作时最后一个位置越界</font>)。
		第一次操作：0,0,3,0,0,0,-3,0,0
		第二次操作：0,-2,3,0,0,0,-3,2,0
		第三次操作：0,-2,3,0,5,0,-3,2,-5
	    对第三次操作后的数组进行前缀和，即可得到结果
### 3. ==原理==
当在差分数组b\[]上进行b\[l]+q时，对应的前缀和数组a\[l]~a\[n+1]的位置都会+q，<font color=red>也就是在任意一个位置+q，前缀和数组从这个位置开始一直到数组末尾的元素都会+q</font>。<font color=greeen>那么如何做到区间+q呢？</font>我们只需要在a\[r+1]的位置进行-q即可，因为前缀和数组从r+1位置到n位置都会进行-q，与上一次操纵的+q相抵消，实现了a\[l]~a\[r]的区间操作。我们以只进行第一次操作（<font color=red>实际可以所有操作都依次进行之后再求前缀和</font>）为例：
	  b\[2]+3：0,0,3,0,0,0,0,0,0 <font color=red>求前缀和后：</font>0,0,3,3,3,3,3,3,3
	  b\[6]-3：0,0,3,0,0,0,-3,0,0 <font color=red>求前缀和后：</font>0,0,3,3,3,3,0,0,0
### 4. [1109. 航班预订统计 - 力扣（LeetCode）](https://leetcode.cn/problems/corporate-flight-bookings/solutions/968214/hang-ban-yu-ding-tong-ji-by-leetcode-sol-5pv8/)

```cpp
class Solution {
public:
    vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
        vector<int> nums(n);
        for (auto& booking : bookings) {
            nums[booking[0] - 1] += booking[2];
            if (booking[1] < n) {
                nums[booking[1]] -= booking[2];
            }
        }
        for (int i = 1; i < n; i++) {
            nums[i] += nums[i - 1];
        }
        return nums;
    }
};
```

## 3.等差数列差分
### 1.<font color=greeen>问题描述</font>
	一开始1~n范围上的数字都是0。接下来一共有m个操作。每次操作：l~r范围上依次加上首项s、末项e、公差d的数列，最终1~n范围上的每个数字都要正确得到
		例如：在a[10]上进行一次操作为l=2,r=6,s=4,e=16,d=3，得到的结果为{0,0,4,7,10,13,16,0,0,0}
### 2. <font color=green>解决方式</font>
每个操作调用set方法，所有操作完成后在arr上生成两遍前缀和，即调用bulid方法，arr里就是最终1~n范围上的每个数字
```
	void set(int l,int r,int e,int d){
		arr[l]+=s;
		arr[l+1]+=d-s;
		arr[r+1]+=d+e;
		arr[r+2]+=e;
	}
	void build(){
		for(int i=1;i<=n;i++)arr[i]+=arr[i-1];
		for(int i=1;i<=n;i++)arr[i]+=arr[i-1];
	}
```
### 3.  ==原理==
我们从结果出发，我们想得到的数组最终应该为（假如l=2,r=6）{0,0,+s,+s+d,+s+2d,+s+3d,+s+4d,0,0,0}。我们可以观察到 l~r 位置元素都增加了s，l+1~r位置元素依次增加d，也就是几个区间增加，从一维差分我们可以知道，要实现区间区间操作需要对原数组进行差分然后前缀和，而我们的结果是<font color=red>前缀和后的数组</font>，因此<font color=red>过程逆反</font>，我们需要对结果数组进行差分，<font color=greeen>那么如何对它进行差分呢？</font>
-  <font color=greeen>第一次差分过程：</font>
	1. 我们先将结果数组进行一次加工，{0,0,+s,+s+d,+s+d+d,+s+d+d+d,+s+d+d+d+d,0,0,0}
	2. 我们首先能明显观察到 l~r 位置都增加了s，那么可以先对这个区间进行差分，得到差分数组{0,0,s,0,0,0,0,-s,0,0}，而这个差分数组对应的前缀和数组为{0,0,s,s,s,s,0,0,0}
	 3. 然后在 l+1 位置上我们想到得到 s+d ，因为已经增加了 s ，我们只需要在 l+1 ~r 位置再进行差分，得到差分数组{0,0,s,d,0,0,0,-s-d,0,0}，而这个差分数组对应的前缀和数组为{0,0,s,s+d,s+d,s+d,s+d,0,0,0}
	 4. 同理，我们再对 s+2d ,s+3d,s+4d 元素的位置进行同样的差分，得到差分数组{0,0,s,d,d,d,d,-s-4d,0,0}，而 -s-4d 其实就是 -e （等差数列公式，你懂的），再得到<font color=red>最终的差分数组{0,0,s,d,d,d,d,-e,0,0}</font>
- 我们还可以观察到在 l+1~r 位置为增长 d 的区间，对于这样的区间，我们仍然可以进行同样的差分，<font color=greeen>那么如何进行第二次差分？</font>
- <font color=greeen>第二次差分过程：</font>
	1. 我们首先想要在 l 位置得到 s ,<font color=red>其实单个元素也是区间，只是区间长度为1，并且 r= l</font>，所以我们仍然可以进行差分得到差分数组{0,0,s,-s,0,0,0,0,0,0,0}，这样我们得到的前缀和数组就只含一个 s ，{0,0,s,0,0,0,0,0,0,0,0}
	2. 接着可以明显看到 l+1~r 的位置是一个d的增长区间，所以我们进行差分得到{0,0,s,-s+d,0,0,0,-d,0,0}，对应的前缀和数组{0,0,s,d,d,d,d,0,0,0}
	3. 最后我们想要在 r+1 位置得到 -e ，所以我们参照得到 s 的过程，同理得到<font color=red>最终的差分数组{0,0,s,-s+d,0,0,0,-d-e,e,0}</font>
 得到差分数组后我们就可以总结出<font color=red>先差分两次原数组，再对得到的差分数组求前缀和</font>，而更简单的，我们直接把原数组当作<font color=red>元素不全为0的差分标记数组</font>，直接对原数组进行操作，也就是<font color=green>void set函数</font>，再求两次前缀和更新数组得到最终的区间等差数列修改的数组，也就是<font color=green>void build函数</font>
### 4. [三步必杀](http:/luogu.com.cn/problem/P4231)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;


const int MAXN = 10000005;
long long d2[MAXN]; // 二阶差分数组

int main() {
    // 优化 IO 性能
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n, m;
    cin >> n >> m;

    while (m--) {
        int l, r;
        long long s, e;
        cin >> l >> r >> s >> e;
        
        // 计算公差 d
        long long d = (e - s) / (r - l);

        // 二阶差分标准修改模板
        d2[l] += s;
        d2[l + 1] += (d - s);
        d2[r + 1] -= (d + e);
        d2[r + 2] += e;
    }

    long long max_val = 0;
    long long xor_sum = 0;
    long long curr_d1 = 0; // 当前的一阶差分值
    long long curr_a = 0;  // 当前的原数组值

    // 通过两次前缀和还原原数组
    for (int i = 1; i <= n; i++) {
        curr_d1 += d2[i];   // 二阶差分的前缀和是阶差分
        curr_a += curr_d1;  // 一阶差分的前缀和是原数组
        
        max_val = max(max_val, curr_a);
        xor_sum ^= curr_a;
    }

    cout << xor_sum << " " << max_val << endl;

    return 0;
}
```
### 5.[Lycanthropy](http:/luogu.com.cn/problem/P5026)

**解题思路：**

每个地毯的影响范围是 $[x-3w+1, x+3w-1]$，我们可以将其拆解为四个连续的等差数列段：

1. $[x-3w+1, x-2w]$：公差为 $1$，首项 $1$，末项 $w$。
    
2. $[x-2w+1, x-w]$：公差为 $0$，首项 $w$，末项 $w$。
    
3. $[x-w+1, x]$：公差为 $-1$，首项 $w-1$，末项 $0$。
    
4. **对称地**，右侧区域同理（或者直接按照题目给出的 $w-|x-pos|$ 公式分段）。
    

**坐标偏移技巧：**

题目中 $x$ 最大 $10^6$，$w$ 最大 $10^6$，地毯最左端可能达到 $x - 3w \approx -2 \times 10^6$。

为了防止数组越界，我们需要给所有坐标加上一个偏移量（Offset），通常设为 $3 \times 10^6$。


```cpp
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long ll;

const int OFFSET = 3000005; // 偏移量，防止负坐标
const int MAXN = 7000005;   // 10^6 + 2*3*10^6

ll d2[MAXN]; // 二阶差分数组

/**
 * 在 [l, r] 区间加上首项 s, 末项 e, 公差 d 的等差数列
 * 偏移量在此统一处理
 */
void add_segment(int l, int r, ll s, ll e, ll d) {
    if (l > r) return;
    l += OFFSET;
    r += OFFSET;
    d2[l] += s;
    d2[l + 1] += (d - s);
    d2[r + 1] -= (d + e);
    d2[r + 2] += e;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n, m;
    cin >> n >> m;

    for (int i = 0; i < n; ++i) {
        int w, x;
        cin >> w >> x;
        // 根据题目公式 w - |x - pos| 拆分等差数列段：
        // 1. [x-3w+1, x-2w]  s=1, e=w, d=1
        add_segment(x - 3 * w + 1, x - 2 * w, 1, w, 1);
        // 2. [x-2w+1, x-w]    s=w, e=w, d=0
        add_segment(x - 2 * w + 1, x - w, w, w, 0);
        // 3. [x-w+1, x+w-1]   s=w-1, mid=0, e=w-1 (这是一个先减后增的 V 字型)
        // 也可以拆成两段：[x-w+1, x] 和 [x+1, x+w-1]
        add_segment(x - w + 1, x, w - 1, 0, -1);
        add_segment(x + 1, x + w - 1, 1, w - 1, 1);
        // 4. [x+w, x+2w-1]    s=-w, e=-w, d=0 (注意题目公式在该范围贡献为负)
        add_segment(x + w, x + 2 * w - 1, -w, -w, 0);
        // 5. [x+2w, x+3w-1]   s=-w+1, e=0, d=1
        add_segment(x + 2 * w, x + 3 * w - 1, -w + 1, 0, 1);
    }

    ll curr_d1 = 0;
    ll curr_a = 0;
    
    // 还原数组并只输出 [1, m] 范围的结果
    for (int i = 1; i < MAXN; ++i) {
        curr_d1 += d2[i];
        curr_a += curr_d1;
        
        int real_pos = i - OFFSET;
        if (real_pos >= 1 && real_pos <= m) {
            cout << curr_a << (real_pos == m ? "" : " ");
        }
    }
    cout << endl;

    return 0;
}
```
## 4.二维差分
### 1.<font color=greeen>问题描述</font>
	在二维数组中，如果经历如下的过程
	1.批量的做如下的操作，每个操作都有独立的a,b,c,d,v，void add(a,b,c,d,v):左上角(a,b)到右下角(c,d)范围上，每个数字+v，怎么快速处理？
	2.操作做完之后，如何正确得到二维数组中每个位置的值？
### 2.<font color=green>解决方式</font>
这就是二维差分的主要工作（<font color=red>对某一矩形区间进行操作</font>，add时候快速处理，最后build得到每个位置的值，<font color=red>修改操纵必须集中在一起，不能边修改边查询</font>。
```
//(1)add方法实现，比较巧妙
void add(int a,int b,int c,int d,int k){
	diff[a][b]+=k;
	diff[c+1][b]-=k;
	diff[a][d+1]-=k;
	diff[c+1][d+1]+=k;
}

(2)build方法实现，和处理前缀和类似
void build(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			diff[i][j]+=diff[i-1][j]+diff[i][j-1]-diff[i-1][j-1];
		}
	}
}

(3)真实数据用一圈0包裹起来，可以减少很多边界讨论
```
### 3.==原理==
从二维前缀和可以知道`sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];`也可以写成`sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];`，也就是该数的前缀和为 <font color=red>上边的数的前缀和+左边的数的前缀和-左上的数的前缀和+自己</font>
#### 1.==从结果出发==
我们想要得到的结果：

| 0   | 0      | 0   | 0      | 0   |
| --- | ------ | --- | ------ | --- |
| 0   | (a,b)v | v   | v      | 0   |
| 0   | v      | v   | v      | 0   |
| 0   | v      | v   | (c,d)v | 0   |
| 0   | 0      | 0   | 0      | 0   |
由于前缀和受到上边，左边和坐上的数的影响，假如我们在差分数组里对<font color=red>某个数进行操作（如+v)</font>，则会改变前缀和数组下边，右边和右下的数的影响

| 0   | 0       | 0   | 0   | 0   |
| --- | ------- | --- | --- | --- |
| 0   | ==(a,b)+v== | ==v==   | ==v==   | ==v==   |
| 0   | ==v==       | ==v==   | ==v==   | ==v==   |
| 0   | ==v==       | ==v==   | ==v==   | ==v==   |
| 0   | ==v==       | ==v==   | ==v==   | ==v==   |
这还没有达到我们想要的结果，因此我们需要<font color=red>减去一些不必要的v</font>，也就是(c+1,b)和(a,d+1)位置-v，再<font color=red>更新前缀和数组</font>

| 0   | 0   | 0   | 0   | 0   |
| --- | --- | --- | --- | --- |
| 0   | +v  | v   | v   | 0   |
| 0   | v   | v   | v   | 0   |
| 0   | v   | v   | v   | 0   |
| 0   | 0   | 0   | 0   | -v  |
从图中我们可以看到区间下边和右边的数已经达到我们想要的结果，<font color=red>但右下角区间先是受到+v的影响，再受到两次-v的影响，得到的结果为-v</font>，所以我们再进行最后一次操作抵消-v的影响，也就是在右下区间的左上角<font color=red>(c+1,d+1)</font>再+v，再<font color=red>更新前缀和数组</font>，就可以得到结果

==在所有操作中，对差分数组进行操作的步骤就是add方法，更新前缀和数组就是build方法，而我们在实际操作中可以统一操作差分数组（加减同时进行），再一同更新前缀和数组==
#### 2.==add和build出发==
对于add方法可以画图为：

| 0   | 0             | 0          | 0        | 0               |
| --- | ------------- | ---------- | -------- | --------------- |
| 0   | ==(a,b)+v==   | (a,b+1)0   | (a,d)0   | ==(a,d+1)-v==   |
| 0   | (a+1,b)0      | (a+1,b+1)0 | (a+1,d)0 | (a+1,d+1)0      |
| 0   | (c,b)0        | (c,b+1)0   | (c,d)    | (c,d+1)0        |
| 0   | ==(c+1,b)-v== | (c+1,b+1)0 | (c+1,d)0 | ==(c+1,d+1)+v== |
根据build，也就是进行前缀和
(a,b)的前缀和=0+0+v=v
(a,b+1)的前缀和=0+v+0=v
(a,d)的前缀和=0+v+0=v
同理，将区间范围的每个数进行前缀和处理可以得到对指定区间操作的结果
 
 ### 4.[铺地毯](https:/luogu.com.cn/problem/P3397)

```cpp
#include <iostream>
#include <vector>

using namespace std;

// 定义最大范围，防止越界
const int MAXN = 1005;
int diff[MAXN][MAXN];
int res[MAXN][MAXN];

int main() {
    // 优化输入输出
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n, m;
    cin >> n >> m;

    // 1. 差分修改
    while (m--) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        
        // 执行二维差分公式
        diff[x1][y1]++;
        diff[x1][y2 + 1]--;
        diff[x2 + 1][y1]--;
        diff[x2 + 1][y2 + 1]++;
    }

    // 2. 二维前缀和还原
    // 公式：res[i][j] = res[i-1][j] + res[i][j-1] - res[i-1][j-1] + diff[i][j]
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            res[i][j] = res[i - 1][j] + res[i][j - 1] - res[i - 1][j - 1] + diff[i][j];
            cout << res[i][j] << (j == n ? "" : " ");
        }
        cout << "\n";
    }

    return 0;
}
```
### 5.[【模板】二维差分_牛客题霸_牛客网](https://www.nowcoder.com/practice/50e1a93989df42efb0b1dec386fb4ccc)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=1e3+5;
ll a[MAXN][MAXN],sum[MAXN][MAXN];
int main()
{
    int n,m,q;
    scanf("%d%d%d",&n,&m,&q);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%lld",&a[i][j]);
    while(q--)
    {
        int x1,x2,y1,y2,k;
        scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&k);
        sum[x1][y1]+=k;
        sum[x2+1][y2+1]+=k;
        sum[x2+1][y1]-=k;
        sum[x1][y2+1]-=k;
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
            a[i][j]+=sum[i][j];
        }
    for(int i=1;i<=n;i++,puts(""))
        for(int j=1;j<=m;j++)
            printf("%lld ",a[i][j]);
}

```

### 7.[用邮票贴满网格图](https://leetcode.cn/problems/stamping-the-grid/)

```cpp
```cpp
class Solution {
public:
    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {
		int n = grid.size();
		int m = grid[0].size();
		vector<vector<int>> sum(n + 1, vector<int>(m + 1, 0));
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				sum[i][j] = grid[i - 1][j - 1];
			}
		}
		build(sum);
		vector<vector<int>> diff(n + 2, vector<int>(m + 2, 0));
		for (int a = 1, c = a + stampHeight - 1; c <= n; a++, c++) {
			for (int b = 1, d = b + stampWidth - 1; d <= m; b++, d++) {
				if (sumRegion(sum, a, b, c, d) == 0) {
					add(diff, a, b, c, d,1);
				}
			}
		}
		build(diff);
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				if (grid[i][j] == 0 && diff[i + 1][j + 1] == 0)return false;
			}
		}
		return true;
    }

	int sumRegion(vector<vector<int>>& sum, int a, int b, int c,int d) {
		return sum[c][d] + sum[a - 1][b - 1] - sum[c][b - 1] - sum[a - 1][d];
	}

	void add(vector<vector<int>>& diff,int a, int b, int c, int d, int k) {
		diff[a][b] += k;
		diff[c + 1][b] -= k;
		diff[a][d + 1] -= k;
		diff[c + 1][d + 1] += k;
	}

	void build(vector<vector<int>>& diff) {
		for (int i = 1; i < diff.size(); i++) {
			for (int j = 1; j < diff[0].size(); j++) {
				diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];
			}
		}
	}
};

```

## 5.离散化技巧


在处理差分问题时，**离散化（Discretization）** 是一种极其重要的优化技巧。

它主要用于解决：**坐标范围非常大（如 $10^9$），但实际给出的操作点或区间数量很少（如 $10^5$）** 的情况。如果我们直接开辟 $10^9$ 大小的差分数组，内存会直接崩溃。

---

### 1. 核心思想

离散化的本质是压缩空间。

既然只有某些坐标点会被修改或作为区间的端点，那么两个操作点之间的巨大空白区域实际上是“无效”的。我们只需要关心这些关键点的相对顺序。

---

### 2. 标准离散化步骤

处理离散化差分通常分为四步：

1. **收集关键点**：把所有涉及到的区间左端点 $L$、右端点 $R$（有时需要 $R+1$）全部放入一个数组。
    
2. **排序与去重**：对数组排序并去除重复元素，得到一个有序的“映射表”。
    
3. **坐标映射**：使用 `lower_bound`（二分查找）将原始坐标替换为该坐标在映射表中的索引（$0, 1, 2, \dots$）。
    
4. **执行差分**：在映射后的索引空间上建立差分数组。
    

---

### 3. 代码模板（以一维为例）

假设有 $n$ 个区间修改 $[L_i, R_i]$，每个区间加 $v_i$，最后询问最大值。

```cpp
// 1. 收集坐标
vector<long long> coords;
for (auto& range : ranges) {
    coords.push_back(range.L);
    coords.push_back(range.R + 1); // 差分通常需要修改 R+1
}

// 2. 排序去重
sort(coords.begin(), coords.end());
coords.erase(unique(coords.begin(), coords.end()), coords.end());

// 3. 构建索引映射并执行差分
vector<int> diff(coords.size() + 1, 0);
for (auto& range : ranges) {
    // 通过二分查找找到离散化后的位置
    int l_idx = lower_bound(coords.begin(), coords.end(), range.L) - coords.begin();
    int r_idx = lower_bound(coords.begin(), coords.end(), range.R + 1) - coords.begin();
    
    diff[l_idx] += range.v;
    diff[r_idx] -= range.v;
}

// 4. 求前缀和获取原值
int max_val = 0, current = 0;
for (int i = 0; i < coords.size(); i++) {
    current += diff[i];
    max_val = max(max_val, current);
}
```

---

### 4. 为什么要处理 $R+1$？

在离散化中，处理边界要非常小心。

- 如果你的差分逻辑是 `diff[L]++, diff[R+1]--`，那么 **$R+1$ 这个坐标也必须加入离散化数组中**。
    
- 如果不把 $R+1$ 放入坐标系，你在映射时就找不到 $R+1$ 对应的索引，或者找出的索引是错误的。
    

---

### 5. 进阶：扫描线法（无需显式差分数组）

当坐标离散化后，如果你只需要求最大值或统计覆盖情况，有一种更简洁的**扫描线**写法。它不需要显式地去重，而是把每个操作转化为“事件”。

```cpp
struct Event {
    long long pos;
    int type; // +1 表示进入区间，-1 表示离开
    bool operator<(const Event& other) const {
        return pos < other.pos || (pos == other.pos && type < other.type);
    }
};

vector<Event> events;
for (auto& r : ranges) {
    events.push_back({r.L, 1});
    events.push_back({r.R + 1, -1});
}
sort(events.begin(), events.end());

int max_val = 0, current = 0;
for (auto& e : events) {
    current += e.type;
    max_val = max(max_val, current);
}
```


### 6.[最强祝福力场](https://leetcode.cn/problems/xepqz5)


**题目分析：**

1. **力场边界**：每个力场是一个正方形，中心 $(x, y)$，边长 $side$。左下角 $(x - \frac{side}{2}, y - \frac{side}{2})$，右上角 $(x + \frac{side}{2}, y + \frac{side}{2})$。
    
2. **坐标处理**：由于边长除以 2 可能产生 `.5`，为了避免浮点数精度问题，我们可以将所有坐标**乘以 2**。
    
3. **核心难点**：坐标范围极大（高达 $10^9$），但矩形数量较少（$N \le 100$）。这提示我们要使用**坐标离散化**。
    

**解题逻辑：**

1. **坐标映射**：收集所有矩形的上下左右边界坐标，去重并排序，映射到 $0, 1, 2 \dots$ 的小整数区间。
    
2. **二维差分**：在离散化后的网格上，对每个矩形区域执行二维差分操作（`+1`, `-1`）。
    
3. **还原与求最值**：通过二维前缀和还原网格，找到最大值。
    


```cpp
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

class Solution {
public:
    int fieldOfGreatestBlessing(vector<vector<int>>& forceField) {
        int n = forceField.size();
        vector<long long> xs, ys;

        // 1. 扩大两倍坐标避免浮点数，并收集所有边界
        for (auto& f : forceField) {
            long long x = f[0], y = f[1], side = f[2];
            // 矩形范围：[2x-side, 2x+side]
            long long x1 = 2 * x - side, x2 = 2 * x + side;
            long long y1 = 2 * y - side, y2 = 2 * y + side;
            xs.push_back(x1); xs.push_back(x2);
            ys.push_back(y1); ys.push_back(y2);
        }

        // 2. 离散化：排序并去重
        sort(xs.begin(), xs.end());
        xs.erase(unique(xs.begin(), xs.end()), xs.end());
        sort(ys.begin(), ys.end());
        ys.erase(unique(ys.begin(), ys.end()), ys.end());

        auto get_id = [](vector<long long>& vec, long long val) {
            return lower_bound(vec.begin(), vec.end(), val) - vec.begin();
        };

        // 3. 构建二维差分数组
        int nx = xs.size(), ny = ys.size();
        // 使用 vector 动态分配，防止大数组栈溢出，注意 size 为 n+2
        vector<vector<int>> diff(nx + 2, vector<int>(ny + 2, 0));

        for (auto& f : forceField) {
            long long x = f[0], y = f[1], side = f[2];
            int r1 = get_id(xs, 2 * x - side);
            int r2 = get_id(xs, 2 * x + side);
            int c1 = get_id(ys, 2 * y - side);
            int c2 = get_id(ys, 2 * y + side);

            // 二维差分标准模板 (坐标从0开始，为了防止索引越界通常用1-based或处理+1)
            diff[r1 + 1][c1 + 1]++;
            diff[r1 + 1][c2 + 2]--;
            diff[r2 + 2][c1 + 1]--;
            diff[r2 + 2][c2 + 2]++;
        }

        // 4. 二维前缀和还原并统计最大值
        int ans = 0;
        vector<vector<int>> f(nx + 2, vector<int>(ny + 2, 0));
        for (int i = 1; i <= nx; ++i) {
            for (int j = 1; j <= ny; ++j) {
                f[i][j] = f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1] + diff[i][j];
                ans = max(ans, f[i][j]);
            }
        }

        return ans;
    }
};
```