<font color=red>先操作再查询，不支持边操作边查询</font>
## 1.差分概念
-  差分是一种和前缀相对的策略，可以当作是求和的逆运算
- ![[Pasted image 20251117154301.png]]
- 差分数组 可以维护 多次 对序列的一个区间加上一个数，并在最后询问某一位置的数或是多次徐文某一位置的数。注意修改操作一定要在查询操作之前
- 差分多用于区间修改和单点查询问题
- 有原数组a\[]
- 差分数组b\[]：初始时由a\[]通过差分计算得出，在b\[]上进行修改操作，最后对b\[]求前缀和可得到修改后的a\[]
- 差分标记数组：初始时b\[]的值全部为0，在b\[]上进行修改操作，然后对b\[]求前缀和，得到sum\[]，sum\[i]是a\[i]的修改量，在原a\[]上再加上sum\[]，才可得到修改后的a\[]
 - [铺地毯](https:/luogu.com.cn/problem/P3397)
## 2.一维差分
### 1.<font color=greeen>问题描述</font>
	有一个长度为n的一维数组（下标从1开始），现在对数组进行m次操作[l,r,q]，每一次操作表示数组[l]~[r]位置增加q。
		  例如，全为0的数组a[9]（**也就是差分标记数组**）进行三次操作，分别是[2,5,3],[1,6,-2],[4,7,5]，操作后的结果为a\[9]={0,-2,1,1,6,6,3,5,0}
### 2. <font color=green>解决方式</font>
在差分数组上对每次操作进行a\[l]+q,a\[r+1]+q，再进行前缀和更新数组a。
	  例如：由于数组a本身全为0，可以做差分数组或是差分标记数组，所以可以直接在a上进行操作（<font color=red>若数组有一定元素，则必须先求出它的差分数组或者差分标记数组再操作，此外，求出的差分数组长度最好为n+2，补充下标0位置以及防止r+1操作时最后一个位置越界</font>)。
		第一次操作：0,0,3,0,0,0,-3,0,0
		第二次操作：0,-2,3,0,0,0,-3,2,0
		第三次操作：0,-2,3,0,5,0,-3,2,-5
	    对第三次操作后的数组进行前缀和，即可得到结果
### 3. ==原理==
当在差分数组b\[]上进行b\[l]+q时，对应的前缀和数组a\[l]~a\[n+1]的位置都会+q，<font color=red>也就是在任意一个位置+q，前缀和数组从这个位置开始一直到数组末尾的元素都会+q</font>。<font color=greeen>那么如何做到区间+q呢？</font>我们只需要在a\[r+1]的位置进行-q即可，因为前缀和数组从r+1位置到n位置都会进行-q，与上一次操纵的+q相抵消，实现了a\[l]~a\[r]的区间操作。我们以只进行第一次操作（<font color=red>实际可以所有操作都依次进行之后再求前缀和</font>）为例：
	  b\[2]+3：0,0,3,0,0,0,0,0,0 <font color=red>求前缀和后：</font>0,0,3,3,3,3,3,3,3
	  b\[6]-3：0,0,3,0,0,0,-3,0,0 <font color=red>求前缀和后：</font>0,0,3,3,3,3,0,0,0
### 4. [航班预定统计](http:/leetcode.cn/problems/corporate-flight-booking/description)
## 3.等差数列差分
### 1.<font color=greeen>问题描述</font>
	一开始1~n范围上的数字都是0。接下来一共有m个操作。每次操作：l~r范围上依次加上首项s、末项e、公差d的数列，最终1~n范围上的每个数字都要正确得到
		例如：在a[10]上进行一次操作为l=2,r=6,s=4,e=16,d=3，得到的结果为{0,0,4,7,10,13,16,0,0,0}
### 2. <font color=green>解决方式</font>
每个操作调用set方法，所有操作完成后在arr上生成两遍前缀和，即调用bulid方法，arr里就是最终1~n范围上的每个数字
```
	void set(int l,int r,int e,int d){
		arr[l]+=s;
		arr[l+1]+=d-s;
		arr[r+1]+=d+e;
		arr[r+2]+=e;
	}
	void build(){
		for(int i=1;i<=n;i++)arr[i]+=arr[i-1];
		for(int i=1;i<=n;i++)arr[i]+=arr[i-1];
	}
```
### 3.  ==原理==
我们从结果出发，我们想得到的数组最终应该为（假如l=2,r=6）{0,0,+s,+s+d,+s+2d,+s+3d,+s+4d,0,0,0}。我们可以观察到 l~r 位置元素都增加了s，l+1~r位置元素依次增加d，也就是几个区间增加，从一维差分我们可以知道，要实现区间区间操作需要对原数组进行差分然后前缀和，而我们的结果是<font color=red>前缀和后的数组</font>，因此<font color=red>过程逆反</font>，我们需要对结果数组进行差分，<font color=greeen>那么如何对它进行差分呢？</font>
-  <font color=greeen>第一次差分过程：</font>
	1. 我们先将结果数组进行一次加工，{0,0,+s,+s+d,+s+d+d,+s+d+d+d,+s+d+d+d+d,0,0,0}
	2. 我们首先能明显观察到 l~r 位置都增加了s，那么可以先对这个区间进行差分，得到差分数组{0,0,s,0,0,0,0,-s,0,0}，而这个差分数组对应的前缀和数组为{0,0,s,s,s,s,0,0,0}
	 3. 然后在 l+1 位置上我们想到得到 s+d ，因为已经增加了 s ，我们只需要在 l+1 ~r 位置再进行差分，得到差分数组{0,0,s,d,0,0,0,-s-d,0,0}，而这个差分数组对应的前缀和数组为{0,0,s,s+d,s+d,s+d,s+d,0,0,0}
	 4. 同理，我们再对 s+2d ,s+3d,s+4d 元素的位置进行同样的差分，得到差分数组{0,0,s,d,d,d,d,-s-4d,0,0}，而 -s-4d 其实就是 -e （等差数列公式，你懂的），再得到<font color=red>最终的差分数组{0,0,s,d,d,d,d,-e,0,0}</font>
- 我们还可以观察到在 l+1~r 位置为增长 d 的区间，对于这样的区间，我们仍然可以进行同样的差分，<font color=greeen>那么如何进行第二次差分？</font>
- <font color=greeen>第二次差分过程：</font>
	1. 我们首先想要在 l 位置得到 s ,<font color=red>其实单个元素也是区间，只是区间长度为1，并且 r= l</font>，所以我们仍然可以进行差分得到差分数组{0,0,s,-s,0,0,0,0,0,0,0}，这样我们得到的前缀和数组就只含一个 s ，{0,0,s,0,0,0,0,0,0,0,0}
	2. 接着可以明显看到 l+1~r 的位置是一个d的增长区间，所以我们进行差分得到{0,0,s,-s+d,0,0,0,-d,0,0}，对应的前缀和数组{0,0,s,d,d,d,d,0,0,0}
	3. 最后我们想要在 r+1 位置得到 -e ，所以我们参照得到 s 的过程，同理得到<font color=red>最终的差分数组{0,0,s,-s+d,0,0,0,-d-e,e,0}</font>
 得到差分数组后我们就可以总结出<font color=red>先差分两次原数组，再对得到的差分数组求前缀和</font>，而更简单的，我们直接把原数组当作<font color=red>元素不全为0的差分标记数组</font>，直接对原数组进行操作，也就是<font color=green>void set函数</font>，再求两次前缀和更新数组得到最终的区间等差数列修改的数组，也就是<font color=green>void build函数</font>
### 4. [三步必杀](http:/luogu.com.cn/problem/P4231)
### 5.[Lycanthropy](http:/luogu.com.cn/problem/P5026)
## 4.二维差分
### 1.<font color=greeen>问题描述</font>
	在二维数组中，如果经历如下的过程
	1.批量的做如下的操作，每个操作都有独立的a,b,c,d,v，void add(a,b,c,d,v):左上角(a,b)到右下角(c,d)范围上，每个数字+v，怎么快速处理？
	2.操作做完之后，如何正确得到二维数组中每个位置的值？
### 2.<font color=green>解决方式</font>
这就是二维差分的主要工作（<font color=red>对某一矩形区间进行操作</font>，add时候快速处理，最后build得到每个位置的值，<font color=red>修改操纵必须集中在一起，不能边修改边查询</font>。
```
//(1)add方法实现，比较巧妙
void add(int a,int b,int c,int d,int k){
	diff[a][b]+=k;
	diff[c+1][b]-=k;
	diff[a][d+1]-=k;
	diff[c+1][d+1]+=k;
}

(2)build方法实现，和处理前缀和类似
void build(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			diff[i][j]+=diff[i-1][j]+diff[i][j-1]-diff[i-1][j-1];
		}
	}
}

(3)真实数据用一圈0包裹起来，可以减少很多边界讨论
```
### 3.==原理==
从二维前缀和可以知道`sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];`也可以写成`sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];`，也就是该数的前缀和为 <font color=red>上边的数的前缀和+左边的数的前缀和-左上的数的前缀和+自己</font>
#### 1.==从结果出发==
我们想要得到的结果：

| 0   | 0      | 0   | 0      | 0   |
| --- | ------ | --- | ------ | --- |
| 0   | (a,b)v | v   | v      | 0   |
| 0   | v      | v   | v      | 0   |
| 0   | v      | v   | (c,d)v | 0   |
| 0   | 0      | 0   | 0      | 0   |
由于前缀和受到上边，左边和坐上的数的影响，假如我们在差分数组里对<font color=red>某个数进行操作（如+v)</font>，则会改变前缀和数组下边，右边和右下的数的影响

| 0   | 0       | 0   | 0   | 0   |
| --- | ------- | --- | --- | --- |
| 0   | ==(a,b)+v== | ==v==   | ==v==   | ==v==   |
| 0   | ==v==       | ==v==   | ==v==   | ==v==   |
| 0   | ==v==       | ==v==   | ==v==   | ==v==   |
| 0   | ==v==       | ==v==   | ==v==   | ==v==   |
这还没有达到我们想要的结果，因此我们需要<font color=red>减去一些不必要的v</font>，也就是(c+1,b)和(a,d+1)位置-v，再<font color=red>更新前缀和数组</font>

| 0   | 0   | 0   | 0   | 0   |
| --- | --- | --- | --- | --- |
| 0   | +v  | v   | v   | 0   |
| 0   | v   | v   | v   | 0   |
| 0   | v   | v   | v   | 0   |
| 0   | 0   | 0   | 0   | -v  |
从图中我们可以看到区间下边和右边的数已经达到我们想要的结果，<font color=red>但右下角区间先是受到+v的影响，再受到两次-v的影响，得到的结果为-v</font>，所以我们再进行最后一次操作抵消-v的影响，也就是在右下区间的左上角<font color=red>(c+1,d+1)</font>再+v，再<font color=red>更新前缀和数组</font>，就可以得到结果

==在所有操作中，对差分数组进行操作的步骤就是add方法，更新前缀和数组就是build方法，而我们在实际操作中可以统一操作差分数组（加减同时进行），再一同更新前缀和数组==
#### 2.==add和build出发==
对于add方法可以画图为：

| 0   | 0             | 0          | 0        | 0               |
| --- | ------------- | ---------- | -------- | --------------- |
| 0   | ==(a,b)+v==   | (a,b+1)0   | (a,d)0   | ==(a,d+1)-v==   |
| 0   | (a+1,b)0      | (a+1,b+1)0 | (a+1,d)0 | (a+1,d+1)0      |
| 0   | (c,b)0        | (c,b+1)0   | (c,d)    | (c,d+1)0        |
| 0   | ==(c+1,b)-v== | (c+1,b+1)0 | (c+1,d)0 | ==(c+1,d+1)+v== |
根据build，也就是进行前缀和
(a,b)的前缀和=0+0+v=v
(a,b+1)的前缀和=0+v+0=v
(a,d)的前缀和=0+v+0=v
同理，将区间范围的每个数进行前缀和处理可以得到对指定区间操作的结果
### 4.[二维差分模板1](https://www.nowcoder.com/practice/50e1a93989df42efb0b1dec386fb4ccc)
### 5.[二维差分模板2](https://www.luogu.com.cn/problem/P3397)
### 6.[用邮票贴满网格图](https://leetcode.cn/problems/stamping-the-grid/)
## 5.离散化技巧
[最强祝福力场](https://leetcode.cn/problems/xepqz5)