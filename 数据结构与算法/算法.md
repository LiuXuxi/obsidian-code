# 1.枚举&模拟
## 1.1枚举——基于已有知识来猜测答案的一种求解策略
- 不断地猜测，从可能的答案集合中一个一个尝试，然后再判断题目的条件是否成立，枚举每一种可能性
1. 找对答案集合
2. 答案成立条件
3. 减小枚举范围
4. 选择合适的枚举顺序
## 1.2模拟——直接模拟题目要求中的操作来求解
- 模拟题目通常码量大，操作多，难以查错
## 1.3暴力——枚举和模拟的统称，可以不做严格区分
- 暴力搜索（暴搜）：用搜索算法枚举答案（找到符合条件的答案）
- 三大玄学解题方法：暴力求解法，直观目测法，心灵感应法
## 1.4做题步骤
1. 读题意，分析题意
2. 看示例（样例），分析样例
3. 看数据范围，确定时间复杂度（1s=10^8)数据范围
4. 找思路，写代码，本地运行测试，提交
## 1.5例题
1. 枚举
	- [P1003 [NOIP 2011 提高组] 铺地毯 - 洛谷](https://www.luogu.com.cn/problem/P1003)
	- 思路：<font color=red>从后往前枚举地毯</font>（因为厚覆盖的地毯在上面，而题目正好要求最上面的地毯），如果有一个地毯满足条件就输出，并退出。如果没有，就输出-1）
	- 满足的条件：点的坐标再地毯覆盖坐标范围内
2. 模拟
	- [59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/description/)
	- 思路：生成一个n* n空矩阵mat，随后模拟整个向内环绕的填入过程：
		- 当num<=n* n时，按照从左到右，从上到下，从右到左，从下到上填入顺序循环，每次填入后：
			- 执行num+=1:得到下一个需要填入的数字
			- 更新边界：例如从左到右填完后，上边界t+=1,相当于上边界向内缩1。
	- 最终返回mat
- [P1328 [NOIP 2014 提高组] 生活大爆炸版石头剪刀布 - 洛谷](https://www.luogu.com.cn/problem/P1328)
	- 思路：将题目中的得分表补全，整理成一个整数型二维数组，我们在查看结果的时候只要将这个数组的（a[i],b[j])便可以知道结果。
	- 细节：出全都是有周期性规律的，单周期长度不一定想等
	- <font color=red>取模循环</font>![[Pasted image 20251031123354.png]]
	- x=(x+1)%na;
	- y=(y+1)%nb;
# 2.递归
1. 在数学和计算机科学中是指<font color=red>在函数的定义中使用函数自身</font>的方法，再计算机科学中还额外指一种<font color=red>通过重复将问题分解为同类的二子问题而解决问题</font>的方法
2. 递归出口：<font color=red>找全边界条件（递归中止条件）</font>
3. 递归代码的理解：<font color=red>画递归调用图/递归树</font>
	- ```
	  int fib(int x){
		  if(x==0||x==1)return 1;
		  return fib(x-1)+fib(x-2);
	  }
	  ```
	- ![[Pasted image 20251109164646.png]]
	- 该层结果返回给上一层，不能跨层返回
4. 怎么写出一个递归函数
	- 确定递归函数是干啥的，写代码过程中，只考虑当前的问题怎么解决，<font  color=red>不分析</font>下层递归怎么展开
5. 递归函数用来解决这些类似的小问题的->确定递归函数能解决什么问题，在写递归函数时，当我们需要类似小问题的答案的时候，直接调用递归函数
6. [汉诺塔问题](https://leetcode.cn/problems/hanota-lcci/)
	- 思路：简化问题，把n个盘子从A移动到C，可以用B当媒介
		1. n=1时：直接将这个盘子从A拿出放到C
		2. n=2时：假设上面的盘子是甲，下面的盘子是乙：甲A->B 乙A->C 甲B->C
		3. n时：可以把上面n-1个盘子看成一个整体（一个盘子）甲，下面的第n个盘子是乙 ：甲A->B 乙A->C 甲B->C
		4. 此时，甲：A->B这个就是一个小问题，把n-1个盘子从A移动到B，可以用C当媒介--递归，甲：B->C这个也是一个小问题，把n-1个盘子从B移动到C，可以用A当媒介--递归
		5. ```
		   递归函数move：四个参数（盘子数量x，起点柱子s，终点柱子e，媒介柱子h）s->h->e{
		   if(x==1)x s->e,return;
			   1.x-1 s->e->h move(x-1,s,h,e);
			   2.x s->e
			   3.x-1 h->s->e move(x-1,h,e,s)
		   }
		   ```
7. 递归改成非递归的必要性：
	1. 工程上几乎一定要改，除非确定数据量再大递归也一定不深，归并排序、快速排序、线段树、很多平衡树
	2. 算法笔试或者比赛中（能通过就不改）
8. <font color=red>mast公式</font>
	1. 所有子问题规模相同的递归才能用master公式，`T(n)=a*T(n/b)+O(n^c),a,b,c都是常数`
	2. ```
	   log(b,a)<c,复杂度：O(n^c)
	   log(b,a)>c,复杂度：O(n^log(b,a))
	   log(b,a)==c,复杂度：O(n^c*logn)
	   ```
	3. `T(n)=2*T(n/2)+O(n*logn)`时间复杂度是`O(n*(logn)^2`证明过程较复杂，记住即可
# 3.分治
1. 把一个<font color=red>复杂的问题分成两个或更多的相同或不相同的子问题</font>，子问题相互独立，知道最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。---最优子结构性质
2. 递归是一种编程技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体问题的算法思想
3. [最大子数组和](https://leetcode.cn/problems/maximum-subarray/)
	- 思路
		1. 暴力：枚举起点和终点，计算区间内的和，取最大值。时间复杂度：O(n^2)
		2. 分治：时间复杂度：O(nlogn)
			1. 取中心点m=(l+r)/2。和最大的区间要么在中心点左边，要么在中心点右边，要么横跨中心点，使用问题分解为求这不三部分的最大区间和，然后取最大值。---分成三个独立的小问题，分治。
			2. 中心点左右边的最大区间和：和原问题相同，递归。
			3. 横跨中心点的最大区间和：贪心求解---从中心点往左右两边延申。
				1. 从中心点不断往左延申，同时记录最大值lmax
				2. 从中心点不断往右延申，同时记录最大值rman
				3. 横跨中心点的最大区间和：lmax+rmax
		3. 动态规划：线性动态规划。时间复杂度O(n).
			1. 状态：dp[i]=x以第i个元素结尾的和最大的区间，最大和是x
			2. 初始状态：dp[0]=nums[0]
			3. 转移方程：dp[i]=max(dp[i-1]+nums[i],nums[i])
			4. 最终答案：max(dp[i])
# 4.前缀和
1. 可以简单理解为<font color=red>数列的前i项的和</font>，是一种重要的预处理方式，一般是用来进行数组的预处理，提高后续操作效率的，多用于求区间和——<font color=red>所有数组下标从1开始</font>
	1. <font color=red>一维</font>：有n个正整数放在数组A里，现在要求一个新的数组sum，新数组的第i个数sum\[i]是原数组A第1到第i个数的和
		- ```
		  sum[1]=a[1];
		  sum[i]=sum[i-1]+a[i];
		  a[l]~~a[r]=sum[r]-sum[l-1];
		  ```
	2. <font color=red>二维</font>：有n* m个的正整数放到二维数组A中，现在要求一个新的二维数组sum，新数组sum\[i]\[j]是原数组A\[1]\[1]到A\[i]\[j]的和（矩形范围）
		- ![[Pasted image 20251114141328.png]]
		- ```
		  //sum数组初始化全为0
		  sum[1][1]=a[1][1];
		  sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];
		  ```
		- ![[Pasted image 20251114141856.png]]
		- ```
		  a[x][y]~~a[i][j](x<=i,y<=j)
		  ans=sum[i][j]-sum[i][y-1]-sum[x-1][j]+sum[x-1][y-1]; 
		  ```
		- ![[Pasted image 20251114143126.png]]
1. 多维前缀和的普通求解方法几乎都是基于<font color=red>容斥原理</font>：
	- 在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种计数方法，，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理
2. [求区间和](https:/luogu.com.cn/problem/B3612)
3. [最大正方形](https:/luogu.com.cn/problem/P1387)
	- 思路：
		1. 先枚举边长L，再枚举正方形左上角(i,j)，判断正方形内的元素和是否为正方形面积（元素不是0就是1），如果是则ans=max(L,ans)。时间复杂度O(n^5);
		2. <font color=red>考虑优化</font>：求矩形内元素和当然可以使用二维前缀和。也就是：sum为前缀和数组。a为矩阵元素。预处理：sum\[i]\[j]=sum\[i-1]\[j]+sum\[i]\[j-1]-sum\[i-1]\[j-1]+a\[i]\[j];然后就可以把o(n^5)优化到O(n^3)