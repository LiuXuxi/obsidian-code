# 1.枚举&模拟
## 1.1枚举——基于已有知识来猜测答案的一种求解策略
- 不断地猜测，从可能的答案集合中一个一个尝试，然后再判断题目的条件是否成立，枚举每一种可能性
1. 找对答案集合
2. 答案成立条件
3. 减小枚举范围
4. 选择合适的枚举顺序
## 1.2模拟——直接模拟题目要求中的操作来求解
- 模拟题目通常码量大，操作多，难以查错
## 1.3暴力——枚举和模拟的统称，可以不做严格区分
- 暴力搜索（暴搜）：用搜索算法枚举答案（找到符合条件的答案）
- 三大玄学解题方法：暴力求解法，直观目测法，心灵感应法
## 1.4做题步骤
1. 读题意，分析题意
2. 看示例（样例），分析样例
3. 看数据范围，确定时间复杂度（1s=10^8)数据范围
4. 找思路，写代码，本地运行测试，提交
## 1.5例题
1. 枚举
	- [P1003 [NOIP 2011 提高组] 铺地毯 - 洛谷](https://www.luogu.com.cn/problem/P1003)
	- 思路：<font color=red>从后往前枚举地毯</font>（因为厚覆盖的地毯在上面，而题目正好要求最上面的地毯），如果有一个地毯满足条件就输出，并退出。如果没有，就输出-1）
	- 满足的条件：点的坐标再地毯覆盖坐标范围内
2. 模拟
	- [59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/description/)
	- 思路：生成一个n* n空矩阵mat，随后模拟整个向内环绕的填入过程：
		- 当num<=n* n时，按照从左到右，从上到下，从右到左，从下到上填入顺序循环，每次填入后：
			- 执行num+=1:得到下一个需要填入的数字
			- 更新边界：例如从左到右填完后，上边界t+=1,相当于上边界向内缩1。
	- 最终返回mat
- [P1328 [NOIP 2014 提高组] 生活大爆炸版石头剪刀布 - 洛谷](https://www.luogu.com.cn/problem/P1328)
	- 思路：将题目中的得分表补全，整理成一个整数型二维数组，我们在查看结果的时候只要将这个数组的（a[i],b[j])便可以知道结果。
	- 细节：出全都是有周期性规律的，单周期长度不一定想等
	- <font color=red>取模循环</font>![[Pasted image 20251031123354.png]]
	- x=(x+1)%na;
	- y=(y+1)%nb;
# 2.递归
1. 在数学和计算机科学中是指<font color=red>在函数的定义中使用函数自身</font>的方法，再计算机科学中还额外指一种<font color=red>通过重复将问题分解为同类的二子问题而解决问题</font>的方法
2. 递归出口：<font color=red>找全边界条件（递归中止条件）</font>
3. 递归代码的理解：<font color=red>画递归调用图/递归树</font>
	- ```
	  int fib(int x){
		  if(x==0||x==1)return 1;
		  return fib(x-1)+fib(x-2);
	  }
	  ```
	- ![[Pasted image 20251109164646.png]]
	- 该层结果返回给上一层，不能跨层返回
4. 怎么写出一个递归函数
	- 确定递归函数是干啥的，写代码过程中，只考虑当前的问题怎么解决，<font  color=red>不分析</font>下层递归怎么展开
5. 递归函数用来解决这些类似的小问题的->确定递归函数能解决什么问题，在写递归函数时，当我们需要类似小问题的答案的时候，直接调用递归函数
6. [汉诺塔问题](https://leetcode.cn/problems/hanota-lcci/)
	- 思路：简化问题，把n个盘子从A移动到C，可以用B当媒介
		1. n=1时：直接将这个盘子从A拿出放到C
		2. n=2时：假设上面的盘子是甲，下面的盘子是乙：甲A->B 乙A->C 甲B->C
		3. n时：可以把上面n-1个盘子看成一个整体（一个盘子）甲，下面的第n个盘子是乙 ：甲A->B 乙A->C 甲B->C
		4. 此时，甲：A->B这个就是一个小问题，把n-1个盘子从A移动到B，可以用C当媒介--递归，甲：B->C这个也是一个小问题，把n-1个盘子从B移动到C，可以用A当媒介--递归
		5. ```
		   递归函数move：四个参数（盘子数量x，起点柱子s，终点柱子e，媒介柱子h）s->h->e{
		   if(x==1)x s->e,return;
			   1.x-1 s->e->h move(x-1,s,h,e);
			   2.x s->e
			   3.x-1 h->s->e move(x-1,h,e,s)
		   }
		   ```
7. 递归改成非递归的必要性：
	1. 工程上几乎一定要改，除非确定数据量再大递归也一定不深，归并排序、快速排序、线段树、很多平衡树
	2. 算法笔试或者比赛中（能通过就不改）
8. <font color=red>mast公式</font>
	1. 所有子问题规模相同的递归才能用master公式，`T(n)=a*T(n/b)+O(n^c),a,b,c都是常数`
	2. ```
	   log(b,a)<c,复杂度：O(n^c)
	   log(b,a)>c,复杂度：O(n^log(b,a))
	   log(b,a)==c,复杂度：O(n^c*logn)
	   ```
	3. `T(n)=2*T(n/2)+O(n*logn)`时间复杂度是`O(n*(logn)^2`证明过程较复杂，记住即可
# 3.分治
1. 把一个<font color=red>复杂的问题分成两个或更多的相同或不相同的子问题</font>，子问题相互独立，知道最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。---最优子结构性质
2. 递归是一种编程技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体问题的算法思想
3. [最大子数组和](https://leetcode.cn/problems/maximum-subarray/)
	- 思路
		1. 暴力：枚举起点和终点，计算区间内的和，取最大值。时间复杂度：O(n^2)
		2. 分治：时间复杂度：O(nlogn)
			1. 取中心点m=(l+r)/2。和最大的区间要么在中心点左边，要么在中心点右边，要么横跨中心点，使用问题分解为求这不三部分的最大区间和，然后取最大值。---分成三个独立的小问题，分治。
			2. 中心点左右边的最大区间和：和原问题相同，递归。
			3. 横跨中心点的最大区间和：贪心求解---从中心点往左右两边延申。
				1. 从中心点不断往左延申，同时记录最大值lmax
				2. 从中心点不断往右延申，同时记录最大值rman
				3. 横跨中心点的最大区间和：lmax+rmax
		3. 动态规划：线性动态规划。时间复杂度O(n).
			1. 状态：dp[i]=x以第i个元素结尾的和最大的区间，最大和是x
			2. 初始状态：dp[0]=nums[0]
			3. 转移方程：dp[i]=max(dp[i-1]+nums[i],nums[i])
			4. 最终答案：max(dp[i])
# 4.前缀和
1. 可以简单理解为<font color=red>数列的前i项的和</font>，是一种重要的预处理方式，一般是用来进行数组的预处理，提高后续操作效率的，多用于求区间和——<font color=red>所有数组下标从1开始</font>
	1. <font color=red>一维</font>：有n个正整数放在数组A里，现在要求一个新的数组sum，新数组的第i个数sum\[i]是原数组A第1到第i个数的和
		- ```
		  sum[1]=a[1];
		  sum[i]=sum[i-1]+a[i];
		  a[l]~~a[r]=sum[r]-sum[l-1];
		  ```
	2. <font color=red>二维</font>：有n* m个的正整数放到二维数组A中，现在要求一个新的二维数组sum，新数组sum\[i]\[j]是原数组A\[1]\[1]到A\[i]\[j]的和（矩形范围）
		- ![[Pasted image 20251114141328.png]]
		- ```
		  //sum数组初始化全为0
		  sum[1][1]=a[1][1];
		  sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];
		  ```
		- ![[Pasted image 20251114141856.png]]
		- ```
		  a[x][y]~~a[i][j](x<=i,y<=j)
		  ans=sum[i][j]-sum[i][y-1]-sum[x-1][j]+sum[x-1][y-1]; 
		  ```
		- ![[Pasted image 20251114143126.png]]
2. 多维前缀和的普通求解方法几乎都是基于<font color=red>容斥原理</font>：
	- 在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种计数方法，，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理
3. [求区间和](https:/luogu.com.cn/problem/B3612)
4. [最大正方形](https:/luogu.com.cn/problem/P1387)
	- 思路：
		1. 先枚举边长L，再枚举正方形左上角(i,j)，判断正方形内的元素和是否为正方形面积（元素不是0就是1），如果是则ans=max(L,ans)。时间复杂度O(n^5);
		2. <font color=red>考虑优化</font>：求矩形内元素和当然可以使用二维前缀和。也就是：sum为前缀和数组。a为矩阵元素。预处理：sum\[i]\[j]=sum\[i-1]\[j]+sum\[i]\[j-1]-sum\[i-1]\[j-1]+a\[i]\[j];然后就可以把o(n^5)优化到O(n^3)
# 5.差分
<font color=red>先操作再查询，不支持边操作边查询</font>
## 1.差分概念
-  差分是一种和前缀相对的策略，可以当作是求和的逆运算
- ![[Pasted image 20251117154301.png]]
- 差分数组 可以维护 多次 对序列的一个区间加上一个数，并在最后询问某一位置的数或是多次徐文某一位置的数。注意修改操作一定要在查询操作之前
- 差分多用于区间修改和单点查询问题
- 有原数组a\[]
- 差分数组b\[]：初始时由a\[]通过差分计算得出，在b\[]上进行修改操作，最后对b\[]求前缀和可得到修改后的a\[]
- 差分标记数组：初始时b\[]的值全部为0，在b\[]上进行修改操作，然后对b\[]求前缀和，得到sum\[]，sum\[i]是a\[i]的修改量，在原a\[]上再加上sum\[]，才可得到修改后的a\[]
 - [铺地毯](https:/luogu.com.cn/problem/P3397)
## 2.一维差分
1. <font color=greeen>问题描述：</font>有一个长度为n的一维数组（**下标从1开始**），现在对数组进行m次操作\[l,r,q]，每一次操作表示数组\[l]~\[r]位置增加q。
	  例如，全为0的数组a\[9]（**也就是差分标记数组**）进行三次操作，分别是\[2,5,3],\[1,6,-2],\[4,7,5]，操作后的结果为a\[9]={0,-2,1,1,6,6,3,5,0}
2. <font color=green>解决方式：</font>在差分数组上对每次操作进行a\[l]+q,a\[r+1]+q，再进行前缀和更新数组a。
		例如：由于数组a本身全为0，可以做差分数组或是差分标记数组，所以可以直接在a上进行操作（<font color=red>若数组有一定元素，则必须先求出它的差分数组或者差分标记数组再操作，此外，求出的差分数组长度最好为n+2，补充下标
		0位置以及防止r+1操作时最后一个位置越界</font>)。
		第一次操作：0,0,3,0,0,0,-3,0,0
		第二次操作：0,-2,3,0,0,0,-3,2,0
		第三次操作：0,-2,3,0,5,0,-3,2,-5
	    对第三次操作后的数组进行前缀和，即可得到结果
3. ==原理：==当在差分数组b\[]上进行b\[l]+q时，对应的前缀和数组a\[l]~a\[n+1]的位置都会+q，<font color=red>也就是在任意一个位置+q，前缀和数组从这个位置开始一直到数组末尾的元素都会+q</font>。<font color=greeen>那么如何做到区间+q呢？</font>我们只需要在a\[r+1]的位置进行-q即可，因为前缀和数组从r+1位置到n位置都会进行-q，与上一次操纵的+q相抵消，实现了a\[l]~a\[r]的区间操作。我们以只进行第一次操作（<font color=red>实际可以所有操作都依次进行之后再求前缀和</font>）为例：
	  b\[2]+3：0,0,3,0,0,0,0,0,0 <font color=red>求前缀和后：</font>0,0,3,3,3,3,3,3,3
	  b\[6]-3：0,0,3,0,0,0,-3,0,0 <font color=red>求前缀和后：</font>0,0,3,3,3,3,0,0,0
	5. [航班预定统计](http:/leetcode.cn/problems/corporate-flight-booking/description)
## 3.等差数列差分
1.  <font color=greeen>问题描述：</font>一开始1~n范围上的数字都是0。接下来一共有m个操作。每次操作：l~r范围上依次加上首项s、末项e、公差d的数列，最终1~n范围上的每个数字都要正确得到
			 例如：在a\[10]上进行一次操作为l=2,r=6,s=4,e=16,d=3，得到的结果为{0,0,4,7,10,13,16,0,0,0}
2. <font color=green>解决方式：</font>每个操作调用set方法，所有操作完成后在arr上生成两遍前缀和，即调用bulid方法，arr里就是最终1~n范围上的每个数字
	```
		void set(int l,int r,int e,int d){
			arr[l]+=s;
			arr[l+1]+=d-s;
			arr[r+1]+=d+e;
			arr[r+2]+=e;
		}
		void build(){
			for(int i=1;i<=n;i++)arr[i]+=arr[i-1];
			for(int i=1;i<=n;i++)arr[i]+=arr[i-1];
		}
	```
3.  ==原理：==我们从结果出发，我们想得到的数组最终应该为（假如l=2,r=6）{0,0,+s,+s+d,+s+2d,+s+3d,+s+4d,0,0,0}。我们可以观察到 l~r 位置元素都增加了s，l+1~r位置元素依次增加d，也就是几个区间增加，从一维差分我们可以知道，要实现区间区间操作需要对原数组进行差分然后前缀和，而我们的结果是<font color=red>前缀和后的数组</font>，因此<font color=red>过程逆反</font>，我们需要对结果数组进行差分，<font color=greeen>那么如何对它进行差分呢？</font>
	-  <font color=greeen>第一次差分过程：</font>
		1. 我们先将结果数组进行一次加工，{0,0,+s,+s+d,+s+d+d,+s+d+d+d,+s+d+d+d+d,0,0,0}
		2. 我们首先能明显观察到 l~r 位置都增加了s，那么可以先对这个区间进行差分，得到差分数组{0,0,s,0,0,0,0,-s,0,0}，而这个差分数组对应的前缀和数组为{0,0,s,s,s,s,0,0,0}
		 3. 然后在 l+1 位置上我们想到得到 s+d ，因为已经增加了 s ，我们只需要在 l+1 ~r 位置再进行差分，得到差分数组{0,0,s,d,0,0,0,-s-d,0,0}，而这个差分数组对应的前缀和数组为{0,0,s,s+d,s+d,s+d,s+d,0,0,0}
		 4. 同理，我们再对 s+2d ,s+3d,s+4d 元素的位置进行同样的差分，得到差分数组{0,0,s,d,d,d,d,-s-4d,0,0}，而 -s-4d 其实就是 -e （等差数列公式，你懂的），再得到<font color=red>最终的差分数组{0,0,s,d,d,d,d,-e,0,0}</font>
	- 我们还可以观察到在 l+1~r 位置为增长 d 的区间，对于这样的区间，我们仍然可以进行同样的差分，<font color=greeen>那么如何进行第二次差分？</font>
	- <font color=greeen>第二次差分过程：</font>
		1. 我们首先想要在 l 位置得到 s ,<font color=red>其实单个元素也是区间，只是区间长度为1，并且 r= l</font>，所以我们仍然可以进行差分得到差分数组{0,0,s,-s,0,0,0,0,0,0,0}，这样我们得到的前缀和数组就只含一个 s ，{0,0,s,0,0,0,0,0,0,0,0}
		2. 接着可以明显看到 l+1~r 的位置是一个d的增长区间，所以我们进行差分得到{0,0,s,-s+d,0,0,0,-d,0,0}，对应的前缀和数组{0,0,s,d,d,d,d,0,0,0}
		3. 最后我们想要在 r+1 位置得到 -e ，所以我们参照得到 s 的过程，同理得到<font color=red>最终的差分数组{0,0,s,-s+d,0,0,0,-d-e,e,0}</font>
	 得到差分数组后我们就可以总结出<font color=red>先差分两次原数组，再对得到的差分数组求前缀和</font>，而更简单的，我们直接把原数组当作<font color=red>元素不全为0的差分标记数组</font>，直接对原数组进行操作，也就是<font color=green>void set函数</font>，再求两次前缀和更新数组得到最终的区间等差数列修改的数组，也就是<font color=green>void build函数</font>
4. [三步必杀](http:/luogu.com.cn/problem/P4231)
5. [Lycanthropy](http:/luogu.com.cn/problem/P5026)
## 4.二维差分